<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>LAN Shell</title>
  
  <!-- å¼ºåˆ¶å…¨å±æ¨¡å¼ -->
  <meta name="apple-touch-fullscreen" content="yes" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="msapplication-tap-highlight" content="no" />
  
  <!-- é˜²æ­¢ç¼©æ”¾å’Œæ»šåŠ¨ -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  
  <!-- PWAé…ç½® -->
  <meta name="theme-color" content="#0f1115" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="LAN Shell" />
  <meta name="mobile-web-app-capable" content="yes" />
  
  <!-- Edge PWA ä¸“ç”¨é…ç½® -->
  <meta name="msapplication-TileColor" content="#0f1115" />
  <meta name="msapplication-config" content="none" />
  <meta name="msapplication-tap-highlight" content="no" />
  <meta name="msapplication-navbutton-color" content="#0f1115" />
  <meta name="msapplication-starturl" content="/?pwa=true&edge=true" />
  <meta name="msapplication-window" content="width=device-width;height=device-height" />
  
  <!-- å®‰å“PWAå¼ºåˆ¶å…¨å± -->
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f1115" />
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#0f1115" />
  <meta name="color-scheme" content="dark" />
  
  <!-- å¼ºåˆ¶éšè—æµè§ˆå™¨UI -->
  <meta name="mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="msapplication-navbutton-color" content="#0f1115" />
  <meta name="application-name" content="LAN Shell" />
  
  <!-- é˜²æ­¢æ˜¾ç¤ºæµè§ˆå™¨æ§ä»¶ -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-touch-fullscreen" content="yes" />
  <meta name="full-screen" content="yes" />
  <meta name="browsermode" content="application" />
  
  <!-- Web App Manifest -->
  <link rel="manifest" href="/manifest.json" />
  
  <!-- å›¾æ ‡ -->
  <link rel="apple-touch-icon" sizes="180x180" href="/icon-192.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/icon-192.png" />
  
  <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css">
  <!-- æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆCodeMirror 5ï¼‰ï¼šè¡Œå·ã€æ»šåŠ¨ã€å…‰æ ‡ç§»åŠ¨ç­‰åŸºç¡€èƒ½åŠ› -->
  <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.16/lib/codemirror.css">
  <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.16/theme/material-darker.css">
  <style id="git-branch-style" disabled>
    /* Git åˆ†æ”¯é€‰æ‹©å¼¹çª—ï¼ˆæ‡’åŠ è½½ï¼Œé¿å…åˆå§‹æ¸²æŸ“å‡ºç°åœ¨ç»ˆç«¯ï¼‰ */
    #git-branch-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1300; /* higher than term */
    }
    #git-branch-backdrop.open { display:block; }
    #git-branch-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 620px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1301; /* above backdrop */
      color:#fff;
    }
    #git-branch-modal.open { display:block; }
    #git-branch-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #git-branch-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #git-branch-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .branch-filter { width:100%; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:rgba(0,0,0,0.18); color:#fff; padding:10px 12px; box-sizing:border-box; font-size:13px; margin-bottom:10px; }
    .branch-columns { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .branch-list { max-height: 48vh; overflow:auto; border:1px solid rgba(255,255,255,0.10); border-radius:12px; padding:6px; background: rgba(0,0,0,0.08); }
    .branch-item { padding:10px 12px; border-radius:10px; cursor:pointer; display:flex; align-items:center; gap:8px; font-size:13px; }
    .branch-item:hover { background: rgba(255,255,255,0.08); }
    .branch-item.active { background: rgba(45,140,255,0.25); border:1px solid rgba(45,140,255,0.55); }
    .branch-tag { font-size:11px; opacity:0.8; padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,0.15); }
    #branch-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    #branch-actions button { border-radius: 12px; padding: 10px 14px; font-size: 13px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.08); color: #fff; cursor: pointer; font-weight: 700; }
    #branch-actions button.primary { background: rgba(45, 140, 255, 0.92); border-color: rgba(45, 140, 255, 0.65); }
    #branch-actions button.danger { background: rgba(255, 80, 80, 0.24); border-color: rgba(255, 80, 80, 0.60); color:#ff6b6b; }
    #branch-status { font-size:12px; opacity:0.8; margin-top:8px; line-height:1.4; }
  </style>
  <style>
    :root { 
      --bg:#0f1115; 
      --panel:#f5f5f7; 
      --accent:#2d8cff; 
      --sidebar-width:380px;
      --vh: 1vh;
    }
    
    html {
      height: 100%;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
    }
    
    body { 
      margin:0; 
      display:flex; 
      flex-direction:column; 
      height:100vh; 
      height: calc(var(--vh, 1vh) * 100);
      font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background:var(--bg); 
      color:#eee;
      overflow-x:hidden;
      width:100vw;
      max-width:100vw;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    #top { 
      display:flex; 
      gap:8px; 
      padding:12px; 
      align-items:center; 
      background:#131722; 
      box-shadow:0 2px 8px rgba(0,0,0,.4); 
      border-bottom:1px solid #2a2d3a;
      transition:margin-left 0.3s;
      margin-left:var(--sidebar-width);
      flex-wrap:wrap;
    }
    body.sidebar-collapsed #top {
      margin-left:0;
    }
    
	    /* removed: logout button + mobile toolbar */
    #path { flex:1; padding:10px 12px; border-radius:8px; border:1px solid #3a3d4a; background:#1c1f2b; color:#f7f7f7; font-size:14px; transition:border-color 0.2s; }
    #path:focus { outline:none; border-color:var(--accent); }
    button { padding:10px 16px; border:none; border-radius:8px; background:var(--accent); color:#fff; cursor:pointer; font-weight:600; font-size:14px; transition:all 0.2s; }
    button:hover { background:#1e7ae8; transform:translateY(-1px); }
    button:active { transform:translateY(0); }
    #main { 
      display:flex; 
      flex:1; 
      min-height:0; 
      position:relative;
      overflow:hidden;
      width:100%;
      max-width:100vw;
    }
    
    /* æŠ˜å çŠ¶æ€ä¸‹çš„å¸ƒå±€è°ƒæ•´ */
    body.sidebar-collapsed #main {
      margin-left:0;
    }
    body.sidebar-collapsed #top {
      padding-left:60px; /* ä¸ºå±•å¼€æŒ‰é’®ç•™ç©ºé—´ */
    }
    
    /* ä¾§è¾¹æ æ ·å¼ */
    #sidebar { 
      width:var(--sidebar-width); 
      height:100%; 
      background:var(--panel); 
      color:#111; 
      display:flex; 
      flex-direction:column; 
      box-shadow:2px 0 10px rgba(0,0,0,.15);
      transition:transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position:fixed;
      left:0;
      top:0;
      z-index:10;
    }
    #sidebar.collapsed { 
      transform:translateX(-100%); 
    }
    
	    /* æŠ˜å æŒ‰é’® */
	    #toggle-sidebar {
	      position:absolute;
	      left:calc(var(--sidebar-width) - 20px);
	      top:50%;
	      transform:translateY(-50%);
	      width:40px;
	      height:60px;
	      background: rgba(45, 140, 255, 0.18);
	      border: 1px solid rgba(45, 140, 255, 0.28);
	      border-radius:0 8px 8px 0;
	      color:#fff;
	      cursor:pointer;
	      display:flex;
	      align-items:center;
	      justify-content:center;
	      font-size:16px;
	      transition:all 0.3s;
	      box-shadow:2px 0 12px rgba(0,0,0,.22);
	      z-index:12;
	    }
    body.sidebar-collapsed #toggle-sidebar {
      left:10px !important;
      border-radius:8px !important;
    }
	    #toggle-sidebar:hover {
	      background: rgba(45, 140, 255, 0.30);
	      border-color: rgba(45, 140, 255, 0.55);
	      width:45px;
	    }
    
    /* ä¾§è¾¹æ å¤´éƒ¨ */
    #sidebar-header {
      padding:16px;
      background:#e8e8ea;
      border-bottom:1px solid #d1d1d6;
      font-weight:600;
      font-size:16px;
      color:#1d1d1f;
      display:flex;
      align-items:center;
      gap:8px;
    }
    #sidebar-header .spacer { flex:1; }
    #sidebar-actions {
      display:flex;
      gap:8px;
      margin-left:auto;
      align-items:center;
    }
    #sidebar-actions button {
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
      font-weight:700;
      background: rgba(26, 30, 44, 0.92);
      border: 1px solid rgba(0,0,0,0.10);
      color:#111;
      cursor:pointer;
    }
    #sidebar-actions button:hover { background: rgba(26, 30, 44, 0.84); }
    #sidebar-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.55);
      color:#fff;
    }
    #sidebar-actions button.ghost {
      background: rgba(255,255,255,0.12);
      border-color: rgba(0,0,0,0.12);
      color:#111;
    }

    /* æ–°å»º/ä¸Šä¼ å¼¹çª— */
    #file-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #file-modal-backdrop.open { display:block; }
    #file-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 520px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #file-modal.open { display:block; }
    .file-modal-row {
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom: 12px;
    }
    .file-modal-title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    .file-modal-close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .file-modal-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .file-modal-field input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    .file-modal-actions {
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .file-modal-actions button {
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 700;
    }
    .file-modal-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }

    /* è§£å‹å¼¹çª— + ç›®å½•é€‰æ‹© */
    #extract-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #extract-modal-backdrop.open { display:block; }
    #extract-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 560px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #extract-modal.open { display:block; }
    #extract-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #extract-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #extract-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .extract-field { margin-top:10px; }
    .extract-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .extract-field input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    .extract-inline {
      display:flex;
      gap:10px;
      align-items:center;
    }
    .extract-inline input { flex:1; min-width:0; }
    .extract-inline button {
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 800;
      white-space:nowrap;
    }
    .extract-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    .extract-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }
    .extract-actions button.danger {
      background: rgba(255, 80, 80, 0.24);
      border-color: rgba(255, 80, 80, 0.60);
      color:#ff6b6b;
    }

    #dirpicker {
      margin-top:12px;
      border-top:1px solid rgba(255,255,255,0.10);
      padding-top:12px;
      display:none;
    }
    #dirpicker.open { display:block; }
    #dirpicker .hint { font-size:12px; opacity:0.8; margin-bottom:8px; }
    #dirpicker-list {
      max-height: 42vh;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:12px;
      padding:8px;
      background: rgba(0,0,0,0.10);
    }
    .dir-item {
      padding:10px 10px;
      border-radius:10px;
      cursor:pointer;
      display:flex;
      gap:10px;
      align-items:center;
      font-size:13px;
    }
    .dir-item:hover { background: rgba(255,255,255,0.07); }
    #dirpicker-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:10px; }

    /* æ–‡ä»¶æ“ä½œï¼šé•¿æŒ‰èœå• */
    #op-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #op-modal-backdrop.open { display:block; }
    #op-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 560px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #op-modal.open { display:block; }
    #op-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #op-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #op-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    #op-path {
      font-size:12px;
      opacity:0.85;
      word-break: break-all;
      margin-bottom: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(0,0,0,0.10);
    }
    #op-actions { display:flex; gap:10px; flex-wrap:wrap; }
    #op-actions button {
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 800;
    }
    #op-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }
    #op-actions button.danger {
      background: rgba(255, 80, 80, 0.24);
      border-color: rgba(255, 80, 80, 0.60);
      color:#ff6b6b;
    }

    /* å¤åˆ¶/å‰ªåˆ‡ï¼šé€‰æ‹©ç›®æ ‡ç›®å½• + å‘½å */
    #xfer-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #xfer-modal-backdrop.open { display:block; }
    #xfer-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 600px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #xfer-modal.open { display:block; }
    #xfer-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #xfer-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #xfer-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .xfer-field { margin-top:10px; }
    .xfer-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .xfer-field input, .xfer-field select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    #xfer-dir-list {
      margin-top: 10px;
      max-height: 42vh;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:12px;
      padding:8px;
      background: rgba(0,0,0,0.10);
    }
    #xfer-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    #xfer-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }
    #xfer-actions button.danger {
      background: rgba(255, 80, 80, 0.24);
      border-color: rgba(255, 80, 80, 0.60);
      color:#ff6b6b;
    }

    /* æ–‡ä»¶åˆ—è¡¨ */
    #list { 
      flex:1; 
      overflow:auto; 
      padding:12px; 
      scrollbar-width:thin;
      scrollbar-color:#ccc transparent;
    }
    #list::-webkit-scrollbar { width:6px; }
    #list::-webkit-scrollbar-track { background:transparent; }
    #list::-webkit-scrollbar-thumb { background:#ccc; border-radius:3px; }
    #list::-webkit-scrollbar-thumb:hover { background:#999; }
    
    #term-wrap { 
      flex:1; 
      min-width:0; 
      display:flex; 
      flex-direction:column; 
      transition:margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      margin-left:var(--sidebar-width);
      will-change:margin-left;
    }
    body.sidebar-collapsed #term-wrap {
      margin-left:0;
    }
    
    #tabs { 
      display:flex; 
      gap:8px; 
      padding:12px; 
      background:#1b2030; 
      border-bottom:1px solid #2a2d3a; 
      overflow-x:auto;
      scrollbar-width:none;
    }
    #tabs::-webkit-scrollbar { display:none; }
    
    .tab { 
      padding:8px 12px; 
      background:#2a3045; 
      color:#eee; 
      border-radius:8px; 
      cursor:pointer; 
      display:flex; 
      align-items:center; 
      gap:8px; 
      white-space:nowrap;
      transition:all 0.2s;
      border:1px solid transparent;
    }
    .tab:hover { background:#3a4055; }
    .tab.active { 
      background:#3c83f6; 
      border-color:#5a9cff;
      box-shadow:0 2px 8px rgba(60,131,246,0.3);
    }
    .tab .close { 
      font-weight:bold; 
      cursor:pointer; 
      padding:2px 4px;
      border-radius:4px;
      transition:background 0.2s;
    }
    .tab .close:hover { background:rgba(255,255,255,0.2); }
    
		    #term-area { 
		      position:relative; 
		      flex:1; 
		      background:#0f1115;
		      overflow:hidden;
	      /* è§¦æ§æ‰‹åŠ¿ï¼šç»ˆç«¯åŒºåŸŸä¼˜å…ˆç”¨äºæ»šåŠ¨ï¼›åº•éƒ¨â€œç©ºç™½è§¦æ§æ¿â€åŒºåŸŸç”¨äºå•æŒ‡ç§»åŠ¨å…‰æ ‡ */
	      touch-action: pan-x pan-y;
		      overscroll-behavior: contain;
		      width:100%;
		      max-width:100%;
		      /* åº•éƒ¨ä¸ç•™å†…è¾¹è·ï¼šè®©ç»ˆç«¯å†…å®¹åŒºåŸŸä¸ä¸‹æ–¹è§¦æ‘¸æ¿ç´§è´´ï¼Œé¿å…å‡ºç°â€œç©ºéš™â€ */
		      padding:5px 5px 0 5px;
		      box-sizing:border-box;
		    }
		    .term-pane { 
		      position:absolute; 
		      /* åº•éƒ¨ä¸ç•™ç©ºï¼šè®©ç»ˆç«¯å†…å®¹åŒºåŸŸç›´æ¥è´´åˆ°è§¦æ‘¸æ¿ä¸Š */
		      inset:5px 5px 0 5px;
		      overflow:hidden;
		      /* ç»å¯¹å®šä½æ—¶ç”± inset å†³å®šå°ºå¯¸ï¼Œé¿å…åŒæ—¶æŒ‡å®š width/height é€ æˆåº•éƒ¨é”™è¯¯ç•™ç™½ */
		      display:flex;
		    }
		    /* ä¿®å¤éƒ¨åˆ†ç§»åŠ¨ç«¯æµè§ˆå™¨ï¼ˆå¦‚ Android Edgeï¼‰å‡ºç°â€œç»ˆç«¯åº•éƒ¨æ­»åŒºâ€ï¼š
		       xterm çš„ .xterm å¯èƒ½æŒ‰ rows è‡ªç„¶é«˜åº¦æ¸²æŸ“ï¼Œæœªæ’‘æ»¡å®¹å™¨ï¼Œå¯¼è‡´åº•éƒ¨ç•™ä¸‹å¯è§ä½†ä¸å¯äº¤äº’çš„ç©ºç™½å¸¦ã€‚ */
		    .term-pane > .xterm {
		      flex:1 1 auto;
		      width:100%;
		      height:100%;
		    }
		    .term-pane .xterm-viewport {
		      height:100% !important;
		    }

		    /* æ–‡æœ¬ç¼–è¾‘å™¨é¢æ¿ï¼šä¸ç»ˆç«¯ pane åŒçº§ï¼Œå¤ç”¨ tabs/å³ä¾§å†…å®¹åŒº */
		    .editor-pane {
		      position:absolute;
		      inset:5px;
		      overflow:hidden;
		      display:flex;
		      flex-direction:column;
		      background:#0f1115;
		      border:1px solid rgba(255,255,255,0.06);
		      border-radius:10px;
		    }
		    .editor-toolbar {
		      display:flex;
		      align-items:center;
		      gap:10px;
		      padding:8px 10px;
		      background:#1b2030;
		      border-bottom:1px solid rgba(255,255,255,0.08);
		      box-sizing:border-box;
		    }
		    .editor-title {
		      flex:1;
		      min-width:0;
		      font-size:13px;
		      color:rgba(255,255,255,0.85);
		      white-space:nowrap;
		      overflow:hidden;
		      text-overflow:ellipsis;
		    }
		    .editor-actions {
		      display:flex;
		      gap:8px;
		    }
		    .mini-btn {
		      padding:8px 10px;
		      border-radius:10px;
		      font-size:12px;
		      font-weight:700;
		      background:rgba(45, 140, 255, 0.92);
		      border:1px solid rgba(45, 140, 255, 0.55);
		      color:#fff;
		    }
		    .mini-btn.secondary {
		      background:rgba(255,255,255,0.08);
		      border-color:rgba(255,255,255,0.12);
		      color:rgba(255,255,255,0.9);
		    }
		    .mini-btn.danger {
		      background:rgba(255, 80, 80, 0.24);
		      border-color:rgba(255, 80, 80, 0.60);
		      color:#ff6b6b;
		    }
		    .editor-body {
		      flex:1;
		      min-height:0;
		      height:0; /* é¿å…éƒ¨åˆ†ç§»åŠ¨ç«¯/Safari ä¸‹ % é«˜åº¦åœ¨ flex å®¹å™¨é‡Œè®¡ç®—ä¸ç¨³å®š */
		      overflow:hidden;
		    }
		    .editor-pane .CodeMirror {
		      height:100%;
		      font-size:13px;
		      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		    }
		    /* è§¦å±è®¾å¤‡ä¸Šåº•éƒ¨æœ‰ #cursor-padï¼šç»™ç¼–è¾‘å™¨æ»šåŠ¨åŒºç•™å‡ºâ€œå®‰å…¨åº•éƒ¨â€ï¼Œé¿å…æœ€åå‡ è¡Œè¢«è§¦æ§æ¿è§†è§‰/äº¤äº’é®æŒ¡ */
		    @media (pointer: coarse) {
		      .editor-pane .CodeMirror-scroll {
		        padding-bottom: calc(clamp(64px, 18vh, 240px) + env(safe-area-inset-bottom, 0px));
		        box-sizing: content-box;
		      }
		    }

	    /* åº•éƒ¨ç©ºç™½è§¦æ§æ¿ï¼šä»…åœ¨è§¦å±è®¾å¤‡ä¸Šæ˜¾ç¤ºï¼Œç”¨äºå•æŒ‡æ»‘åŠ¨ç§»åŠ¨å…‰æ ‡ */
	    #cursor-pad {
	      display:none;
	      flex:0 0 auto;
	      height:64px;
	      background:#0f1115;
	      border-top:1px solid rgba(255,255,255,0.08);
	      touch-action:none;
	      user-select:none;
	      -webkit-user-select:none;
	      -webkit-touch-callout:none;
	      box-sizing:border-box;
	    }
	    @media (pointer: coarse) {
	      #cursor-pad {
	        display:block;
	        /* è§¦å±è®¾å¤‡ä¸Šå°½é‡æŠŠâ€œç»ˆç«¯ä¸‹æ–¹çš„ç©ºç™½â€åˆ†é…ç»™å…‰æ ‡è§¦æ§æ¿ï¼Œæå‡å¯ç”¨é¢ç§¯ */
	        height: clamp(64px, 18vh, 240px);
	        /* iOS åº•éƒ¨å®‰å…¨åŒºä¹Ÿå¹¶å…¥è§¦æ§æ¿åŒºåŸŸï¼Œé¿å…å‡ºç°â€œçœ‹å¾—è§ä½†æ‘¸ä¸åˆ°â€çš„ç©ºç™½ */
	        padding-bottom: env(safe-area-inset-bottom, 0px);
	      }
	    }

	    /* ç¼–è¾‘å™¨é¡µé¢ä¸éœ€è¦åº•éƒ¨è§¦æ§æ¿ï¼šè®©ç¼–è¾‘å™¨å æ»¡å¯ç”¨ç©ºé—´ */
	    body.editor-active #cursor-pad {
	      display: none !important;
	    }
    
    .item { 
      padding:10px 12px; 
      border-radius:8px; 
      margin-bottom:6px; 
      cursor:pointer; 
      transition:all 0.2s;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
      font-weight:500;
    }
    .item:hover { 
      background:rgba(0,0,0,0.08); 
      transform:translateX(2px);
    }
    .item .file-name { 
      flex:1; 
      color:#1d1d1f;
      font-weight:600;
      font-size:15px;
    }
    .item .file-tag { 
      color:#666; 
      font-size:11px; 
      background:#f0f0f0;
      padding:3px 7px;
      border-radius:4px;
      font-weight:500;
    }
    
    /* PWAæ ·å¼ä¼˜åŒ– - å…¨å±æ¨¡å¼ */
    @media (display-mode: fullscreen), (display-mode: standalone) {
      body {
        /* å…¨å±æ¨¡å¼ä¸‹çš„é¢å¤–æ ·å¼ */
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        height: 100vh;
        height: 100dvh; /* åŠ¨æ€è§†å£é«˜åº¦ */
        overflow: hidden;
      }
      
      #top {
        /* çŠ¶æ€æ é€‚é… */
        padding-top: calc(12px + env(safe-area-inset-top));
      }
      
      /* éšè—æ‰€æœ‰å¯èƒ½çš„æµè§ˆå™¨UI */
      html {
        overflow: hidden;
        height: 100%;
        height: 100dvh;
      }
      
      /* å¼ºåˆ¶å…¨å± */
      body {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
      }
    }
    
    /* é˜²æ­¢é¡µé¢è¢«æ‹‰åŠ¨ */
    body {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }
    
    /* ç¦ç”¨æ–‡æœ¬é€‰æ‹©å’Œé•¿æŒ‰èœå• */
    * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* å…è®¸è¾“å…¥æ¡†é€‰æ‹©æ–‡æœ¬ */
    input, textarea, .xterm-helper-textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    
    /* ç¡®ä¿æŒ‰é’®å¯ä»¥æ¥æ”¶è§¦æ‘¸äº‹ä»¶ */
    button {
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
    }
    @media (max-width: 768px) {
      :root { --sidebar-width:300px; }
      
      body {
        overflow-x:hidden !important;
        position:fixed;
        width:100vw;
        height:100vh;
      }
      
      #top { 
        padding:8px;
        width:100%;
        box-sizing:border-box;
        overflow:hidden;
        justify-content:space-between;
      }
      
	      /* removed: mobile toolbar */
      
      /* æ‰‹æœºç«¯éšè—éƒ¨åˆ†æŒ‰é’®æ–‡å­— */
      #load, #newTerm {
        font-size:12px;
        padding:6px 8px;
      }
      
      #path {
        flex:1;
        min-width:120px;
        font-size:12px;
      }
      
      #main {
        overflow:hidden !important;
        width:100vw;
        max-width:100vw;
      }
      
      #sidebar {
        max-width:100vw;
        box-sizing:border-box;
      }
      
      #term-wrap {
        max-width:100vw;
        box-sizing:border-box;
        overflow:hidden;
      }
      
      #term-area {
        overflow:hidden !important;
        width:100% !important;
        max-width:100vw !important;
        touch-action: pan-x pan-y;
        overscroll-behavior: contain;
      }
      
      .term-pane {
        overflow:hidden !important;
        width:100% !important;
        max-width:100vw !important;
      }
      
      /* å¼ºåˆ¶ç»ˆç«¯å†…å®¹ä¸è¶…å‡ºå±å¹• */
      .xterm-viewport {
        overflow-x:hidden !important;
        width:100% !important;
        max-width:100vw !important;
      }
      
      .xterm-screen {
        overflow-x:hidden !important;
        width:100% !important;
        max-width:100vw !important;
      }
      
      #tabs {
        overflow-x:auto;
        scrollbar-width:none;
        -ms-overflow-style:none;
      }
      
      #tabs::-webkit-scrollbar {
        display:none;
      }
      
      button { padding:8px 12px; font-size:13px; }
	    }

	    /* å³ä¾§æ‚¬æµ®å…¥å£ + æŠ½å±‰ */
	    #side-actions {
	      position: fixed;
	      right: calc(12px + env(safe-area-inset-right, 0px));
	      top: 50%;
	      transform: translate(0, -50%);
	      transition: transform 0.22s ease;
	      z-index: 9999;
	      display: flex;
	      flex-direction: column;
	      align-items: center;
	      gap: 10px;
	    }
	    #side-actions.open {
	      transform: translate(calc(-1 * var(--drawer-w, 0px)), -50%);
	    }

	    #drawerToggleBtn {
	      width: 52px;
	      height: 52px;
	      border-radius: 14px;
	      border: 1px solid rgba(255,255,255,0.20);
	      background: transparent;
	      color: #fff;
	      cursor: pointer;
	      box-shadow: 0 10px 26px rgba(0,0,0,0.40);
	      font-size: 20px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	    }
	    #drawerToggleBtn:hover {
	      background: rgba(45, 140, 255, 0.12);
	      border-color: rgba(45, 140, 255, 0.45);
	    }

	    #cmdsetFloatingBtn {
	      width: 52px;
	      height: 52px;
	      border-radius: 14px;
	      border: 1px solid rgba(255,255,255,0.20);
	      background: transparent;
	      color: #fff;
	      cursor: pointer;
	      box-shadow: 0 10px 26px rgba(0,0,0,0.40);
	      font-size: 18px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	    }
	    #cmdsetFloatingBtn:hover {
	      background: rgba(45, 140, 255, 0.12);
	      border-color: rgba(45, 140, 255, 0.45);
	    }

	    #comboFloatingBtn {
	      width: 52px;
	      height: 52px;
	      border-radius: 14px;
	      border: 1px solid rgba(255,255,255,0.20);
	      background: transparent;
	      color: #fff;
	      cursor: pointer;
	      box-shadow: 0 10px 26px rgba(0,0,0,0.40);
	      font-size: 16px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	    }
	    #comboFloatingBtn:hover {
	      background: rgba(45, 140, 255, 0.12);
	      border-color: rgba(45, 140, 255, 0.45);
	    }

	    #drawer-backdrop {
	      position: fixed;
	      inset: 0;
	      background: rgba(0,0,0,0.55);
	      z-index: 9998;
	      display: none;
	    }
	    #drawer-backdrop.open { display: block; }

	    #right-drawer {
	      position: fixed;
	      top: 0;
	      right: 0;
	      height: 100vh;
	      height: 100dvh;
	      width: auto;
	      padding: 12px 10px;
	      box-sizing: border-box;
	      background: rgba(19, 23, 34, 0.96);
	      border-left: 1px solid rgba(255,255,255,0.08);
	      transform: translateX(110%);
	      transition: transform 0.22s ease;
	      z-index: 9999;
	      display: flex;
	      flex-direction: column;
	      gap: 12px;
	      backdrop-filter: blur(10px);
	    }
	    #right-drawer.open { transform: translateX(0); }

	    #right-drawer .drawer-header {
	      display: flex;
	      align-items: center;
	      justify-content: space-between;
	      gap: 10px;
	      padding-top: calc(6px + env(safe-area-inset-top, 0px));
	    }
	    #right-drawer .drawer-title {
	      display: none;
	    }
	    #right-drawer .drawer-title {
	      font-weight: 700;
	      letter-spacing: 0.2px;
	    }
	    #drawerCloseBtn {
	      width: 40px;
	      height: 40px;
	      border-radius: 12px;
	      border: 1px solid rgba(255,255,255,0.10);
	      background: rgba(26, 30, 44, 0.92);
	      color: #fff;
	      cursor: pointer;
	    }
	    #right-drawer .drawer-actions {
	      display: flex;
	      flex-direction: column;
	      gap: 10px;
	      margin-top: 8px;
	    }
	    #right-drawer .drawer-actions button {
	      width: 84px;
	      border-radius: 12px;
	      border: 1px solid rgba(255,255,255,0.10);
	      background: rgba(26, 30, 44, 0.92);
	      color: #fff;
	      padding: 10px 12px;
	      font-size: 13px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	      gap: 10px;
	    }
	    #right-drawer .drawer-actions button .k {
	      opacity: 0.75;
	      font-size: 12px;
	      border: 1px solid rgba(255,255,255,0.12);
	      padding: 2px 8px;
	      border-radius: 999px;
	    }
	    #right-drawer .drawer-actions button.active {
	      background: rgba(45, 140, 255, 0.16);
	      border-color: rgba(45, 140, 255, 0.65);
	      box-shadow: 0 0 0 1px rgba(45, 140, 255, 0.25);
	    }

		    /* Paste modal (long-press on PASTE) */
		    #paste-modal-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.60);
		      z-index: 10000;
		      display: none;
		    }
		    #paste-modal-backdrop.open { display: block; }
		    #paste-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 680px);
		      max-height: min(80vh, 720px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
		      z-index: 10001;
		      display: none;
		      padding: 14px;
		      box-sizing: border-box;
		    }
		    #paste-modal.open { display: block; }
		    #paste-modal .row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 10px;
		    }
		    #paste-modal .title {
		      font-weight: 700;
		      font-size: 14px;
		      opacity: 0.9;
		    }
		    #paste-modal .close {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #paste-input {
		      width: 100%;
		      height: min(46vh, 420px);
		      resize: vertical;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.12);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      box-sizing: border-box;
		      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		      font-size: 13px;
		      line-height: 1.35;
		      outline: none;
		    }
		    #paste-modal .actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		      margin-top: 10px;
		    }
		    #paste-modal .actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		    }
		    #paste-modal .actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }

		    /* ç»„åˆé”®å¼¹çª— */
		    #combo-modal-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.60);
		      z-index: 10020;
		      display: none;
		    }
		    #combo-modal-backdrop.open { display: block; }
		    #combo-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 520px);
		      max-height: min(80vh, 520px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
		      z-index: 10021;
		      display: none;
		      padding: 14px;
		      box-sizing: border-box;
		    }
		    #combo-modal.open { display: block; }
		    #combo-modal .row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 12px;
		    }
		    #combo-modal .title {
		      font-weight: 800;
		      font-size: 14px;
		      opacity: 0.9;
		    }
		    #combo-modal .close {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    .combo-toggle {
		      display: flex;
		      gap: 8px;
		      margin-bottom: 10px;
		    }
		    .combo-toggle button {
		      flex: 1;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      font-size: 13px;
		      cursor: pointer;
		    }
		    .combo-toggle button.active {
		      background: rgba(45, 140, 255, 0.22);
		      border-color: rgba(45, 140, 255, 0.65);
		    }
		    #combo-input {
		      width: 100%;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.12);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      box-sizing: border-box;
		      font-size: 14px;
		      outline: none;
		      margin-bottom: 12px;
		    }
		    #combo-modal .actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		    }
		    #combo-modal .actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #combo-modal .actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }

		    /* æŒ‡ä»¤é›†é¡µé¢ï¼ˆå…¨å±è¦†ç›–ï¼‰ */
		    #cmdset-page {
		      position: fixed;
		      inset: 0;
		      background: rgba(15, 17, 21, 0.98);
		      z-index: 10050;
		      display: none;
		      flex-direction: column;
		      box-sizing: border-box;
		      padding: calc(env(safe-area-inset-top, 0px)) calc(env(safe-area-inset-right, 0px)) calc(env(safe-area-inset-bottom, 0px)) calc(env(safe-area-inset-left, 0px));
		    }
		    #cmdset-page.open { display: flex; }

		    /* Git é¡µé¢ï¼ˆå¤ç”¨æŒ‡ä»¤é›†æ ·å¼ï¼‰ */
		    #git-page {
		      position: fixed;
		      inset: 0;
		      background: rgba(15, 17, 21, 0.98);
		      z-index: 10050;
		      display: none;
		      flex-direction: column;
		      box-sizing: border-box;
		      padding: calc(env(safe-area-inset-top, 0px)) calc(env(safe-area-inset-right, 0px)) calc(env(safe-area-inset-bottom, 0px)) calc(env(safe-area-inset-left, 0px));
		    }
		    #git-page.open { display: flex; }

		    #gitCwdText {
		      margin-top: 3px;
		      font-size: 12px;
		      opacity: 0.75;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }

		    /* Git å›é€€å¼¹çª— */
		    #git-reset-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.55);
		      z-index: 10090;
		      display: none;
		    }
		    #git-reset-backdrop.open { display: block; }
		    #git-reset-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 520px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      z-index: 10100;
		      display: none;
		      padding: 12px;
		      box-sizing: border-box;
		    }
		    #git-reset-modal.open { display: block; }
		    #git-reset-modal .row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 10px;
		    }
		    #git-reset-modal .title { font-weight: 800; font-size: 14px; }
		    #git-reset-modal .close {
		      width: 32px;
		      height: 32px;
		      border-radius: 10px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #git-reset-modal .desc {
		      font-size: 13px;
		      opacity: 0.9;
		      white-space: pre-wrap;
		      line-height: 1.5;
		      padding: 6px 2px 10px;
		    }
		    #git-reset-modal .actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		    }
		    #git-reset-modal .actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #git-reset-modal .actions button:disabled {
		      opacity: 0.45;
		      cursor: not-allowed;
		    }
		    #git-reset-modal .actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }
		    #git-reset-modal .actions button.danger {
		      background: rgba(255, 80, 80, 0.24);
		      border-color: rgba(255, 80, 80, 0.60);
		      color: #ff6b6b;
		    }

		    .cmdset-topbar {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      padding: 12px;
		      border-bottom: 1px solid rgba(255,255,255,0.08);
		      background: rgba(19, 23, 34, 0.98);
		    }
		    .cmdset-icon-btn {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		      display: inline-flex;
		      align-items: center;
		      justify-content: center;
		      font-size: 16px;
		      padding: 0;
		    }
		    .cmdset-title-wrap { flex: 1; min-width: 0; }
		    .cmdset-title { font-weight: 800; font-size: 14px; letter-spacing: 0.2px; }
		    .cmdset-breadcrumb {
		      margin-top: 3px;
		      font-size: 12px;
		      opacity: 0.75;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }
		    .cmdset-top-actions {
		      display: flex;
		      gap: 8px;
		      flex-wrap: wrap;
		      justify-content: flex-end;
		    }
		    .cmdset-small-btn {
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      font-size: 13px;
		      cursor: pointer;
		      white-space: nowrap;
		    }
		    .cmdset-small-btn.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }

		    .cmdset-body {
		      flex: 1;
		      min-height: 0;
		      overflow: auto;
		      padding: 12px;
		      box-sizing: border-box;
		    }
		    .cmdset-empty {
		      padding: 18px 12px;
		      opacity: 0.75;
		      font-size: 13px;
		    }

		    .cmdset-item {
		      display: flex;
		      align-items: center;
		      gap: 10px;
		      padding: 10px 12px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.08);
		      background: rgba(26, 30, 44, 0.62);
		      cursor: pointer;
		      margin-bottom: 10px;
		      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
		    }
		    .cmdset-item:hover {
		      transform: translateX(2px);
		      background: rgba(26, 30, 44, 0.82);
		      border-color: rgba(45, 140, 255, 0.20);
		    }
		    /* Git æäº¤çŠ¶æ€ï¼šå·²æ¨é€ / æœªæ¨é€ / æœªçŸ¥ */
		    .cmdset-item.git-pushed {
		      background: rgba(16, 185, 129, 0.12);
		      border-color: rgba(16, 185, 129, 0.28);
		    }
		    .cmdset-item.git-unpushed {
		      background: rgba(245, 158, 11, 0.12);
		      border-color: rgba(245, 158, 11, 0.28);
		    }
		    .cmdset-item.git-unknown {
		      background: rgba(148, 163, 184, 0.10);
		      border-color: rgba(148, 163, 184, 0.22);
		    }
		    .cmdset-item .ico { width: 22px; text-align: center; opacity: 0.9; }
		    .cmdset-item .name {
		      flex: 1;
		      min-width: 0;
		      font-weight: 750;
		      font-size: 14px;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }
		    .cmdset-item .meta {
		      font-size: 12px;
		      opacity: 0.7;
		      white-space: nowrap;
		      max-width: 40%;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }
		    .cmdset-edit {
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.18);
		      background: rgba(255,255,255,0.08);
		      color: #fff;
		      padding: 8px 10px;
		      font-size: 13px;
		      cursor: pointer;
		    }
		    .cmdset-edit:hover {
		      background: rgba(45, 140, 255, 0.18);
		      border-color: rgba(45, 140, 255, 0.45);
		    }

		    /* æŒ‡ä»¤é›†ï¼šé€šç”¨å¼¹çª— */
		    #cmdset-modal-backdrop, #cmdset-confirm-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.60);
		      z-index: 10060;
		      display: none;
		    }
		    #cmdset-modal-backdrop.open, #cmdset-confirm-backdrop.open { display: block; }

		    #cmdset-modal, #cmdset-confirm-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 720px);
		      max-height: min(82vh, 760px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
		      z-index: 10061;
		      display: none;
		      padding: 14px;
		      box-sizing: border-box;
		    }
		    #cmdset-modal.open, #cmdset-confirm-modal.open { display: block; }

		    .cmdset-modal-row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 10px;
		    }
		    .cmdset-modal-title { font-weight: 800; font-size: 14px; opacity: 0.95; }
		    .cmdset-modal-close {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    .cmdset-field { margin-top: 10px; }
		    .cmdset-field label { display:block; font-size: 12px; opacity:0.8; margin-bottom: 6px; }
		    .cmdset-field input, .cmdset-field textarea {
		      width: 100%;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.12);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      box-sizing: border-box;
		      font-size: 13px;
		      outline: none;
		    }
		    .cmdset-field textarea {
		      height: min(34vh, 340px);
		      resize: vertical;
		      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		      line-height: 1.35;
		    }
		    .cmdset-modal-actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		      margin-top: 12px;
		    }
		    .cmdset-modal-actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    .cmdset-modal-actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }
		    .cmdset-modal-actions button.danger {
		      background: rgba(255, 80, 80, 0.24);
		      border-color: rgba(255, 80, 80, 0.60);
		      color: #ff6b6b;
		    }
		  </style>
		</head>
		<body>
  <div id="top">
    <input id="path" value="." />
    <button id="load">æ‰“å¼€ç›®å½•</button>
    <button id="newTerm">åœ¨æ­¤å¯åŠ¨ç»ˆç«¯</button>
	    <!-- removed: mobile toolbar + logout -->
	  </div>
  <div id="main">
    <button id="toggle-sidebar" title="æŠ˜å /å±•å¼€ä¾§è¾¹æ ">â€¹</button>
    <div id="sidebar">
      <div id="sidebar-header">
        <span>ğŸ“</span>
        <span>æ–‡ä»¶æµè§ˆå™¨</span>
        <span class="spacer"></span>
        <div id="sidebar-actions">
          <button id="toggleHiddenBtn" class="ghost" title="æ˜¾ç¤ºéšè—æ–‡ä»¶">æ˜¾ç¤ºéšè—</button>
          <button id="newFileBtn" class="primary" title="æ–°å»º/ä¸Šä¼ ">ï¼‹</button>
        </div>
      </div>
      <div id="list"></div>
    </div>
		    <div id="term-wrap">
		      <div id="tabs"></div>
		      <div id="term-area"></div>
		      <div id="cursor-pad" aria-hidden="true"></div>
		    </div>
		  </div>

	  <!-- å³ä¾§æ‚¬æµ®å…¥å£ + æŠ½å±‰ -->
	  <div id="side-actions">
	    <button id="drawerToggleBtn" title="Tools">â‰¡</button>
	    <button id="cmdsetFloatingBtn" title="æŒ‡ä»¤é›†">âŒ˜</button>
	    <button id="comboFloatingBtn" title="ç»„åˆé”®">âŒ¥âŒ˜</button>
	  </div>
		  <div id="drawer-backdrop"></div>
		  <aside id="right-drawer" aria-hidden="true">
		    <div class="drawer-header">
		      <div class="drawer-title">Tools</div>
		      <button id="drawerCloseBtn" title="Close">Ã—</button>
		    </div>
			    <div class="drawer-actions">
		      <button id="orientationLockBtn" title="æ—‹è½¬ï¼šé”å®šç«–å±/å…è®¸æ—‹è½¬">
		        <span class="k">ROT</span>
		      </button>
		      <button id="undoBtn" title="æ’¤å›ï¼ˆå‘é€ Ctrl+U æ¸…ç©ºå½“å‰è¾“å…¥è¡Œï¼‰">
		        <span class="k">UNDO</span>
		      </button>
			      <button id="tabBtn" title="Tab">
			        <span class="k">TAB</span>
			      </button>
			      <button id="enterBtn" title="Enter">
			        <span class="k">ENTER</span>
			      </button>
			      <button id="continueBtn" title="ESC, then continue, then Enter">
		        <span class="k">CONT</span>
		      </button>
		      <button id="escBtn" title="Send ESC">
		        <span class="k">ESC</span>
		      </button>
		      <button id="ctrlCBtn" title="Send Ctrl+C">
		        <span class="k">^C</span>
		      </button>
		    </div>
		  </aside>

			  <!-- é•¿æŒ‰ PASTE å¼¹å‡ºè¾“å…¥æ¡† -->
		  <div id="paste-modal-backdrop" aria-hidden="true"></div>
			  <div id="paste-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">PASTE</div>
			      <button class="close" id="pasteModalCloseBtn" title="Close">Ã—</button>
			    </div>
			    <textarea id="paste-input" placeholder="Paste text hereâ€¦" spellcheck="false" autocapitalize="off" autocorrect="off"></textarea>
			    <div class="actions">
			      <button id="pasteModalCancelBtn">Cancel</button>
			      <button id="pasteModalOkBtn" class="primary">OK</button>
			    </div>
			  </div>

			  <!-- æ–°å»º/ä¸Šä¼ æ–‡ä»¶å¼¹çª— -->
			  <div id="file-modal-backdrop" aria-hidden="true"></div>
			  <div id="file-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="file-modal-row">
			      <div class="file-modal-title">æ–°å»º / ä¸Šä¼ æ–‡ä»¶</div>
			      <button class="file-modal-close" id="fileModalCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div class="file-modal-field">
			      <label>å½“å‰ç›®å½•</label>
			      <input id="fileModalDir" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="file-modal-field" style="margin-top:10px;">
			      <label>åç§°</label>
			      <input id="newEntryNameInput" placeholder="ä¾‹å¦‚ï¼šnotes.txt æˆ– docs" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <input id="uploadFileInput" type="file" style="display:none;" />
			    <div class="file-modal-actions">
			      <button id="uploadBtn">ä¸Šä¼ æ–‡ä»¶</button>
			      <button id="createEmptyFileBtn" class="primary">æ–°å»ºæ–‡ä»¶</button>
			      <button id="createEmptyDirBtn" class="primary">æ–°å»ºæ–‡ä»¶å¤¹</button>
			    </div>
			  </div>

			  <!-- è§£å‹å¼¹çª—ï¼ˆå«ç›®å½•é€‰æ‹©å™¨ï¼‰ -->
			  <div id="extract-modal-backdrop" aria-hidden="true"></div>
			  <div id="extract-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">è§£å‹</div>
			      <button class="close" id="extractModalCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div class="extract-field">
			      <label>å‹ç¼©åŒ…è·¯å¾„</label>
			      <input id="extractArchivePath" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="extract-field">
			      <label>è§£å‹åˆ°ç›®å½•</label>
			      <div class="extract-inline">
			        <input id="extractDestPath" spellcheck="false" autocapitalize="off" autocorrect="off" />
			        <button id="pickDestBtn" title="é€‰æ‹©ç›®å½•">é€‰æ‹©</button>
			      </div>
			    </div>
			    <div class="extract-field" style="margin-top:10px;">
			      <label style="display:flex;align-items:center;gap:8px;">
			        <input type="checkbox" id="extractOverwrite" style="width:16px;height:16px;" />
			        <span>å…è®¸è¦†ç›–åŒåæ–‡ä»¶</span>
			      </label>
			    </div>
			    <div class="extract-actions">
			      <button id="extractCancelBtn" class="danger">å–æ¶ˆ</button>
			      <button id="extractOkBtn" class="primary">å¼€å§‹è§£å‹</button>
			    </div>

			    <div id="dirpicker">
			      <div class="hint">é€‰æ‹©è§£å‹ç›®å½•ï¼ˆç‚¹å‡»æ–‡ä»¶å¤¹è¿›å…¥ï¼›ç‚¹å‡» â¬†ï¸ è¿”å›ä¸Šçº§ï¼‰</div>
			      <div class="extract-field" style="margin-top:0;">
			        <label>å½“å‰æµè§ˆç›®å½•</label>
			        <input id="dirpickerPath" spellcheck="false" autocapitalize="off" autocorrect="off" />
			      </div>
			      <div id="dirpicker-list"></div>
			      <div id="dirpicker-actions">
			        <button id="dirpickerCancelBtn">å–æ¶ˆé€‰æ‹©</button>
			        <button id="dirpickerOkBtn" class="primary">ä½¿ç”¨è¯¥ç›®å½•</button>
			      </div>
			    </div>
			  </div>

			  <!-- æ–‡ä»¶æ“ä½œï¼šé•¿æŒ‰èœå• -->
			  <div id="op-modal-backdrop" aria-hidden="true"></div>
			  <div id="op-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title" id="op-title">æ–‡ä»¶æ“ä½œ</div>
			      <button class="close" id="opCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div id="op-path"></div>
			    <div id="op-actions"></div>
			  </div>

			  <!-- å¤åˆ¶/å‰ªåˆ‡ï¼šé€‰æ‹©ç›®æ ‡ç›®å½•å¹¶å‘½å -->
			  <div id="xfer-modal-backdrop" aria-hidden="true"></div>
			  <div id="xfer-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title" id="xfer-title">å¤åˆ¶/ç§»åŠ¨</div>
			      <button class="close" id="xferCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div class="xfer-field">
			      <label>æºè·¯å¾„</label>
			      <input id="xfer-src" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="xfer-field">
			      <label>ç›®æ ‡ç›®å½•ï¼ˆç‚¹å‡»æ–‡ä»¶å¤¹è¿›å…¥ï¼›ç‚¹å‡» â¬†ï¸ è¿”å›ä¸Šçº§ï¼‰</label>
			      <input id="xfer-dest-dir" spellcheck="false" autocapitalize="off" autocorrect="off" />
			      <div id="xfer-dir-list"></div>
			    </div>
			    <div class="xfer-field">
			      <label>æ–°åç§°</label>
			      <input id="xfer-dest-name" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="xfer-field">
			      <label>åŒåå¤„ç†ï¼ˆç›®å½•åˆå¹¶æ—¶ä¹Ÿç”Ÿæ•ˆï¼‰</label>
			      <select id="xfer-conflict">
			        <option value="error">é‡åˆ°åŒåå°±æŠ¥é”™</option>
			        <option value="skip">è·³è¿‡åŒåæ–‡ä»¶</option>
			        <option value="overwrite">è¦†ç›–åŒåæ–‡ä»¶</option>
			      </select>
			    </div>
			    <div id="xfer-actions">
			      <button id="xferCancelBtn" class="danger">å–æ¶ˆ</button>
			      <button id="xferOkBtn" class="primary">æ‰§è¡Œ</button>
			    </div>
			  </div>

			  <!-- ç»„åˆé”®å¼¹çª— -->
			  <div id="combo-modal-backdrop" aria-hidden="true"></div>
			  <div id="combo-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">å‘é€ç»„åˆé”®</div>
			      <button class="close" id="comboModalCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div class="combo-toggle">
			      <button id="comboCtrlBtn">Ctrl</button>
			      <button id="comboAltBtn">Alt</button>
			      <button id="comboShiftBtn">Shift</button>
			    </div>
			    <input id="combo-input" placeholder="è¾“å…¥è¦é…åˆçš„å­—ç¬¦ï¼Œå¦‚ï¼šx" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    <div class="actions">
			      <button id="comboModalCancelBtn">å–æ¶ˆ</button>
			      <button id="comboModalOkBtn" class="primary">ç¡®å®š</button>
			    </div>
			  </div>

			  <!-- æŒ‡ä»¤é›†é¡µé¢ -->
			  <div id="cmdset-page" aria-hidden="true">
			    <div class="cmdset-topbar">
			      <button id="cmdsetBackBtn" class="cmdset-icon-btn" title="è¿”å›">â†</button>
			      <div class="cmdset-title-wrap">
			        <div class="cmdset-title">æŒ‡ä»¤é›†</div>
			        <div id="cmdsetBreadcrumb" class="cmdset-breadcrumb"></div>
			      </div>
			      <div class="cmdset-top-actions">
			        <button id="cmdsetNewCommandBtn" class="cmdset-small-btn primary">æ–°å»ºæŒ‡ä»¤</button>
			        <button id="cmdsetNewFolderBtn" class="cmdset-small-btn">æ–°å»ºæ–‡ä»¶å¤¹</button>
			      </div>
			    </div>
			    <div id="cmdsetBody" class="cmdset-body">
			      <div id="cmdsetEmpty" class="cmdset-empty" style="display:none;">æš‚æ— æŒ‡ä»¤æˆ–æ–‡ä»¶å¤¹</div>
			      <div id="cmdsetList"></div>
			    </div>
			  </div>

			  <!-- Git é¡µé¢ï¼ˆé•¿æŒ‰â€œæŒ‡ä»¤é›†â€æŒ‰é’®è¿›å…¥ï¼‰ -->
			  <div id="git-page" aria-hidden="true">
			    <div class="cmdset-topbar">
			      <button id="gitBackBtn" class="cmdset-icon-btn" title="è¿”å›">â†</button>
			      <div class="cmdset-title-wrap">
			        <div class="cmdset-title">Git</div>
			        <div class="cmdset-subtitle" id="gitCwdText">â€”</div>
			      </div>
			      <div class="cmdset-actions">
			        <button id="gitRefreshBtn" class="cmdset-icon-btn" title="åˆ·æ–°">âŸ³</button>
			        <button id="gitBranchSwitchBtn" class="cmdset-icon-btn" title="åˆ‡æ¢åˆ†æ”¯">â¤´</button>
			        <button id="gitBranchNewBtn" class="cmdset-icon-btn" title="æ–°å»ºåˆ†æ”¯">ï¼‹</button>
			      </div>
			    </div>
			    <div class="cmdset-body">
			      <div id="gitInfoBox" class="cmdset-empty"></div>
			      <div id="gitList"></div>
			    </div>
			  </div>

			  <!-- Git åˆ†æ”¯é€‰æ‹©å¼¹çª— -->
			  <div id="git-branch-backdrop" aria-hidden="true" style="display:none;"></div>
			  <div id="git-branch-modal" role="dialog" aria-modal="true" aria-hidden="true" style="display:none;">
			    <div class="row">
			      <div class="title">åˆ‡æ¢åˆ†æ”¯</div>
			      <button class="close" id="gitBranchCloseBtn" title="Close">Ã—</button>
			    </div>
			    <input id="gitBranchFilter" class="branch-filter" placeholder="æœç´¢åˆ†æ”¯ï¼ˆæœ¬åœ°/è¿œç¨‹ï¼‰" />
			    <div class="branch-columns">
			      <div>
			        <div style="font-size:12px;opacity:0.8;margin-bottom:6px;">æœ¬åœ°åˆ†æ”¯</div>
			        <div id="gitBranchLocalList" class="branch-list"></div>
			      </div>
			      <div>
			        <div style="font-size:12px;opacity:0.8;margin-bottom:6px;">è¿œç¨‹åˆ†æ”¯</div>
			        <div id="gitBranchRemoteList" class="branch-list"></div>
			      </div>
			    </div>
			    <div class="extract-field" style="margin-top:10px;">
			      <label style="display:flex;align-items:center;gap:8px;">
			        <input type="checkbox" id="gitBranchForce" style="width:16px;height:16px;" />
			        <span>å¼ºåˆ¶åˆ‡æ¢ï¼ˆä¸¢å¼ƒæœªæäº¤æ”¹åŠ¨ï¼‰</span>
			      </label>
			    </div>
			    <div id="branch-status"></div>
			    <div id="branch-actions">
			      <button id="gitBranchCancelBtn" class="danger">å–æ¶ˆ</button>
			      <button id="gitBranchOkBtn" class="primary">åˆ‡æ¢</button>
			    </div>
			  </div>

			  <!-- Git å›é€€å¼¹çª—ï¼ˆé•¿æŒ‰æœ€æ–°æœªæ¨é€æäº¤ï¼‰ -->
			  <div id="git-reset-backdrop" aria-hidden="true"></div>
			  <div id="git-reset-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">å›é€€åˆ°æ­¤æäº¤</div>
			      <button class="close" id="gitResetCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div id="gitResetDesc" class="desc"></div>
			    <div class="actions">
			      <button id="gitResetCancelBtn">å–æ¶ˆ</button>
			      <button id="gitRevertBtn">Revert</button>
			      <button id="gitResetSoftBtn" class="primary">è½¯å›é€€</button>
			      <button id="gitResetHardBtn" class="danger">ç¡¬å›é€€</button>
			    </div>
			  </div>

			  <!-- æŒ‡ä»¤é›†ï¼šæ–°å»ºå¼¹çª— -->
			  <div id="cmdset-modal-backdrop" aria-hidden="true"></div>
			  <div id="cmdset-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="cmdset-modal-row">
			      <div class="cmdset-modal-title" id="cmdsetModalTitle">æ–°å»ºæŒ‡ä»¤</div>
			      <button class="cmdset-modal-close" id="cmdsetModalCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div class="cmdset-field">
			      <label for="cmdsetNameInput">åç§°</label>
			      <input id="cmdsetNameInput" placeholder="ä¾‹å¦‚ï¼šæ‰“å¼€frp" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="cmdset-field" id="cmdsetContentField">
			      <label for="cmdsetContentInput">å†…å®¹</label>
			      <textarea id="cmdsetContentInput" placeholder="ä¾‹å¦‚ï¼šstart frp" spellcheck="false" autocapitalize="off" autocorrect="off"></textarea>
			    </div>
			    <div class="cmdset-field" id="cmdsetAutoSendField">
			      <label style="display:flex;align-items:center;gap:8px;">
			        <input type="checkbox" id="cmdsetAutoSendInput" style="width:16px;height:16px;" />
			        <span>åˆ›å»ºåç‚¹å‡»è‡ªåŠ¨å‘é€ï¼ˆä¼šè‡ªåŠ¨å›è½¦ï¼‰</span>
			      </label>
			    </div>
			    <div class="cmdset-modal-actions" style="justify-content:space-between;">
			      <button id="cmdsetModalDeleteBtn" class="danger" style="margin-right:auto; display:none;">åˆ é™¤</button>
			      <div style="display:flex; gap:10px; margin-left:auto;">
			        <button id="cmdsetModalCancelBtn">å–æ¶ˆ</button>
			        <button id="cmdsetModalOkBtn" class="primary">ç¡®å®š</button>
			      </div>
			    </div>
			  </div>

			  <!-- æŒ‡ä»¤é›†ï¼šåˆ é™¤ç¡®è®¤å¼¹çª— -->
			  <div id="cmdset-confirm-backdrop" aria-hidden="true"></div>
			  <div id="cmdset-confirm-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="cmdset-modal-row">
			      <div class="cmdset-modal-title">ç¡®è®¤åˆ é™¤</div>
			      <button class="cmdset-modal-close" id="cmdsetConfirmCloseBtn" title="Close">Ã—</button>
			    </div>
			    <div id="cmdsetConfirmText" style="font-size:13px; opacity:0.85; line-height:1.5;"></div>
			    <div class="cmdset-modal-actions">
			      <button id="cmdsetConfirmCancelBtn">å–æ¶ˆ</button>
			      <button id="cmdsetConfirmOkBtn" class="danger">åˆ é™¤</button>
			    </div>
			  </div>

			  <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
			  <!-- å¯é€‰ï¼šWebGL æ¸²æŸ“åŠ é€Ÿï¼ˆåŠ è½½å¤±è´¥æ—¶è‡ªåŠ¨é™çº§ï¼‰ -->
			  <script src="https://unpkg.com/xterm-addon-webgl/lib/xterm-addon-webgl.js"></script>
			  <script src="https://unpkg.com/codemirror@5.65.16/lib/codemirror.js"></script>
			  <script>
    // PWAå…¨å±å’Œéšè—åœ°å€æ åŠŸèƒ½
    function hideAddressBar() {
      // å¼ºåˆ¶æ»šåŠ¨éšè—åœ°å€æ 
      setTimeout(() => {
        window.scrollTo(0, 1);
        window.scrollTo(0, 0);
      }, 100);
      
      // è¯·æ±‚å…¨å±æ¨¡å¼
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(() => {
          // å…¨å±è¯·æ±‚å¤±è´¥æ—¶çš„å¤‡ç”¨æ–¹æ¡ˆ
          console.log('å…¨å±æ¨¡å¼è¯·æ±‚è¢«æ‹’ç»');
        });
      }
    }

    // æ£€æµ‹PWAæ¨¡å¼
    function isPWA() {
      // æ£€æŸ¥URLå‚æ•°
      const urlParams = new URLSearchParams(window.location.search);
      const isPWAParam = urlParams.get('pwa') === 'true';
      const isSourcePWA = urlParams.get('source') === 'pwa';
      const isEdgeParam = urlParams.get('edge') === 'true';
      
      // æ£€æŸ¥User Agentæ˜¯å¦ä¸ºEdge
      const isEdge = /Edg/i.test(navigator.userAgent);
      
      // æ£€æŸ¥display-mode
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                          window.matchMedia('(display-mode: fullscreen)').matches ||
                          window.navigator.standalone === true;
      
      // PWAæ£€æµ‹ï¼ˆæ”¯æŒæ–°æ—§å‚æ•°ï¼‰
      const isPWAMode = isPWAParam || isSourcePWA || isStandalone;
      
      // Edgeç‰¹æ®Šæ£€æµ‹
      const isEdgePWA = isEdge && (isPWAMode || isEdgeParam);
      
      return isPWAMode || isEdgePWA;
    }

    // Edge PWAæ¨¡å¼ä¸‹çš„ç‰¹æ®Šå¤„ç†
    function applyEdgePWAStyles() {
      const isEdge = /Edg/i.test(navigator.userAgent);
      
      if (isEdge && isPWA()) {
        console.log('Edge PWAæ¨¡å¼æ¿€æ´»ï¼Œåº”ç”¨ç‰¹æ®Šæ ·å¼');
        
        // Edgeä¸“ç”¨æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
          /* Edge PWA ä¸“ç”¨æ ·å¼ */
          html {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
          }
          
          body {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            margin: 0 !important;
            padding: 0 !important;
          }
          
          /* ç¡®ä¿é¡¶éƒ¨å·¥å…·æ åœ¨Edgeä¸­å¯è§ */
          #top {
            position: relative !important;
            z-index: 1000 !important;
            display: flex !important;
            flex-shrink: 0 !important;
          }
          
	          /* removed: mobile toolbar */
          
          /* Edge è°ƒæ•´ä¸»å†…å®¹åŒºåŸŸ */
          #main {
            height: calc(100vh - 60px) !important;
            height: calc(100dvh - 60px) !important;
            overflow: hidden !important;
            flex: 1 !important;
            position: relative !important;
          }
          
          /* Edge ç‰¹æ®Šå¤„ç† */
          @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
            body {
              -ms-content-zooming: none;
              -ms-user-select: none;
              -ms-touch-action: manipulation;
            }
          }
        `;
        document.head.appendChild(style);
        
        // è®¾ç½®Edge PWAæ ‡è¯†
        document.body.classList.add('edge-pwa-mode');
        document.documentElement.classList.add('edge-pwa-mode');
        
        // Edgeç‰¹æ®Šçš„å…¨å±è¯·æ±‚
        setTimeout(() => {
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(() => {
              console.log('Edgeå…¨å±è¯·æ±‚è¢«æ‹’ç»');
            });
          }
        }, 1000);
      }
    }

    // PWAæ¨¡å¼ä¸‹çš„ç‰¹æ®Šå¤„ç†
    function applyPWAStyles() {
      if (isPWA()) {
        console.log('PWAæ¨¡å¼æ¿€æ´»ï¼Œåº”ç”¨å…¨å±æ ·å¼');
        
        // æ·»åŠ PWAä¸“ç”¨æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
          html {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
          }
          
          body {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            margin: 0 !important;
            /* ä¿ç•™é¡¶éƒ¨å·¥å…·æ ç©ºé—´ */
            padding: 0 !important;
          }
          
          /* ç¡®ä¿é¡¶éƒ¨å·¥å…·æ å¯è§ */
          #top {
            position: relative !important;
            z-index: 1000 !important;
            display: flex !important;
            flex-shrink: 0 !important;
          }
          
	          /* removed: mobile toolbar */
          
          /* è°ƒæ•´ä¸»å†…å®¹åŒºåŸŸ */
          #main {
            height: calc(100vh - 60px) !important;
            height: calc(100dvh - 60px) !important;
            overflow: hidden !important;
            flex: 1 !important;
          }
          
          /* éšè—å¯èƒ½çš„æµè§ˆå™¨UI */
          body::before {
            content: '';
            position: fixed;
            top: -100px;
            left: 0;
            right: 0;
            height: 100px;
            background: #0f1115;
            z-index: -1;
          }
          
          body::after {
            content: '';
            position: fixed;
            bottom: -100px;
            left: 0;
            right: 0;
            height: 100px;
            background: #0f1115;
            z-index: -1;
          }
        `;
        document.head.appendChild(style);
        
        // è®¾ç½®PWAæ ‡è¯†
        document.body.classList.add('pwa-mode');
        document.documentElement.classList.add('pwa-mode');
      }
    }

	    // å¼ºåˆ¶éšè—ç§»åŠ¨ç«¯åœ°å€æ å’Œåº•éƒ¨æ 
	    function forceMobileFullscreen() {
	      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
	        let __lastAppliedViewportHeight = 0;
	        // è®¾ç½®è§†å£é«˜åº¦
	        const setViewportHeight = () => {
	          // ä¼˜å…ˆä½¿ç”¨ VisualViewportï¼šiOS/Android çš„è½¯é”®ç›˜å¼¹å‡ºé€šå¸¸åªä¼šè§¦å‘ visualViewport.resizeï¼Œ
	          // ä¸ä¸€å®šä¼šè§¦å‘ window.resizeï¼›å¦‚æœåªç”¨ innerHeightï¼Œç»ˆç«¯åŒºåŸŸä¸ä¼šè·Ÿç€â€œå˜çŸ®â€ï¼Œè¾“å…¥è¡Œå°±ä¼šè¢«é”®ç›˜æŒ¡ä½ã€‚
	          const vv = window.visualViewport;
	          const winH = Math.max(0, Math.floor(window.innerHeight || 0));
	          const vvH = Math.max(0, Math.floor(vv?.height || 0));
	          // Android Edge ç­‰æµè§ˆå™¨åœ¨é¡µé¢åˆå§‹åŒ–/åˆ‡åå°å›å‰å°/åœ°å€æ åŠ¨ç”»é˜¶æ®µï¼ŒvisualViewport.height å¯èƒ½çŸ­æš‚å˜æˆæå°å€¼ï¼Œ
	          // è¿™ä¼šæŠŠ body å¼ºåˆ¶å‹åˆ°å‡ åƒç´ ï¼Œè¡¨ç°ä¸ºâ€œé¡µé¢ç©ºç™½/è¢«è£åˆ‡â€ã€‚è¿™é‡Œç»™ä¸€ä¸ªä¸‹é™é˜²æŠ–ã€‚
	          const MIN_VALID_H = 180;
	          const height = (vvH >= MIN_VALID_H ? vvH : winH);
	          if (!height) return;
	          // é˜²æŠ–ï¼šé¿å… visualViewport çš„é¢‘ç¹å¾®å°æŠ–åŠ¨å¯¼è‡´ç¼–è¾‘å™¨ refreshï¼Œä»è€Œå‡ºç°â€œè§¦åº•è½»å¾®å›å¼¹/è·³åŠ¨â€
	          if (__lastAppliedViewportHeight && Math.abs(height - __lastAppliedViewportHeight) < 2) return;
	          __lastAppliedViewportHeight = height;

	          const vh = (height * 0.01);
	          document.documentElement.style.setProperty('--vh', `${vh}px`);

	          // å¼ºåˆ¶è®¾ç½®é«˜åº¦ï¼Œé©±åŠ¨ #term-area è§¦å‘ ResizeObserver -> xterm resize
	          document.body.style.height = height + 'px';
	          document.documentElement.style.height = height + 'px';

	          // ç¼–è¾‘å™¨åŒæ ·éœ€è¦è·Ÿéšè§†å£å˜åŒ–åˆ·æ–°ï¼Œå¦åˆ™ä¼šå‡ºç°é¡¶éƒ¨/åº•éƒ¨è¢«è£åˆ‡ã€æ»šåŠ¨é«˜åº¦ä¸æ­£ç¡®ç­‰é—®é¢˜
	          try { refreshAllEditors(); } catch {}
	        };
	        
	        setViewportHeight();
	        window.addEventListener('resize', setViewportHeight);

	        // é”®ç›˜å¼¹å‡º/æ”¶èµ·æ—¶ï¼šæ›´å¯é çš„äº‹ä»¶æº
	        try {
	          const vv = window.visualViewport;
	          if (vv) {
	            vv.addEventListener('resize', setViewportHeight);
	            // æ³¨æ„ï¼šAndroid Edge ä¸Š visualViewport.scroll å¯èƒ½åœ¨å†…å®¹æ»šåŠ¨æ—¶é¢‘ç¹è§¦å‘ï¼Œ
	            // ä¼šå¯¼è‡´ setViewportHeight -> refreshAllEditorsï¼Œä»è€Œå‡ºç°â€œè§¦åº•è½»å¾®å›å¼¹/è·³åŠ¨â€ã€‚
	            // é”®ç›˜å¼¹å‡º/æ”¶èµ·ä¸»è¦ä¾èµ– resize å·²è¶³å¤Ÿï¼Œå› æ­¤ä¸ç»‘å®š scrollã€‚
	          }
	        } catch {}

	        // ç»ˆç«¯èšç„¦æ—¶ï¼ˆç‚¹å‡»è¾“å‡ºåŒºåŸŸä¼šè§¦å‘ xterm çš„éšè— textarea focusï¼‰ï¼Œå†è¡¥å‡ æ¬¡å»¶è¿Ÿåˆ·æ–°ï¼Œ
	        // é€‚é…ä¸åŒæµè§ˆå™¨é”®ç›˜åŠ¨ç”»æ—¶åºï¼Œç¡®ä¿è¾“å…¥è¡Œä¸è¢«æŒ¡ä½ã€‚
	        const scheduleKeyboardRelayout = () => {
	          setViewportHeight();
	          setTimeout(setViewportHeight, 50);
	          setTimeout(setViewportHeight, 250);
	          setTimeout(() => {
	            try {
	              const s = getActive?.();
	              if (!s?.term) return;
	              // å¦‚æœå½“å‰åœ¨åº•éƒ¨ï¼Œå°½é‡ä¿æŒå…‰æ ‡/è¾“å…¥è¡Œå¯è§
	              if (isTermAtBottom(s.term) && typeof s.term.scrollToBottom === 'function') {
	                s.term.scrollToBottom();
	              }
	              s.resizeTerminal?.();
	            } catch {}
	          }, 80);
	        };

	        document.addEventListener('focusin', (e) => {
	          const t = e?.target;
	          if (t && t.classList && t.classList.contains('xterm-helper-textarea')) {
	            scheduleKeyboardRelayout();
	            // å…œåº•ï¼šéƒ¨åˆ†æœºå‹/æµè§ˆå™¨ä¼šé‡å»º textareaï¼Œç¡®ä¿ IME ç›‘å¬å­˜åœ¨
	            try {
	              const s = getActive?.();
	              installImeWorkaround?.(s);
	            } catch {}
	          }
	        }, true);

	        // åœ¨ç»ˆç«¯åŒºåŸŸç‚¹å‡»æ—¶ä¹Ÿè§¦å‘ä¸€æ¬¡ï¼ˆæŸäº›æœºå‹ focusin äº‹ä»¶æ—¶æœºåæ™šï¼‰
	        try {
	          document.getElementById('term-area')?.addEventListener('pointerdown', () => {
	            scheduleKeyboardRelayout();
	          }, { passive: true });
	        } catch {}

	        window.addEventListener('orientationchange', () => {
	          setTimeout(setViewportHeight, 100);
	          setTimeout(setViewportHeight, 500);
	        });
        
        // å¤šæ¬¡å°è¯•éšè—åœ°å€æ 
        const hideAddressBarMultiple = () => {
          for (let i = 0; i < 10; i++) {
            setTimeout(() => {
              window.scrollTo(0, 1);
              setTimeout(() => window.scrollTo(0, 0), 10);
            }, i * 100);
          }
        };
        
        hideAddressBarMultiple();
        
        // é¡µé¢è·å¾—ç„¦ç‚¹æ—¶é‡æ–°éšè—
        window.addEventListener('focus', hideAddressBarMultiple);
        window.addEventListener('pageshow', hideAddressBarMultiple);
        
        // å®‰å“ç‰¹æ®Šå¤„ç†
        if (/Android/i.test(navigator.userAgent)) {
          // å¼ºåˆ¶å…¨å±æ¨¡å¼
          document.documentElement.style.overflow = 'hidden';
          document.body.style.overflow = 'hidden';
          
          // å°è¯•è¯·æ±‚å…¨å±
          const requestFullscreen = () => {
            const element = document.documentElement;
            if (element.requestFullscreen) {
              element.requestFullscreen().catch(() => {});
            } else if (element.webkitRequestFullscreen) {
              element.webkitRequestFullscreen().catch(() => {});
            } else if (element.mozRequestFullScreen) {
              element.mozRequestFullScreen().catch(() => {});
            } else if (element.msRequestFullscreen) {
              element.msRequestFullscreen().catch(() => {});
            }
          };
          
          // å»¶è¿Ÿè¯·æ±‚å…¨å±
          setTimeout(requestFullscreen, 1000);
          
          // ç”¨æˆ·äº¤äº’åå†æ¬¡å°è¯•
          document.addEventListener('touchstart', requestFullscreen, { once: true });
          document.addEventListener('click', requestFullscreen, { once: true });
        }
      }
    }

    // PWAå®‰è£…æç¤º
    let deferredPrompt;
    
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      
      // æ˜¾ç¤ºå®‰è£…æç¤º
      const installBanner = document.createElement('div');
      installBanner.innerHTML = `
        <div style="position: fixed; top: 0; left: 0; right: 0; background: #2d8cff; color: white; padding: 10px; text-align: center; z-index: 1000;">
          <span>ğŸ“± æ·»åŠ åˆ°ä¸»å±å¹•ä»¥è·å¾—æ›´å¥½çš„ä½“éªŒ</span>
          <button onclick="installPWA()" style="margin-left: 10px; background: white; color: #2d8cff; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">å®‰è£…</button>
          <button onclick="this.parentElement.parentElement.remove()" style="margin-left: 5px; background: transparent; color: white; border: 1px solid white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">ç¨å</button>
        </div>
      `;
      document.body.appendChild(installBanner);
    });
    
    window.installPWA = async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        console.log(`PWAå®‰è£…ç»“æœ: ${outcome}`);
        deferredPrompt = null;
        
        // ç§»é™¤å®‰è£…æ¨ªå¹…
        const banner = document.querySelector('[style*="position: fixed"]');
        if (banner) banner.parentElement.remove();
      }
    };
    
    // Register Service Worker (required for "Install/Add to Home screen" standalone PWA on Android Edge)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration.scope);
          })
          .catch((error) => {
            console.log('SW registration failed: ', error);
          });
      });
    }

    // å–æ¶ˆé‰´æƒï¼šä¸å†éœ€è¦ token
    const urlParams = new URLSearchParams(window.location.search);
    const authToken = urlParams.get('token');

	    // removed: mobile toolbar (copy/paste via side buttons)
	    function initMobileToolbar() {}

    // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
    function showToast(message) {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 1000;
        pointer-events: none;
        max-width: 80%;
        text-align: center;
      `;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    // å¤‡ç”¨å¤åˆ¶æ–¹æ³•ï¼ˆä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•ï¼‰
    function fallbackCopyText(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      try {
        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);
        return successful;
      } catch (err) {
        document.body.removeChild(textArea);
        return false;
      }
    }

	    // ä¾§è¾¹æ æŠ˜å åŠŸèƒ½
	    const sidebar = document.getElementById('sidebar');
	    const toggleBtn = document.getElementById('toggle-sidebar');
	    // Default: collapsed when entering the page
	    let sidebarCollapsed = true;
	    sidebar.classList.toggle('collapsed', sidebarCollapsed);
	    document.body.classList.toggle('sidebar-collapsed', sidebarCollapsed);
	    toggleBtn.textContent = sidebarCollapsed ? 'â€º' : 'â€¹';
	    toggleBtn.title = sidebarCollapsed ? 'å±•å¼€ä¾§è¾¹æ ' : 'æŠ˜å ä¾§è¾¹æ ';

	    toggleBtn.onclick = () => {
	      sidebarCollapsed = !sidebarCollapsed;
	      sidebar.classList.toggle('collapsed', sidebarCollapsed);
	      document.body.classList.toggle('sidebar-collapsed', sidebarCollapsed);
      toggleBtn.textContent = sidebarCollapsed ? 'â€º' : 'â€¹';
      toggleBtn.title = sidebarCollapsed ? 'å±•å¼€ä¾§è¾¹æ ' : 'æŠ˜å ä¾§è¾¹æ ';
      
      // ä¾§è¾¹æ çŠ¶æ€æ”¹å˜åï¼Œå¼ºåˆ¶é‡æ–°è®¡ç®—æ‰€æœ‰ç»ˆç«¯çš„å°ºå¯¸
      setTimeout(() => {
        sessions.forEach(session => {
          if (session.resizeTerminal) {
            session.resizeTerminal();
          } else if (session.type === 'editor') {
            refreshEditorSession(session);
          }
        });
      }, 350); // ç­‰å¾…CSSåŠ¨ç”»å®Œæˆ
    };



	    // é”®ç›˜å¿«æ·é”®ï¼šCtrl+B åˆ‡æ¢ä¾§è¾¹æ 
	    document.addEventListener('keydown', (e) => {
	      if (e.ctrlKey && e.key === 'b') {
	        e.preventDefault();
	        toggleBtn.click();
	      }

	      // ç¼–è¾‘å™¨å¿«æ·é”®ï¼šCtrl+S ä¿å­˜ï¼ŒCtrl+W å…³é—­
	      if (e.ctrlKey && (e.key === 's' || e.key === 'S')) {
	        const s = getActive();
	        if (s?.type === 'editor') {
	          e.preventDefault();
	          saveEditorFile(s).catch(() => {});
	          return;
	        }
	      }
	      if (e.ctrlKey && (e.key === 'w' || e.key === 'W')) {
	        const s = getActive();
	        if (s?.type === 'editor') {
	          e.preventDefault();
	          closeEditor(s.id);
	          return;
	        }
	      }
	      
	      // æ‰‹æœºç«¯é¢å¤–å¿«æ·é”®
	      if (window.innerWidth <= 768) {
	        if (e.ctrlKey && e.key === 'c' && e.shiftKey) {
	          // Ctrl+Shift+C å¤åˆ¶
	          e.preventDefault();
	          try { window.__lanShellQuickActions?.copyLastOutput?.(); } catch {}
	        } else if (e.ctrlKey && e.key === 'v' && e.shiftKey) {
	          // Ctrl+Shift+V ç²˜è´´
	          e.preventDefault();
	          try { window.__lanShellQuickActions?.pasteClipboard?.(); } catch {}
	        }
	      }
	    });

		    // ä¼šè¯ç®¡ç†ï¼ˆä»¥æœåŠ¡ç«¯ä¸ºå‡†ï¼šå…³é—­=åˆ é™¤ï¼Œåˆ·æ–°=æ¢å¤å‰©ä½™ä¼šè¯ï¼‰
		    const CLIENT_ID_KEY = 'lanshell_client_id';

		    function getClientId() {
		      try {
		        const existing = localStorage.getItem(CLIENT_ID_KEY);
		        if (existing) return existing;
		        const id =
		          (crypto && typeof crypto.randomUUID === 'function' && crypto.randomUUID()) ||
		          `${Date.now().toString(16)}-${Math.random().toString(16).slice(2)}`;
		        localStorage.setItem(CLIENT_ID_KEY, id);
		        return id;
		      } catch {
		        return `anon-${Date.now().toString(16)}-${Math.random().toString(16).slice(2)}`;
		      }
		    }

    const clientId = getClientId();

    let sessions = [];
    let activeId = null;
    let counter = 1;
    let showHiddenFiles = false;

    // åŠ è½½ç°æœ‰ä¼šè¯
	    async function loadExistingSessions() {
	      try {
	        const response = await fetch(
	          `/api/sessions?clientId=${encodeURIComponent(clientId)}&token=${encodeURIComponent(authToken)}`
	        );
	        if (response.ok) {
	          const data = await response.json();
	          return data.sessions;
	        }
      } catch (error) {
        console.error('åŠ è½½ä¼šè¯å¤±è´¥:', error);
      }
      return [];
    }

    async function loadDir(p) {
      const res = await fetch(`/api/fs?path=${encodeURIComponent(p)}&token=${encodeURIComponent(authToken)}`);
      if (res.status === 401) {
        console.log('âŒ æ–‡ä»¶ç³»ç»Ÿè®¿é—®éœ€è¦é‡æ–°è®¤è¯');
        showToast('ğŸ” ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
        setTimeout(() => {
          window.location.href = '/';
        }, 2000);
        return;
      }
      const data = await res.json();
      document.getElementById('path').value = data.cwd;
      const list = document.getElementById('list');
      list.innerHTML = '';

      // add parent shortcut if not root
      if (data.cwd !== data.root) {
        const parent = document.createElement('div');
        parent.textContent = 'â¬†ï¸ ..';
        parent.className = 'item';
        parent.onclick = () => {
          const up = data.cwd.split('/').slice(0,-1).join('/') || '/';
          loadDir(up);
        };
        list.appendChild(parent);
      }
      data.items
        .filter(it => showHiddenFiles || !String(it?.name || '').startsWith('.'))
        .forEach(it => {
        const div = document.createElement('div');
        div.className = 'item';
        
        const icon = document.createElement('span');
        icon.textContent = it.isDir ? 'ğŸ“' : (it.isExe ? 'âš¡' : 'ğŸ“„');
        div.appendChild(icon);
        
        const name = document.createElement('span');
        name.className = 'file-name';
        name.textContent = it.name;
        div.appendChild(name);
        
        const tag = document.createElement('span');
        tag.className = 'file-tag';
        tag.textContent = it.isDir ? 'dir' : (it.isExe ? 'exec' : `${it.size}B`);
        div.appendChild(tag);
        
        div.onclick = () => {
          // é•¿æŒ‰èœå•è§¦å‘åï¼Œé¿å…éšåçš„ click å†æ‰§è¡Œâ€œæ‰“å¼€/è¿›å…¥â€
          try {
            if (div.__lanFsLongPressFiredAt && (Date.now() - div.__lanFsLongPressFiredAt) < 800) return;
          } catch {}
          if (it.isDir) {
            const next = join(data.cwd, it.name);
            loadDir(next);
          } else if (it.isExe) {
            const confirmed = confirm(`åœ¨ ${data.cwd} è¿è¡Œ ./${it.name} ?`);
            if (confirmed) createTerminal(data.cwd, `./${it.name}`);
          } else {
            // æ¡Œé¢ç«¯ï¼šåŒå‡»æ‰“å¼€æ›´ç¬¦åˆä¹ æƒ¯ï¼›ç§»åŠ¨ç«¯æ²¡æœ‰åŒå‡»æ¦‚å¿µï¼Œå› æ­¤å•å‡»ä¹Ÿæ‰“å¼€
            const full = join(data.cwd, it.name);
            if (isArchiveFileName(it.name)) {
              try { window.__lanShellOpenExtractModal?.({ archivePath: full, defaultDest: data.cwd }); } catch {}
            } else {
              openEditor(full);
            }
          }
        };

        // æ¡Œé¢ç«¯åŒå‡»æ‰“å¼€æ–‡ä»¶ç¼–è¾‘å™¨ï¼ˆä¸å½±å“ç›®å½•å•å‡»è¿›å…¥ï¼‰
        div.ondblclick = () => {
          try {
            if (div.__lanFsLongPressFiredAt && (Date.now() - div.__lanFsLongPressFiredAt) < 800) return;
          } catch {}
          if (!it.isDir && !it.isExe) {
            const full = join(data.cwd, it.name);
            if (isArchiveFileName(it.name)) {
              try { window.__lanShellOpenExtractModal?.({ archivePath: full, defaultDest: data.cwd }); } catch {}
            } else {
              openEditor(full);
            }
          }
        };

        // é•¿æŒ‰/å³é”®ï¼šå¼¹å‡ºæ–‡ä»¶æ“ä½œèœå•
        installItemLongPress(div, {
          cwd: data.cwd,
          root: data.root,
          item: it,
          fullPath: join(data.cwd, it.name),
        });

        div.oncontextmenu = (e) => {
          e.preventDefault();
          e.stopPropagation();
          try { openOpMenu({ cwd: data.cwd, item: it, fullPath: join(data.cwd, it.name) }); } catch {}
          return false;
        };
        list.appendChild(div);
      });
    }

    function join(base, name){
      if (base === '/') return `/${name}`;
      return base.replace(/\/$/, '') + '/' + name;
    }

	    function isArchiveFileName(name) {
	      const n = String(name || '').toLowerCase();
	      return (
	        n.endsWith('.zip') ||
	        n.endsWith('.tar') ||
	        n.endsWith('.tar.gz') ||
	        n.endsWith('.tgz') ||
	        n.endsWith('.tar.bz2') ||
	        n.endsWith('.tbz2') ||
	        n.endsWith('.tar.xz') ||
	        n.endsWith('.txz')
	      );
	    }

	    function dirname(p) {
	      try {
	        const s = String(p || '');
	        const i = s.lastIndexOf('/');
	        if (i <= 0) return '/';
	        return s.slice(0, i) || '/';
	      } catch {
	        return '.';
	      }
	    }

	    function installHiddenToggle() {
	      const btn = document.getElementById('toggleHiddenBtn');
	      if (!btn) return;

	      const KEY = 'lanshell_show_hidden';
	      try {
	        const saved = localStorage.getItem(KEY);
	        showHiddenFiles = saved === '1';
	      } catch {}

	      function sync() {
	        btn.textContent = showHiddenFiles ? 'éšè—éšè—' : 'æ˜¾ç¤ºéšè—';
	        btn.title = showHiddenFiles ? 'ä¸æ˜¾ç¤ºä»¥ . å¼€å¤´çš„æ–‡ä»¶' : 'æ˜¾ç¤ºä»¥ . å¼€å¤´çš„æ–‡ä»¶';
	      }
	      sync();

	      btn.onclick = () => {
	        showHiddenFiles = !showHiddenFiles;
	        try { localStorage.setItem(KEY, showHiddenFiles ? '1' : '0'); } catch {}
	        sync();
	        loadDir(document.getElementById('path')?.value || '.');
	      };
	    }

	    // -----------------------
	    // è§£å‹ï¼ˆå½’æ¡£ï¼‰
	    // -----------------------
	    function installExtractModal() {
	      const backdrop = document.getElementById('extract-modal-backdrop');
	      const modal = document.getElementById('extract-modal');
	      const closeBtn = document.getElementById('extractModalCloseBtn');
	      const cancelBtn = document.getElementById('extractCancelBtn');
	      const okBtn = document.getElementById('extractOkBtn');
	      const archiveInput = document.getElementById('extractArchivePath');
	      const destInput = document.getElementById('extractDestPath');
	      const overwriteInput = document.getElementById('extractOverwrite');
	      const pickBtn = document.getElementById('pickDestBtn');

	      const picker = document.getElementById('dirpicker');
	      const pickerPath = document.getElementById('dirpickerPath');
	      const pickerList = document.getElementById('dirpicker-list');
	      const pickerCancel = document.getElementById('dirpickerCancelBtn');
	      const pickerOk = document.getElementById('dirpickerOkBtn');

	      if (!backdrop || !modal) return;

	      let currentPick = '.';

	      async function renderPickerDir(p) {
	        const res = await fetch(`/api/fs?path=${encodeURIComponent(p)}&token=${encodeURIComponent(authToken)}`);
	        if (!res.ok) {
	          showToast('âŒ æ— æ³•è¯»å–ç›®å½•');
	          return;
	        }
	        const data = await res.json();
	        const cwd = data.cwd;
	        currentPick = cwd;
	        pickerPath.value = cwd;
	        pickerList.innerHTML = '';

	        if (data.cwd !== data.root) {
	          const up = document.createElement('div');
	          up.className = 'dir-item';
	          up.textContent = 'â¬†ï¸ ..';
	          up.onclick = () => {
	            const parent = cwd.split('/').slice(0, -1).join('/') || '/';
	            renderPickerDir(parent);
	          };
	          pickerList.appendChild(up);
	        }

	        (data.items || []).forEach((it) => {
	          if (!it?.isDir) return;
	          const row = document.createElement('div');
	          row.className = 'dir-item';
	          row.innerHTML = `<span>ğŸ“</span><span style="flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${it.name}</span>`;
	          row.onclick = () => renderPickerDir(join(cwd, it.name));
	          pickerList.appendChild(row);
	        });
	      }

	      function openPicker(initial) {
	        picker.classList.add('open');
	        currentPick = initial || '.';
	        pickerPath.value = currentPick;
	        renderPickerDir(currentPick).catch(() => {});
	      }

	      function closePicker() {
	        picker.classList.remove('open');
	      }

	      function open({ archivePath, defaultDest } = {}) {
	        archiveInput.value = archivePath || '';
	        destInput.value = defaultDest || dirname(archivePath || '') || '.';
	        overwriteInput.checked = false;
	        backdrop.classList.add('open');
	        modal.classList.add('open');
	        modal.setAttribute('aria-hidden', 'false');
	        backdrop.setAttribute('aria-hidden', 'false');
	        closePicker();
	      }

	      function close() {
	        closePicker();
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	        modal.setAttribute('aria-hidden', 'true');
	        backdrop.setAttribute('aria-hidden', 'true');
	      }

	      async function doExtract() {
	        const archive = (archiveInput.value || '').trim();
	        const dest = (destInput.value || '').trim();
	        if (!archive) { showToast('âš ï¸ ç¼ºå°‘å‹ç¼©åŒ…è·¯å¾„'); return; }
	        if (!dest) { showToast('âš ï¸ è¯·é€‰æ‹©è§£å‹ç›®å½•'); return; }

	        okBtn.disabled = true;
	        cancelBtn.disabled = true;
	        pickBtn.disabled = true;
	        showToast('â³ å¼€å§‹è§£å‹...');
	        try {
	          const res = await fetch(`/api/archive/extract?token=${encodeURIComponent(authToken)}`, {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ path: archive, dest, overwrite: Boolean(overwriteInput.checked) }),
	          });
	          if (!res.ok) {
	            let msg = `è§£å‹å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	            try { const j = await res.json(); if (j?.error) msg = `è§£å‹å¤±è´¥ï¼š${j.error}`; } catch {}
	            showToast(`âŒ ${msg}`);
	            return;
	          }
	          showToast('âœ… è§£å‹å®Œæˆ');
	          close();
	          try { await loadDir(document.getElementById('path')?.value || '.'); } catch {}
	        } catch (e) {
	          showToast(`âŒ è§£å‹å¤±è´¥ï¼š${e?.message || e}`);
	        } finally {
	          okBtn.disabled = false;
	          cancelBtn.disabled = false;
	          pickBtn.disabled = false;
	        }
	      }

	      backdrop.onclick = close;
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };
	      cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };
	      okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); doExtract(); };
	      pickBtn.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        const init = (destInput.value || '').trim() || '.';
	        openPicker(init);
	      };

	      pickerCancel.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closePicker(); };
	      pickerOk.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        destInput.value = currentPick;
	        closePicker();
	      };

	      document.addEventListener('keydown', (e) => {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
	          close();
	        }
	      }, true);

	      window.__lanShellOpenExtractModal = open;
	    }

	    // -----------------------
	    // æ–‡ä»¶æ“ä½œï¼šé•¿æŒ‰èœå• + å¤åˆ¶/å‰ªåˆ‡/é‡å‘½å/åˆ é™¤/ç²˜è´´
	    // -----------------------
	    let fsClipboard = null; // { mode:'copy'|'move', src, name, isDir }

	    function openOpMenu({ cwd, item, fullPath }) {
	      const backdrop = document.getElementById('op-modal-backdrop');
	      const modal = document.getElementById('op-modal');
	      const closeBtn = document.getElementById('opCloseBtn');
	      const title = document.getElementById('op-title');
	      const pathEl = document.getElementById('op-path');
	      const actions = document.getElementById('op-actions');
	      if (!backdrop || !modal) return;

	      function close({ clearClipboard = false } = {}) {
	        if (clearClipboard) fsClipboard = null;
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	      }

	      backdrop.onclick = close;
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };

	      title.textContent = item.isDir ? 'æ–‡ä»¶å¤¹æ“ä½œ' : 'æ–‡ä»¶æ“ä½œ';
	      pathEl.textContent = fullPath;
	      actions.innerHTML = '';

	      function addBtn(text, cls, handler) {
	        const b = document.createElement('button');
	        b.textContent = text;
	        if (cls) b.className = cls;
	        b.onclick = (e) => { e.preventDefault(); e.stopPropagation(); handler(); };
	        actions.appendChild(b);
	      }

	      addBtn('é‡å‘½å', '', () => {
	        close();
	        const nn = prompt('è¾“å…¥æ–°åç§°', item.name);
	        if (!nn || nn.trim() === item.name) return;
	        renameEntry(fullPath, nn.trim());
	      });

	      addBtn('å¤åˆ¶', '', () => {
	        close();
	        // ç«‹å³å¼¹å‡ºç›®å½•é€‰æ‹©å™¨ï¼›åŒæ—¶æŠŠå‰ªè´´æ¿åŒæ­¥ä¸ºå¤‡ç”¨
	        fsClipboard = { mode: 'copy', src: fullPath, name: item.name, isDir: !!item.isDir };
	        openXferModal({
	          mode: 'copy',
	          src: fullPath,
	          defaultDest: cwd,
	          defaultName: item.name,
	        });
	      });

	      addBtn('å‰ªåˆ‡', '', () => {
	        close();
	        fsClipboard = { mode: 'move', src: fullPath, name: item.name, isDir: !!item.isDir };
	        openXferModal({
	          mode: 'move',
	          src: fullPath,
	          defaultDest: cwd,
	          defaultName: item.name,
	        });
	      });

	      addBtn('åˆ é™¤', 'danger', () => {
	        close();
	        const ok = confirm(`ç¡®å®šåˆ é™¤ï¼š${fullPath} ?\nè¯¥æ“ä½œä¸å¯æ’¤é”€ã€‚`);
	        if (!ok) return;
	        deleteEntry(fullPath);
	      });

	      if (isArchiveFileName(item.name)) {
	        addBtn('è§£å‹', 'primary', () => {
	          close();
	          try { window.__lanShellOpenExtractModal?.({ archivePath: fullPath, defaultDest: cwd }); } catch {}
	        });
	      }

	      // è‹¥å‰ªè´´æ¿æœ‰å†…å®¹ä¸”å½“å‰å¯¹è±¡ä¸ºç›®å½•ï¼Œå¯åœ¨æ­¤ç›®å½•ä¸­ç²˜è´´
	      if (fsClipboard && item.isDir) {
	        addBtn('ç²˜è´´åˆ°æ­¤', 'primary', () => {
	          close();
	          openXferModal({
	            mode: fsClipboard.mode,
	            src: fsClipboard.src,
	            defaultDest: fullPath,
	            defaultName: fsClipboard.name,
	          });
	        });
	      }

	      backdrop.classList.add('open');
	      modal.classList.add('open');

	      document.addEventListener('keydown', function esc(e) {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
          close();
	          document.removeEventListener('keydown', esc, true);
	        }
	      }, true);
	    }

	    function installItemLongPress(el, ctx) {
	      let timer = null;
	      const delay = 520;
	      const MOVE_CANCEL_PX = 12;
	      let startX = 0;
	      let startY = 0;
	      el.addEventListener('touchstart', (e) => {
	        const t = e.touches?.[0];
	        if (!t) return;
	        startX = t.clientX;
	        startY = t.clientY;
	        timer = setTimeout(() => {
	          try { openOpMenu(ctx); } catch {}
	          try { el.__lanFsLongPressFiredAt = Date.now(); } catch {}
	        }, delay);
	      }, { passive: true });
	      el.addEventListener('touchmove', (e) => {
	        if (!timer) return;
	        const t = e.touches?.[0];
	        if (!t) return;
	        const dx = Math.abs(t.clientX - startX);
	        const dy = Math.abs(t.clientY - startY);
	        if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) {
	          clearTimeout(timer);
	          timer = null;
	        }
	      }, { passive: true });
	      el.addEventListener('touchend', () => { if (timer) clearTimeout(timer); timer = null; }, { passive: true });
	      el.addEventListener('touchcancel', () => { if (timer) clearTimeout(timer); timer = null; }, { passive: true });
	      // å…¼å®¹æ¡Œé¢é•¿æŒ‰ï¼ˆmouseï¼‰
	      el.addEventListener('mousedown', (e) => {
	        if (e.buttons !== 1) return;
	        timer = setTimeout(() => {
	          try { openOpMenu(ctx); } catch {}
	        }, delay);
	      });
	      el.addEventListener('mouseup', () => { if (timer) clearTimeout(timer); timer = null; });
	      el.addEventListener('mouseleave', () => { if (timer) clearTimeout(timer); timer = null; });
	    }

	    async function deleteEntry(pathStr) {
	      try {
	        const res = await fetch(`/api/fs/delete?token=${encodeURIComponent(authToken)}`, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({ path: pathStr }),
	        });
	        if (!res.ok) {
	          let msg = `åˆ é™¤å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	          try { const j = await res.json(); if (j?.error) msg = `åˆ é™¤å¤±è´¥ï¼š${j.error}`; } catch {}
	          showToast(`âŒ ${msg}`);
	          return;
	        }
	        showToast('âœ… å·²åˆ é™¤');
	        await loadDir(document.getElementById('path')?.value || '.');
	      } catch (e) {
	        showToast(`âŒ åˆ é™¤å¤±è´¥ï¼š${e?.message || e}`);
	      }
	    }

	    async function renameEntry(pathStr, newName) {
	      try {
	        const res = await fetch(`/api/fs/rename?token=${encodeURIComponent(authToken)}`, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({ path: pathStr, newName }),
	        });
	        if (!res.ok) {
	          let msg = `é‡å‘½åå¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	          try { const j = await res.json(); if (j?.error) msg = `é‡å‘½åå¤±è´¥ï¼š${j.error}`; } catch {}
	          showToast(`âŒ ${msg}`);
	          return;
	        }
	        showToast('âœ… å·²é‡å‘½å');
	        await loadDir(document.getElementById('path')?.value || '.');
	      } catch (e) {
	        showToast(`âŒ é‡å‘½åå¤±è´¥ï¼š${e?.message || e}`);
	      }
	    }

	    function openXferModal({ mode, src, defaultDest, defaultName } = {}) {
	      const backdrop = document.getElementById('xfer-modal-backdrop');
	      const modal = document.getElementById('xfer-modal');
	      const closeBtn = document.getElementById('xferCloseBtn');
	      const cancelBtn = document.getElementById('xferCancelBtn');
	      const okBtn = document.getElementById('xferOkBtn');
	      const title = document.getElementById('xfer-title');
	      const srcInput = document.getElementById('xfer-src');
	      const destDirInput = document.getElementById('xfer-dest-dir');
	      const destNameInput = document.getElementById('xfer-dest-name');
	      const conflictSel = document.getElementById('xfer-conflict');
	      const dirList = document.getElementById('xfer-dir-list');

	      if (!backdrop || !modal) return;

	      let browsing = defaultDest || '.';

	      async function renderDir(dir) {
	        const res = await fetch(`/api/fs?path=${encodeURIComponent(dir)}&token=${encodeURIComponent(authToken)}`);
	        if (!res.ok) {
	          showToast('âŒ è¯»å–ç›®å½•å¤±è´¥');
	          return;
	        }
          const data = await res.json();
	        browsing = data.cwd;
	        destDirInput.value = browsing;
	        dirList.innerHTML = '';
	        if (data.cwd !== data.root) {
	          const up = document.createElement('div');
	          up.className = 'dir-item';
	          up.textContent = 'â¬†ï¸ ..';
	          up.onclick = () => {
	            const parent = browsing.split('/').slice(0, -1).join('/') || '/';
	            renderDir(parent);
	          };
	          dirList.appendChild(up);
	        }
	        (data.items || []).forEach((it) => {
	          if (!it?.isDir) return;
	          const row = document.createElement('div');
	          row.className = 'dir-item';
	          row.innerHTML = `<span>ğŸ“</span><span style="flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${it.name}</span>`;
	          row.onclick = () => renderDir(join(browsing, it.name));
	          dirList.appendChild(row);
	        });
	      }

	      function close() {
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	      }

	      async function submit() {
	        const destDir = (destDirInput.value || '').trim() || '.';
	        const destName = (destNameInput.value || '').trim() || defaultName || '';
	        if (!src || !destDir) { showToast('âš ï¸ å‚æ•°ç¼ºå¤±'); return; }

	        okBtn.disabled = true; cancelBtn.disabled = true;
	        try {
	          const payload = { src, destDir, destName, conflict: conflictSel.value };
	          const api = mode === 'move' ? '/api/fs/move' : '/api/fs/copy';
	          const res = await fetch(`${api}?token=${encodeURIComponent(authToken)}`, {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify(payload),
	          });
	          if (!res.ok) {
	            let msg = `${mode === 'move' ? 'ç§»åŠ¨' : 'å¤åˆ¶'}å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	            try { const j = await res.json(); if (j?.error) msg = `${mode === 'move' ? 'ç§»åŠ¨' : 'å¤åˆ¶'}å¤±è´¥ï¼š${j.error}`; } catch {}
	            showToast(`âŒ ${msg}`);
	            return;
	          }
	          showToast(mode === 'move' ? 'âœ… å·²ç§»åŠ¨' : 'âœ… å·²å¤åˆ¶');
	          fsClipboard = null; // å‰ªåˆ‡å®Œæˆåæ¸…ç©º
	          close({ clearClipboard: true });
	          await loadDir(document.getElementById('path')?.value || '.');
	        } catch (e) {
	          showToast(`âŒ ${mode === 'move' ? 'ç§»åŠ¨' : 'å¤åˆ¶'}å¤±è´¥ï¼š${e?.message || e}`);
	        } finally {
	          okBtn.disabled = false; cancelBtn.disabled = false;
	        }
	      }

	      title.textContent = mode === 'move' ? 'ç§»åŠ¨åˆ°...' : 'å¤åˆ¶åˆ°...';
	      srcInput.value = src || '';
	      destNameInput.value = defaultName || '';
	      conflictSel.value = 'error';
	      backdrop.classList.add('open');
	      modal.classList.add('open');
	      renderDir(defaultDest || '.');

	      backdrop.onclick = () => close({ clearClipboard: true });
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close({ clearClipboard: true }); };
	      cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close({ clearClipboard: true }); };
	      okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); submit(); };

	      document.addEventListener('keydown', function esc(e) {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
	          close({ clearClipboard: true });
	          document.removeEventListener('keydown', esc, true);
	        }
	      }, true);
	    }

	    // -----------------------
	    // æ–‡ä»¶åˆ›å»º/ä¸Šä¼ 
	    // -----------------------
	    function installFileModal() {
	      const newFileBtn = document.getElementById('newFileBtn');
	      const backdrop = document.getElementById('file-modal-backdrop');
	      const modal = document.getElementById('file-modal');
	      const closeBtn = document.getElementById('fileModalCloseBtn');
	      const dirInput = document.getElementById('fileModalDir');
	      const nameInput = document.getElementById('newEntryNameInput');
	      const createBtn = document.getElementById('createEmptyFileBtn');
	      const createDirBtn = document.getElementById('createEmptyDirBtn');
	      const uploadBtn = document.getElementById('uploadBtn');
	      const uploadInput = document.getElementById('uploadFileInput');

	      if (!newFileBtn || !backdrop || !modal) return;

	      function open() {
	        try {
	          const cwd = document.getElementById('path')?.value || '.';
	          dirInput.value = cwd;
	        } catch {}
	        backdrop.classList.add('open');
	        modal.classList.add('open');
	        modal.setAttribute('aria-hidden', 'false');
	        backdrop.setAttribute('aria-hidden', 'false');
	        setTimeout(() => { try { nameInput?.focus?.(); } catch {} }, 0);
	      }

	      function close() {
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	        modal.setAttribute('aria-hidden', 'true');
	        backdrop.setAttribute('aria-hidden', 'true');
	      }

	      newFileBtn.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        open();
	      };
	      backdrop.onclick = close;
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };

	      async function refreshDir() {
	        try {
	          const p = document.getElementById('path')?.value || '.';
	          await loadDir(p);
	        } catch {}
	      }

	      createBtn.onclick = async (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        const dir = (dirInput.value || '').trim() || '.';
	        const name = (nameInput.value || '').trim();
	        if (!name) {
	          showToast('âš ï¸ è¯·è¾“å…¥æ–‡ä»¶å');
	          return;
	        }
	        const full = join(dir, name);
	        try {
	          const res = await fetch(`/api/file?token=${encodeURIComponent(authToken)}`, {
	            method: 'PUT',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ path: full, content: '' }),
	          });
	          if (!res.ok) {
	            let msg = `æ–°å»ºå¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	            try { const j = await res.json(); if (j?.error) msg = `æ–°å»ºå¤±è´¥ï¼š${j.error}`; } catch {}
	            showToast(`âŒ ${msg}`);
	            return;
	          }
	          showToast('âœ… å·²æ–°å»ºæ–‡ä»¶');
	          close();
	          await refreshDir();
	          openEditor(full);
	        } catch (err) {
	          showToast(`âŒ æ–°å»ºå¤±è´¥ï¼š${err?.message || err}`);
	        }
	      };

	      createDirBtn.onclick = async (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        const dir = (dirInput.value || '').trim() || '.';
	        const name = (nameInput.value || '').trim();
	        if (!name) {
	          showToast('âš ï¸ è¯·è¾“å…¥æ–‡ä»¶å¤¹å');
	          return;
	        }
	        try {
	          const res = await fetch(`/api/fs/mkdir?token=${encodeURIComponent(authToken)}`, {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ dir, name }),
	          });
	          if (!res.ok) {
	            let msg = `æ–°å»ºæ–‡ä»¶å¤¹å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	            try { const j = await res.json(); if (j?.error) msg = `æ–°å»ºæ–‡ä»¶å¤¹å¤±è´¥ï¼š${j.error}`; } catch {}
	            showToast(`âŒ ${msg}`);
	            return;
	          }
	          showToast('âœ… å·²æ–°å»ºæ–‡ä»¶å¤¹');
	          close();
	          await refreshDir();
	        } catch (err) {
	          showToast(`âŒ æ–°å»ºæ–‡ä»¶å¤¹å¤±è´¥ï¼š${err?.message || err}`);
	        }
	      };

	      uploadBtn.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        try { uploadInput.value = ''; } catch {}
	        uploadInput.click();
	      };

	      uploadInput.onchange = async () => {
	        const file = uploadInput.files?.[0];
	        if (!file) return;
	        const dir = (dirInput.value || '').trim() || '.';
	        const name = file.name || 'upload.bin';
	        try {
	          async function doUploadRaw({ overwrite = false } = {}) {
	            const q = new URLSearchParams({
	              dir,
	              name,
	              overwrite: overwrite ? '1' : '0',
	              token: authToken || '',
	            });
	            const res = await fetch(`/api/upload-raw?${q.toString()}`, {
	              method: 'POST',
	              headers: { 'Content-Type': 'application/octet-stream' },
	              body: file,
	            });
	            if (res.status === 409) return { ok: false, conflict: true };
	            if (!res.ok) {
	              let msg = `ä¸Šä¼ å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	              try { const j = await res.json(); if (j?.error) msg = `ä¸Šä¼ å¤±è´¥ï¼š${j.error}`; } catch {}
	              showToast(`âŒ ${msg}`);
	              return { ok: false, conflict: false };
	            }
	            return { ok: true };
	          }

	          const r1 = await doUploadRaw({ overwrite: false });
	          if (!r1.ok && r1.conflict) {
	            const ok = confirm(`æ–‡ä»¶å·²å­˜åœ¨ï¼š${name}\n\nâ€œç¡®å®šâ€=è¦†ç›–\nâ€œå–æ¶ˆâ€=ä¸ä¸Šä¼ `);
	            if (!ok) return;
	            const r2 = await doUploadRaw({ overwrite: true });
	            if (!r2.ok) return;
	          } else if (!r1.ok) {
	            return;
	          }

	          showToast('âœ… ä¸Šä¼ æˆåŠŸ');
	          close();
	          await refreshDir();
	        } catch (err) {
	          showToast(`âŒ ä¸Šä¼ å¤±è´¥ï¼š${err?.message || err}`);
	        }
	      };

	      // ESC å…³é—­
	      document.addEventListener('keydown', (e) => {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
	          close();
	        }
	      }, true);
	    }

	    // -----------------------
	    // æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆCodeMirrorï¼‰
	    // -----------------------
	    let editorCounter = 1;

	    function basename(p) {
	      try {
	        const s = String(p || '');
	        const i = s.lastIndexOf('/');
	        return i >= 0 ? s.slice(i + 1) : s;
	      } catch {
	        return String(p || '');
	      }
	    }

	    function findEditorByPath(filePath) {
	      return sessions.find(s => s?.type === 'editor' && s.filePath === filePath);
	    }

	    function updateEditorTabTitle(s) {
	      if (!s?.tab) return;
	      const title = s.displayName || basename(s.filePath);
	      // tab çš„ç»“æ„æ˜¯ï¼šæ–‡æœ¬èŠ‚ç‚¹ + close spanï¼›è¿™é‡Œç›´æ¥æ”¹ç¬¬ä¸€ä¸ª child çš„ textContent æ›´ç¨³å®š
	      try {
	        const textNode = s.tab.childNodes?.[0];
	        if (textNode) textNode.textContent = s.dirty ? `${title} *` : title;
	        else s.tab.textContent = s.dirty ? `${title} *` : title;
	      } catch {
	        s.tab.textContent = s.dirty ? `${title} *` : title;
	      }
	    }

	    async function loadEditorFile(s) {
	      if (!s?.filePath) return false;
	      try {
	        const res = await fetch(`/api/file?path=${encodeURIComponent(s.filePath)}&token=${encodeURIComponent(authToken)}`);
	        if (!res.ok) {
	          let msg = `æ‰“å¼€å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	          try {
	            const j = await res.json();
	            if (j?.error) msg = `æ‰“å¼€å¤±è´¥ï¼š${j.error}`;
	          } catch {}
	          showToast(`âŒ ${msg}`);
	          return false;
	        }
	        const data = await res.json();
	        s._suppressDirty = true;
	        s.cm.setValue(data?.content ?? '');
	        s.cm.setCursor({ line: 0, ch: 0 });
	        s.cm.scrollTo(0, 0);
	        s._suppressDirty = false;
	        s.dirty = false;
	        s.mtimeMs = data?.mtimeMs;
	        s.size = data?.size;
	        updateEditorTabTitle(s);
	        try { s.titleEl.textContent = data?.path || s.filePath; } catch {}
	        return true;
	      } catch (e) {
	        showToast(`âŒ æ‰“å¼€å¤±è´¥ï¼š${e?.message || e}`);
	        return false;
	      }
	    }

	    async function saveEditorFile(s, { force = false } = {}) {
	      if (!s?.filePath || !s?.cm) return false;
	      try {
	        const payload = {
	          path: s.filePath,
	          content: s.cm.getValue(),
	        };
	        if (!force) payload.mtimeMs = s.mtimeMs;

	        const res = await fetch(`/api/file?token=${encodeURIComponent(authToken)}`, {
	          method: 'PUT',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify(payload),
	        });

	        if (res.status === 409) {
	          // ä¹è§‚é”å†²çªï¼šæç¤ºè¦†ç›–æˆ–é‡è½½
	          let currentMtimeMs = null;
	          try {
	            const j = await res.json();
	            currentMtimeMs = j?.currentMtimeMs ?? null;
	          } catch {}
	          const ok = confirm('æ–‡ä»¶å·²åœ¨ç£ç›˜ä¸Šè¢«ä¿®æ”¹ã€‚\n\nâ€œç¡®å®šâ€=å¼ºåˆ¶è¦†ç›–ä¿å­˜\nâ€œå–æ¶ˆâ€=ä¸ä¿å­˜ï¼ˆå»ºè®®ç‚¹â€œé‡è½½â€å†å¯¹æ¯”ï¼‰');
	          if (ok) return await saveEditorFile(s, { force: true });
	          showToast('âš ï¸ å·²å–æ¶ˆä¿å­˜');
	          return false;
	        }

	        if (!res.ok) {
	          let msg = `ä¿å­˜å¤±è´¥ï¼ˆ${res.status}ï¼‰`;
	          try {
	            const j = await res.json();
	            if (j?.error) msg = `ä¿å­˜å¤±è´¥ï¼š${j.error}`;
	          } catch {}
	          showToast(`âŒ ${msg}`);
	          return false;
	        }

	        const data = await res.json();
	        s.dirty = false;
	        s.mtimeMs = data?.mtimeMs;
	        s.size = data?.size;
	        updateEditorTabTitle(s);
	        showToast('âœ… å·²ä¿å­˜');
	        return true;
	      } catch (e) {
	        showToast(`âŒ ä¿å­˜å¤±è´¥ï¼š${e?.message || e}`);
	        return false;
	      }
	    }

	    function removeEditor(id) {
	      const idx = sessions.findIndex(s => s.id === id);
	      if (idx === -1) return;
	      const s = sessions[idx];
	      try { s.cm?.toTextArea?.(); } catch {}
	      try { s.pane?.remove?.(); } catch {}
	      try { s.tab?.remove?.(); } catch {}
	      sessions.splice(idx, 1);
	      if (activeId === id) {
	        if (sessions.length) setActive(sessions[0].id);
	        else activeId = null;
	      }
	    }

	    function closeEditor(id) {
	      const s = sessions.find(s => s.id === id);
	      if (!s) return;
	      if (s.dirty) {
	        const ok = confirm('æ–‡ä»¶å°šæœªä¿å­˜ï¼Œç¡®å®šå…³é—­å—ï¼Ÿ');
	        if (!ok) return;
	      }
	      removeEditor(id);
	    }

	    async function openEditor(filePath) {
	      const existing = findEditorByPath(filePath);
	      if (existing) {
	        setActive(existing.id);
	        try { existing.cm.focus(); } catch {}
	        return existing;
	      }

	      if (typeof CodeMirror !== 'function') {
	        showToast('âŒ ç¼–è¾‘å™¨ç»„ä»¶æœªåŠ è½½ï¼ˆè¯·æ£€æŸ¥ç½‘ç»œ/CDNï¼‰');
	        return null;
	      }

	      const id = `edit-${editorCounter++}`;
	      const tabs = document.getElementById('tabs');
	      const tab = document.createElement('div');
	      tab.className = 'tab';
	      tab.appendChild(document.createTextNode(basename(filePath)));
	      const close = document.createElement('span');
	      close.className = 'close';
	      close.textContent = 'Ã—';
	      close.onclick = (e) => { e.stopPropagation(); closeEditor(id); };
	      tab.appendChild(close);
	      tab.onclick = () => setActive(id);
	      tabs.appendChild(tab);

	      const pane = document.createElement('div');
	      pane.className = 'editor-pane';
	      const toolbar = document.createElement('div');
	      toolbar.className = 'editor-toolbar';
	      const titleEl = document.createElement('div');
	      titleEl.className = 'editor-title';
	      titleEl.textContent = filePath;
	      const actions = document.createElement('div');
	      actions.className = 'editor-actions';
	      const saveBtn = document.createElement('button');
	      saveBtn.className = 'mini-btn';
	      saveBtn.textContent = 'ä¿å­˜';
	      const reloadBtn = document.createElement('button');
	      reloadBtn.className = 'mini-btn secondary';
	      reloadBtn.textContent = 'é‡è½½';
	      const closeBtn = document.createElement('button');
	      closeBtn.className = 'mini-btn danger';
	      closeBtn.textContent = 'å…³é—­';
	      actions.appendChild(saveBtn);
	      actions.appendChild(reloadBtn);
	      actions.appendChild(closeBtn);
	      toolbar.appendChild(titleEl);
	      toolbar.appendChild(actions);
	      const body = document.createElement('div');
	      body.className = 'editor-body';
	      pane.appendChild(toolbar);
	      pane.appendChild(body);
	      document.getElementById('term-area').appendChild(pane);

	      const cm = CodeMirror(body, {
	        value: '',
	        lineNumbers: true,
	        theme: 'material-darker',
	        indentUnit: 2,
	        tabSize: 2,
	        lineWrapping: false,
	        viewportMargin: 20,
	      });
	      try { cm.setSize('100%', '100%'); } catch {}

	      const session = {
	        type: 'editor',
	        id,
	        filePath,
	        displayName: basename(filePath),
	        tab,
	        pane,
	        cm,
	        titleEl,
	        dirty: false,
	        _suppressDirty: false,
	        mtimeMs: null,
	        size: null,
	      };
	      sessions.push(session);

	      cm.on('change', () => {
	        if (session._suppressDirty) return;
	        if (!session.dirty) {
	          session.dirty = true;
	          updateEditorTabTitle(session);
	        }
	      });

	      saveBtn.onclick = async (e) => { e.preventDefault(); e.stopPropagation(); await saveEditorFile(session); };
	      reloadBtn.onclick = async (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        if (session.dirty) {
	          const ok = confirm('å½“å‰æœ‰æœªä¿å­˜ä¿®æ”¹ï¼Œä»è¦é‡è½½å—ï¼Ÿ');
	          if (!ok) return;
	        }
	        await loadEditorFile(session);
	      };
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeEditor(id); };

	      setActive(id);
	      const ok = await loadEditorFile(session);
	      if (!ok) {
	        // æ‰“å¼€å¤±è´¥æ—¶è‡ªåŠ¨å›æ”¶ tab/paneï¼Œé¿å…ç•™ä¸‹ç©ºç™½çª—å£
	        removeEditor(id);
	        return null;
	      }
	      try { cm.focus(); } catch {}
	      return session;
	    }

	    // å°†åç«¯ PTY è¾“å‡ºåšâ€œåˆå¸§/åˆæ‰¹â€å†™å…¥ï¼Œé¿å…é•¿å¯¹è¯ä¸‹é«˜é¢‘ term.write å¯¼è‡´æ»šåŠ¨å¡é¡¿
	    function isTermAtBottom(term) {
	      try {
	        const buf = term?.buffer?.active;
	        if (!buf) return true;
	        const viewportY = (typeof buf.viewportY === 'number') ? buf.viewportY : buf.baseY;
	        return viewportY === buf.baseY;
	      } catch {
	        return true;
	      }
	    }

	    function scheduleTermFlush(session) {
	      try {
	        if (!session?.term) return;
	        if (session._termFlushScheduled) return;
	        session._termFlushScheduled = true;

	        const active = session.id === activeId;
	        const fast = active && isTermAtBottom(session.term) && !document.hidden;

	        if (fast && typeof requestAnimationFrame === 'function') {
	          requestAnimationFrame(() => {
	            session._termFlushScheduled = false;
	            flushTermWrites(session);
	          });
	        } else {
	          const delay = document.hidden ? 200 : 80;
	          session._termFlushTimer = setTimeout(() => {
	            session._termFlushScheduled = false;
	            flushTermWrites(session);
	          }, delay);
	        }
	      } catch {}
	    }

	    function flushTermWrites(session) {
	      try {
	        if (!session?.term) return;
	        if (session._termWriting) return;
	        const data = session._pendingTermWrites;
	        if (!data) return;
	        session._pendingTermWrites = '';
	        session._termWriting = true;
	        session.term.write(data, () => {
	          session._termWriting = false;
	          if (session._pendingTermWrites) scheduleTermFlush(session);
	        });
	      } catch {
	        // å¦‚æœ write å›è°ƒå¼‚å¸¸ï¼Œç¡®ä¿ä¸ä¼šå¡æ­»åœ¨ writing çŠ¶æ€
	        try { session._termWriting = false; } catch {}
	      }
	    }

		    function queueTermWrite(session, chunk) {
		      try {
		        if (!session?.term) return;
		        if (!chunk) return;
		        session._pendingTermWrites = (session._pendingTermWrites || '') + chunk;

	        // æµè§ˆå™¨/è®¾å¤‡æ€§èƒ½ä¸è¶³æ—¶ï¼Œä¼˜å…ˆåŠ å¿«åˆ·æ–°ï¼Œé¿å…å¾…å†™å…¥é˜Ÿåˆ—æ— ç•Œå¢é•¿å¯¼è‡´æ›´å¡
	        if (!session._termWriting && session._pendingTermWrites.length > 256 * 1024) {
	          flushTermWrites(session);
	          return;
	        }
	        scheduleTermFlush(session);
		      } catch {}
		    }

		    // æ‰‹æœºè¾“å…¥æ³•ï¼ˆIMEï¼‰å…¼å®¹ï¼š
		    // æŸäº›è¾“å…¥æ³•åœ¨è¾“å…¥æ™ºèƒ½å¼•å·ç­‰å­—ç¬¦æ—¶ï¼Œä¼šåœ¨ composing é˜¶æ®µåå¤â€œæ•´æ®µé‡å‘â€ï¼Œ
		    // é€ æˆæ¯è¾“å…¥ä¸€ä¸ªå­—ç¬¦å°±æŠŠä¹‹å‰çš„å†…å®¹å†æ¬¡å‘é€åˆ°åç«¯ï¼ˆçœ‹èµ·æ¥åƒé‡å¤ç²˜è´´ï¼‰ã€‚
		    function installImeWorkaround(session) {
		      try {
		        if (!session?.pane || session._imeInstalled) return;
		        const ta = session.pane.querySelector('.xterm-helper-textarea');
		        if (!ta) return;

		        session._imeInstalled = true;
		        session._xtermTextarea = ta;
		        session._imeComposing = false;
		        session._imeLastData = '';
		        session._imeDedupeUntil = 0;
		        session._imeProblemModeUntil = 0;

		        function clearTextareaSoon() {
		          try {
		            if (!session._xtermTextarea) return;
		            // ä¸è¦åœ¨ composing ä¸­å¼ºè¡Œæ¸…ç©ºï¼Œå¦åˆ™ä¼šæ‰“æ–­è¾“å…¥æ³•å€™é€‰/è”æƒ³ã€‚
		            if (session._imeComposing) return;
		            // ç”¨ 0ms å»¶è¿Ÿï¼Œé¿å…ä¸ xterm å†…éƒ¨äº‹ä»¶é¡ºåºå†²çª
		            setTimeout(() => {
		              try {
		                if (session._imeComposing) return;
		                session._xtermTextarea.value = '';
		                // æŸäº›æµè§ˆå™¨éœ€è¦æ˜¾å¼é‡ç½® selectionï¼Œé¿å…è¾“å…¥æ³•ç»§ç»­åŸºäºæ—§æ–‡æœ¬åšâ€œæ•´æ®µé‡å‘â€
		                if (typeof session._xtermTextarea.setSelectionRange === 'function') {
		                  session._xtermTextarea.setSelectionRange(0, 0);
		                }
		              } catch {}
		            }, 0);
		          } catch {}
		        }

		        ta.addEventListener(
		          'compositionstart',
		          () => {
		            session._imeComposing = true;
		            session._imeLastData = '';
		            session._imeDedupeUntil = Date.now() + 20000;
		          },
		          { passive: true }
		        );

		        ta.addEventListener(
		          'compositionupdate',
		          () => {
		            session._imeComposing = true;
		            session._imeDedupeUntil = Date.now() + 20000;
		          },
		          { passive: true }
		        );

		        ta.addEventListener(
		          'compositionend',
		          () => {
		            session._imeComposing = false;
		            session._imeLastData = '';
		            // æœ‰äº›è¾“å…¥æ³•åœ¨ compositionend åè¿˜ä¼šæŒç»­å‡ ç§’â€œæ•´æ®µé‡å‘â€
		            session._imeDedupeUntil = Date.now() + 8000;
		            // compositionend åå¼ºåˆ¶æ¸…ç©ºä¸€æ¬¡ textareaï¼Œé¿å…åç»­æŒ‰é”®åŸºäºæ—§å€¼é‡å‘æ•´æ®µ
		            clearTextareaSoon();
		          },
		          { passive: true }
		        );

		        // å…œåº•ï¼šåœ¨â€œé—®é¢˜çª—å£â€å†…ï¼Œæ¯æ¬¡ input éƒ½æ¸…ç©º textareaï¼Œé¿å…è¾“å…¥æ³•æŒç»­æºå¸¦å†å²æ–‡æœ¬
		        ta.addEventListener(
		          'input',
		          () => {
		            try {
		              if (session._imeComposing) return;
		              if (session._imeProblemModeUntil && Date.now() < session._imeProblemModeUntil) {
		                clearTextareaSoon();
		              }
		            } catch {}
		          },
		          { passive: true }
		        );
		      } catch {}
		    }

			    function createTerminal(cwd, autorunCmd=null, sessionId=null) {
	      const id = `term-${counter++}`;
      const tabs = document.getElementById('tabs');
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = sessionId ? `ç»ˆç«¯ ${sessions.length + 1} (æ¢å¤)` : `ç»ˆç«¯ ${sessions.length + 1}`;
	      const close = document.createElement('span');
	      close.className = 'close';
	      close.textContent = 'Ã—';
	      close.onclick = (e) => { e.stopPropagation(); closeTerminal(id); };
	      tab.appendChild(close);
      tab.onclick = () => setActive(id);
      tabs.appendChild(tab);

	      const pane = document.createElement('div');
	      pane.className = 'term-pane';
	      document.getElementById('term-area').appendChild(pane);

	      // é»˜è®¤å•å…ƒæ ¼å°ºå¯¸ï¼ˆä¼šåœ¨ term.open åå°½é‡ç”¨ xterm å®æµ‹å€¼æ›¿æ¢ï¼Œé¿å…ä¸åŒæµè§ˆå™¨ä¸‹ rows è®¡ç®—åå·®å¯¼è‡´â€œå­—é“ºä¸æ»¡â€ï¼‰
	      let cellWidth = 7.6;
	      let cellHeight = 18;

	      function updateCellMetrics(term) {
	        try {
	          const d = term?._core?._renderService?.dimensions;
	          const w = d?.actualCellWidth ?? d?.css?.cell?.width;
	          const h = d?.actualCellHeight ?? d?.css?.cell?.height;
	          if (Number.isFinite(w) && w > 0) cellWidth = w;
	          if (Number.isFinite(h) && h > 0) cellHeight = h;
	        } catch {}
	      }

		      // è®¡ç®—åˆå§‹ç»ˆç«¯å°ºå¯¸
		      function calculateTermSize() {
		        const termArea = document.getElementById('term-area');
		        // æ³¨æ„ï¼šç§»åŠ¨ç«¯ä¼šåœ¨åº•éƒ¨æ¸²æŸ“ä¸€ä¸ªâ€œç©ºç™½è§¦æ§æ¿â€(#cursor-pad) ä½œä¸ºå•æŒ‡ç§»åŠ¨å…‰æ ‡åŒºåŸŸï¼Œ
		        // ç»ˆç«¯å®é™…å¯ç”¨åŒºåŸŸä»¥ pane çš„å°ºå¯¸ä¸ºå‡†ï¼Œé¿å…è¡Œæ•°è®¡ç®—åå¤§å¯¼è‡´å†…å®¹è¢«é®æŒ¡ã€‚
		        const container = pane || termArea;
		        // pane å·²æŒ‰ CSS inset æ‰£æ‰è¾¹è·ï¼Œè¿™é‡Œç›´æ¥ç”¨ clientWidth/clientHeightï¼Œé¿å…è¯¯å·®å¯¼è‡´åº•éƒ¨å‡ºç°â€œç©ºéš™æ„Ÿâ€ã€‚
		        const availableWidth = container.clientWidth;
		        const availableHeight = container.clientHeight;
		        
		        const cols = Math.floor(availableWidth / (cellWidth || 1));
		        const rows = Math.floor(availableHeight / (cellHeight || 1));
	        
	        return {
	          cols: Math.max(Math.min(cols, 150), 20),
	          rows: Math.max(Math.min(rows, 50), 10)
        };
      }

      const initialSize = calculateTermSize();
	      const term = new Terminal({ 
	        convertEol: true, 
	        theme: { background: '#0f1115' },
	        cols: initialSize.cols,
	        rows: initialSize.rows,
	        scrollback: 5000,
	        cursorBlink: true,
	        fontSize: 13,
	        fontFamily: 'Consolas, "Courier New", monospace',
	        allowTransparency: false,
	        cursorStyle: 'block',
	        // æ˜ç¡®ä½¿ç”¨ canvas æ¸²æŸ“ï¼ˆä¸æ”¯æŒåˆ™è‡ªåŠ¨å¿½ç•¥ï¼‰ï¼Œé¿å… DOM æ¸²æŸ“åœ¨é•¿è¾“å‡ºä¸‹æ›´æ˜“å¡é¡¿
	        rendererType: 'canvas'
	      });
	      
	      term.open(pane);

	      // å°è¯•å¯ç”¨ WebGL æ¸²æŸ“åŠ é€Ÿï¼ˆå¤±è´¥åˆ™è‡ªåŠ¨é™çº§ä¸º canvasï¼‰
	      try {
	        if (typeof term.loadAddon === 'function' && window.WebglAddon?.WebglAddon) {
	          const webgl = new window.WebglAddon.WebglAddon();
	          term.loadAddon(webgl);
	        }
	      } catch (e) {
	        console.warn('WebGL æ¸²æŸ“åŠ é€Ÿä¸å¯ç”¨ï¼Œå·²é™çº§:', e);
	      }

	      // åˆ›å»ºä¸€ä¸ªä¸“é—¨çš„resizeå‡½æ•°
	      function resizeTerminal() {
	        updateCellMetrics(term);
	        const newSize = calculateTermSize();
	        if (term.cols !== newSize.cols || term.rows !== newSize.rows) {
	          term.resize(newSize.cols, newSize.rows);
	        }
	      }

      // ç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–
      let resizeTimeout;
	      const resizeObserver = new ResizeObserver(() => {
	        clearTimeout(resizeTimeout);
	        resizeTimeout = setTimeout(resizeTerminal, 50);
	      });
	      // è§‚å¯Ÿ pane å°ºå¯¸å˜åŒ–æ›´ç²¾ç¡®ï¼ˆç»å¯¹å®šä½ + inset å˜åŒ–ä¹Ÿèƒ½è§¦å‘ï¼‰ï¼Œé¿å…å‡ºç°â€œåº•éƒ¨æœ‰ç©ºç™½ä½† rows æ²¡è·Ÿä¸Šâ€çš„æƒ…å†µ
	      try { resizeObserver.observe(pane); } catch { resizeObserver.observe(document.getElementById('term-area')); }

	      // term.open åçš„å‰å‡ å¸§ï¼Œxterm çš„å®é™… cell å°ºå¯¸å¯èƒ½æ‰ç¨³å®šï¼šè¡¥å‡ æ¬¡æµ‹é‡ä¸ resizeï¼Œå°½é‡è®©å­—é“ºæ»¡é«˜åº¦ï¼ˆAndroid Edge å¸¸è§ï¼‰
	      try {
	        requestAnimationFrame(() => {
	          try { updateCellMetrics(term); resizeTerminal(); } catch {}
	          setTimeout(() => { try { updateCellMetrics(term); resizeTerminal(); } catch {} }, 60);
	          setTimeout(() => { try { updateCellMetrics(term); resizeTerminal(); } catch {} }, 220);
	        });
	      } catch {}

			      const session = { 
			        type: 'term',
			        id, cwd, term, pane, tab, ws: null, inputDisposable: null, 
			        autorun: autorunCmd,
			        resizeObserver,
			        resizeTerminal,
			        sessionId,
			        lastReplyText: '',
			        lastReplyLine: '',
			        _replyTextBytes: 0,
			        _capturingReply: false,
			        _replyCarry: '',
			        _pendingTermWrites: '',
			        _termFlushScheduled: false,
			        _termFlushTimer: null,
			        _termWriting: false,
			        _imeInstalled: false,
			        _xtermTextarea: null,
			        _imeComposing: false,
			        _imeLastData: '',
			        _imeDedupeUntil: 0,
			        _imeProblemModeUntil: 0
			      };
		      sessions.push(session);
		      // xterm çš„éšè— textarea å¯èƒ½åœ¨ open åå¼‚æ­¥å‡ºç°ï¼Œå»¶è¿Ÿå®‰è£… IME ç›‘å¬ã€‚
		      requestAnimationFrame(() => { try { installImeWorkaround(session); } catch {} });
	      // Ensure the terminal has the correct size before establishing WS, otherwise xterm may wrap/reflow
	      // the first line when a later resize happens (common on mobile/PWA during layout settle).
	      try { resizeTerminal(); } catch {}
	      requestAnimationFrame(() => {
	        setTimeout(() => {
	          try { resizeTerminal(); } catch {}
	          connectSession(session);
	        }, 0);
	      });
	      setActive(id);
	      
	      return session;
	    }

	    function connectSession(session) {
      // teardown old; suppress close message when reconnecting
      if (session.ws) {
        session.suppressClose = true;
        session.ws.close();
      }
      session.inputDisposable?.dispose();
      
      // åœ¨URLä¸­åŒ…å«ç»ˆç«¯å°ºå¯¸ã€tokenå’Œä¼šè¯ID
	      const params = new URLSearchParams({
	        cwd: session.cwd,
	        cols: session.term.cols,
	        rows: session.term.rows,
	        clientId,
	        token: authToken
	      });
      
      if (session.sessionId) {
        params.set('sessionId', session.sessionId);
        params.set('reconnect', 'true');
      }
      
      const url = `${location.origin.replace('http','ws')}/ws/pty?${params}`;
      const ws = new WebSocket(url);
      session.ws = ws;
      
				      ws.onmessage = ev => {
				        const data = ev.data;

	        // Backend may refuse reconnects to missing sessions (e.g. after server restart/cleanup).
	        if (data.startsWith('SESSION_NOT_FOUND:')) {
	          const missingId = data.split(':')[1];
	          console.warn('ä¼šè¯ä¸å­˜åœ¨:', missingId);

		          // Session is gone on the server; remove UI without deleting.
		          try { removeTerminal(session.id); } catch {}
		          if (!sessions.length) createTerminal('.');
		          return;
		        }

	        if (data.startsWith('SESSION_FORBIDDEN:')) {
	          const forbiddenId = data.split(':')[1];
	          console.warn('ä¼šè¯æ— æƒé™:', forbiddenId);
		          try { removeTerminal(session.id); } catch {}
		          if (!sessions.length) createTerminal('.');
		          return;
		        }
        
		        // æ£€æŸ¥æ˜¯å¦æ˜¯ä¼šè¯IDæ¶ˆæ¯
		        if (data.startsWith('SESSION_ID:')) {
		          session.sessionId = data.split(':')[1];
		          console.log('ä¼šè¯ID:', session.sessionId);
		          return;
		        }
		        
				        // Normal pty output (what we consider "reply")
				        updateLastReplyLine(session, data);
				        appendReplyText(session, data);
				        queueTermWrite(session, data);
				      };
      
	      ws.onclose = () => {
	        if (session.suppressClose) {
	          session.suppressClose = false;
	          return;
	        }
	        queueTermWrite(session, '\\r\\n[è¿æ¥å·²æ–­å¼€ - ä¼šè¯å·²ä¿å­˜ï¼Œå°è¯•è‡ªåŠ¨é‡è¿ä¸­...]\\r\\n');
	        // è‡ªåŠ¨é‡è¿ï¼ˆå¸¦æŒ‡æ•°é€€é¿ä¸Šé™ï¼‰
	        const base = 800;
	        const max = 8000;
	        const attempts = session._retries || 0;
	        const delay = Math.min(max, base * Math.pow(1.6, attempts));
	        session._retries = attempts + 1;
	        setTimeout(() => {
	          try {
	            connectSession(session);
	          } catch (e) {
	            queueTermWrite(session, `\\r\\n[é‡è¿å¤±è´¥ï¼š${e?.message || e}]\\r\\n`);
	          }
	        }, delay);
	      };
      
	      ws.onopen = () => {
	        session._capturingReply = true;
	        // è¯·æ±‚ä¼šè¯IDï¼ˆå¦‚æœæ˜¯æ–°ä¼šè¯ï¼‰
	        if (!session.sessionId) {
	          ws.send('GET_SESSION_ID');
	        }

	        // Re-assert current size right after connect (mobile layout can change after initial params).
	        try { ws.send(`RESIZE:${session.term.cols}:${session.term.rows}`); } catch {}
	        
	        if (session.autorun) {
	          setTimeout(() => {
	            ws.send(session.autorun);
	            ws.send('\n');
            session.autorun = null;
          }, 200);
        }
	      };
	      
	      session.inputDisposable = session.term.onData((d) => {
	        if (ws?.readyState !== 1) return;
	        try {
	          let payload = d;

	          // å…¼å®¹ï¼šæŠŠæ™ºèƒ½å¼•å·ç»Ÿä¸€ä¸º ASCIIï¼Œé¿å…æŸäº› shell/ç¨‹åºè§£æå¼‚å¸¸
	          if (typeof payload === 'string' && payload) {
	            const raw = payload;
	            payload = payload.replace(/[â€œâ€]/g, '"').replace(/[â€˜â€™]/g, "'");
	            // ç¦ç”¨â€œæˆå¯¹å¼•å·è‡ªåŠ¨è¡¥å…¨â€ï¼ˆå¸¸è§äºéƒ¨åˆ†å®‰å“è¾“å…¥æ³•ï¼Œå¦‚å°ç±³è¾“å…¥æ³•ï¼‰ã€‚
	            // è¿™ç±»è¾“å…¥æ³•ä¼šä¸€æ¬¡æ€§æ’å…¥ä¸¤ä¸ªå¼•å·å¹¶è¯•å›¾æŠŠå…‰æ ‡æ”¾åˆ°ä¸­é—´ï¼Œä½† xterm çš„è¾“å…¥æ¨¡å‹ä¸æ”¯æŒè¯¥è¡Œä¸ºï¼Œ
	            // å®¹æ˜“è§¦å‘åç»­æŒ‰é”®çš„â€œæ•´æ®µé‡å‘/é‡å¤ç²˜è´´â€ã€‚è¿™é‡Œç›´æ¥é™çº§ä¸ºåªå‘é€ä¸€ä¸ªå¼•å·ã€‚
	            if (payload === '""') payload = '"';
	            else if (payload === "''") payload = "'";

	            // å¦‚æœæ£€æµ‹åˆ°æ¥è‡ªè¾“å…¥æ³•çš„â€œå¼•å·ç›¸å…³è§¦å‘â€ï¼ˆæ™ºèƒ½å¼•å·/æˆå¯¹è¡¥å…¨ï¼‰ï¼Œå¼€å¯ä¸€ä¸ªçŸ­æš‚çš„â€œé—®é¢˜çª—å£â€ï¼Œ
	            // åœ¨çª—å£å†…æ›´ç§¯æåœ°æ¸…ç©º xterm textareaï¼Œé˜²æ­¢è¾“å…¥æ³•æŒç»­æºå¸¦å†å²æ–‡æœ¬é‡å‘æ•´æ®µã€‚
	            try {
	              const looksLikeImeQuote =
	                (typeof raw === 'string' && /[â€œâ€â€˜â€™]/.test(raw)) || raw === '""' || raw === "''";
	              if (looksLikeImeQuote) {
	                session._imeProblemModeUntil = Date.now() + 15000;
	                session._imeDedupeUntil = Math.max(session._imeDedupeUntil || 0, Date.now() + 15000);
	              }
	            } catch {}
	          }

	          // IME å»é‡ï¼ˆæ›´æ¿€è¿›çš„å…œåº•ï¼‰ï¼š
	          // ä¸€äº›æ‰‹æœºè¾“å…¥æ³•åœ¨è¾“å…¥æ™ºèƒ½å¼•å·ç­‰å­—ç¬¦åï¼Œä¼šåœ¨åç»­æŒ‰é”®é‡ŒæŒç»­å‘é€â€œæ•´æ®µæ–‡æœ¬â€ï¼Œ
	          // å¯¼è‡´ç»ˆç«¯çœ‹èµ·æ¥åƒâ€œæ¯è¾“å…¥ä¸€ä¸ªå­—ç¬¦å°±æŠŠä¹‹å‰å…¨éƒ¨å†ç²˜è´´ä¸€éâ€ã€‚
	          // è¿™é‡Œåœ¨ composing æœŸé—´/åˆšç»“æŸåä¸€æ®µæ—¶é—´å†…ï¼Œåšâ€œæœ€é•¿å…¬å…±å‰ç¼€â€å¢é‡å‘é€ã€‚
	          if (typeof payload === 'string' && payload.length > 1) {
	            const now = Date.now();
	            const inImeDedupe = !!session._imeComposing || (session._imeDedupeUntil && now < session._imeDedupeUntil);
	            if (inImeDedupe) {
	              const last = session._imeLastData || '';
	              let delta = payload;
	              if (last) {
	                let i = 0;
	                const max = Math.min(last.length, payload.length);
	                while (i < max && last.charCodeAt(i) === payload.charCodeAt(i)) i++;
	                delta = payload.slice(i);
	              }
	              session._imeLastData = payload;
	              if (!delta) return;
	              payload = delta;
	            } else if (session._imeLastData) {
	              session._imeLastData = '';
	            }
	          } else if (!session._imeComposing && session._imeLastData) {
	            session._imeLastData = '';
	          }

	          ws.send(payload);

	          // åœ¨é—®é¢˜çª—å£å†…ï¼ˆä¸”é composingï¼‰ï¼Œæ¯æ¬¡å‘é€åéƒ½æ¸…ç©º textareaï¼Œå°½é‡é˜»æ–­â€œæ•´æ®µé‡å‘â€é“¾è·¯
	          try {
	            if (!session._imeComposing && session._imeProblemModeUntil && Date.now() < session._imeProblemModeUntil) {
	              const ta = session._xtermTextarea;
	              if (ta) {
	                setTimeout(() => {
	                  try {
	                    if (session._imeComposing) return;
	                    ta.value = '';
	                    if (typeof ta.setSelectionRange === 'function') ta.setSelectionRange(0, 0);
	                  } catch {}
	                }, 0);
	              }
	            }
	          } catch {}
	        } catch {
	          try { ws.send(d); } catch {}
	        }

	        // When user submits a command (Enter), reset reply accumulator so "copy reply"
	        // grabs the full output from this command.
	        if (d.includes('\r') || d.includes('\n')) {
	          session.lastReplyText = '';
	          session._replyTextBytes = 0;
	          session._replyCarry = '';
	          session.lastReplyLine = '';
	          session._capturingReply = true;
	        }
	      });
      
      // ç›‘å¬ç»ˆç«¯å°ºå¯¸å˜åŒ–ï¼Œé€šçŸ¥åç«¯
      if (session.resizeListener) {
        session.resizeListener.dispose();
      }
      session.resizeListener = session.term.onResize(({ cols, rows }) => {
        if (ws?.readyState === 1) {
          ws.send(`RESIZE:${cols}:${rows}`);
        }
      });
    }

	    function setActive(id) {
	      activeId = id;
	      const activeSession = sessions.find(s => s.id === id) || null;
	      try { document.body.classList.toggle('editor-active', activeSession?.type === 'editor'); } catch {}

	      sessions.forEach(s => {
	        const active = s.id === id;
	        s.tab.classList.toggle('active', active);
	        // ä¸åŒé¢æ¿ç±»å‹çš„ display ä¸èƒ½ä¸€åˆ€åˆ‡ï¼š
	        // - editor-pane ä¾èµ– flex å¸ƒå±€ï¼ˆå¦åˆ™ editor-body çš„é«˜åº¦è®¡ç®—ä¼šå¤±æ•ˆï¼Œè¡¨ç°ä¸ºâ€œçœ‹ä¸åˆ°ç¼–è¾‘å™¨â€ï¼‰
	        // - term-pane ç”¨ block/flex éƒ½èƒ½å·¥ä½œï¼Œè¿™é‡Œä¿æŒ block
	        if (active) s.pane.style.display = (s.type === 'editor') ? 'flex' : 'block';
	        else s.pane.style.display = 'none';
	      });

	      // åˆ‡æ¢åˆ°æ´»åŠ¨ç»ˆç«¯åï¼Œä¼˜å…ˆæŠŠç§¯å‹è¾“å‡ºå¿«é€Ÿåˆ·æ–°ï¼ˆé¿å…åˆ‡æ¢åçœ‹åˆ°â€œå¡ä½â€ï¼‰
	      try {
	        const s = activeSession;
	        if (s?.type === 'term') {
	          if (s?._pendingTermWrites) flushTermWrites(s);
	          if (s?._pendingTermWrites) scheduleTermFlush(s);
	          try { s.term?.focus?.(); } catch {}
	        } else if (s?.type === 'editor') {
	          refreshEditorSession(s);
	          try { s.cm?.focus?.(); } catch {}
	        }
	      } catch {}

	    }

	    function getActive() {
	      return sessions.find(s => s.id === activeId);
	    }

	    function refreshEditorSession(s) {
	      try {
	        if (!s || s.type !== 'editor' || !s.cm) return;
	        // setSize èƒ½æ˜¾å¼è§£å†³æŸäº›æµè§ˆå™¨ä¸‹ CodeMirror é«˜åº¦è®¡ç®—åå·®ï¼ˆå¯¼è‡´é¡¶éƒ¨/åº•éƒ¨è¢«è£åˆ‡ï¼‰
	        try { s.cm.setSize('100%', '100%'); } catch {}
	        try { s.cm.refresh(); } catch {}
	      } catch {}
	    }

	    function refreshAllEditors() {
	      try { sessions.forEach(refreshEditorSession); } catch {}
	    }

	    // ç¼–è¾‘å™¨åœ¨å®¹å™¨å°ºå¯¸å˜åŒ–æ—¶éœ€è¦ refreshï¼Œå¦åˆ™å¯èƒ½å‡ºç°ç©ºç™½/é«˜åº¦ä¸æ­£ç¡®ï¼ˆå°¤å…¶æ˜¯ç§»åŠ¨ç«¯æ—‹è½¬/è½¯é”®ç›˜å¼¹å‡ºï¼‰
	    window.addEventListener('resize', () => {
	      try {
	        const s = getActive();
	        if (s?.type === 'editor') refreshEditorSession(s);
	      } catch {}
	    });

		    function getLatestNonEmptyLine(term) {
		      try {
		        const buf = term?.buffer?.active;
		        if (!buf) return '';
		        const start = (buf.baseY || 0) + (buf.cursorY || 0);
		        for (let y = start; y >= 0; y--) {
		          const line = buf.getLine(y);
		          if (!line) continue;
		          const text = (line.translateToString(true) || '').replace(/\s+$/g, '');
		          if (text.trim().length) return text;
		        }
		      } catch {}
		      return '';
		    }

			    // Track "terminal reply": latest non-empty line received from backend output.
			    function updateLastReplyLine(session, chunk) {
		      try {
		        if (!session) return;
		        const carry = session._replyCarry || '';
		        const text = (carry + (chunk || '')).replace(/\r/g, '');
		        const parts = text.split('\n');
		        session._replyCarry = parts.pop() || '';
		        for (const line of parts) {
		          const cleaned = (line || '').replace(/\s+$/g, '');
		          if (cleaned.trim()) session.lastReplyLine = cleaned;
		        }
			      } catch {}
			    }

			    // Track "terminal reply": full output text for the most recent command.
			    function appendReplyText(session, chunk) {
			      try {
			        if (!session?._capturingReply) return;
			        if (!chunk) return;
			        const text = String(chunk).replace(/\r/g, '');

			        // Avoid unbounded growth (keep last ~200KB per session).
			        const maxBytes = 200000;
			        const newBytes = session._replyTextBytes + text.length;
			        if (newBytes > maxBytes) {
			          const overflow = newBytes - maxBytes;
			          session.lastReplyText = (session.lastReplyText || '').slice(overflow);
			          session._replyTextBytes = Math.max(0, session._replyTextBytes - overflow);
			        }

			        session.lastReplyText = (session.lastReplyText || '') + text;
			        session._replyTextBytes += text.length;
			      } catch {}
			    }

	    async function writeClipboard(text) {
	      if (!text) return false;
	      try {
	        await navigator.clipboard.writeText(text);
	        return true;
	      } catch {
	        try {
	          const ta = document.createElement('textarea');
	          ta.value = text;
	          ta.style.position = 'fixed';
	          ta.style.left = '-9999px';
	          document.body.appendChild(ta);
	          ta.focus();
	          ta.select();
	          const ok = document.execCommand('copy');
	          ta.remove();
	          return ok;
	        } catch {
	          return false;
	        }
	      }
	    }

		    async function readClipboard() {
		      try {
		        return await navigator.clipboard.readText();
		      } catch {
		        return '';
		      }
		    }

		    // ç»Ÿä¸€çš„â€œç²˜è´´åˆ°æ´»åŠ¨ç»ˆç«¯â€ï¼ˆä¸è‡ªåŠ¨å›è½¦ï¼‰ï¼Œä¾›å·¥å…·æ /æŒ‡ä»¤é›†å…±ç”¨
			    function pasteTextToActiveTerminal(text, { toastOk = 'âœ… å·²ç²˜è´´', toastEmpty = 'âš ï¸ å†…å®¹ä¸ºç©º' } = {}) {
			      const s = getActive();
			      if (!s?.ws || s.ws.readyState !== 1) {
			        showToast('âŒ ç»ˆç«¯æœªè¿æ¥');
			        return false;
		      }
		      const normalized = String(text ?? '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
		      if (!normalized.trim()) {
		        showToast(toastEmpty);
		        return false;
		      }
		      // bracketed pasteï¼šé¿å…å¤šè¡Œè¢«é€è¡Œæ‰§è¡Œ
		      try {
		        s.ws.send(`\x1b[200~${normalized}\x1b[201~`);
		      } catch {
		        showToast('âŒ ç²˜è´´å¤±è´¥');
		        return false;
		      }
			      showToast(toastOk);
			      return true;
			    }

			    // ========= æŒ‡ä»¤é›†ï¼ˆé¢„è®¾å‘½ä»¤ï¼‰ =========
			    function initCommandSets() {
			      const page = document.getElementById('cmdset-page');
			      const backBtn = document.getElementById('cmdsetBackBtn');
			      const breadcrumbEl = document.getElementById('cmdsetBreadcrumb');
			      const listEl = document.getElementById('cmdsetList');
			      const emptyEl = document.getElementById('cmdsetEmpty');
			      const newCmdBtn = document.getElementById('cmdsetNewCommandBtn');
			      const newFolderBtn = document.getElementById('cmdsetNewFolderBtn');
			      const floatingBtn = document.getElementById('cmdsetFloatingBtn');

			      const modalBackdrop = document.getElementById('cmdset-modal-backdrop');
			      const modal = document.getElementById('cmdset-modal');
			      const modalTitle = document.getElementById('cmdsetModalTitle');
			      const nameInput = document.getElementById('cmdsetNameInput');
			      const contentField = document.getElementById('cmdsetContentField');
			      const contentInput = document.getElementById('cmdsetContentInput');
			      const autoSendField = document.getElementById('cmdsetAutoSendField');
			      const autoSendInput = document.getElementById('cmdsetAutoSendInput');
			      const modalCancelBtn = document.getElementById('cmdsetModalCancelBtn');
			      const modalOkBtn = document.getElementById('cmdsetModalOkBtn');
			      const modalCloseBtn = document.getElementById('cmdsetModalCloseBtn');

			      const confirmBackdrop = document.getElementById('cmdset-confirm-backdrop');
			      const confirmModal = document.getElementById('cmdset-confirm-modal');
			      const confirmText = document.getElementById('cmdsetConfirmText');
			      const confirmCancelBtn = document.getElementById('cmdsetConfirmCancelBtn');
			      const confirmOkBtn = document.getElementById('cmdsetConfirmOkBtn');
			      const confirmCloseBtn = document.getElementById('cmdsetConfirmCloseBtn');

			      if (!page || !backBtn || !breadcrumbEl || !listEl || !emptyEl || !newCmdBtn || !newFolderBtn || !floatingBtn) return;
				      const modalDeleteBtn = document.getElementById('cmdsetModalDeleteBtn');
				      if (!modalBackdrop || !modal || !modalTitle || !nameInput || !contentField || !contentInput || !autoSendField || !autoSendInput || !modalCancelBtn || !modalOkBtn || !modalCloseBtn || !modalDeleteBtn) return;
			      if (!confirmBackdrop || !confirmModal || !confirmText || !confirmCancelBtn || !confirmOkBtn || !confirmCloseBtn) return;

			      const state = {
			        root: null,
			        path: ['root'], // id æ ˆ
			        modalMode: 'command', // 'command' | 'folder'
			        pendingDelete: null, // node id
			        loading: false,
			      };

			      const genId = () => `c_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;

			      function findNodeById(id, node) {
			        if (!node) return null;
			        if (node.id === id) return node;
			        if (node.type === 'folder' && Array.isArray(node.children)) {
			          for (const ch of node.children) {
			            const r = findNodeById(id, ch);
			            if (r) return r;
			          }
			        }
			        return null;
			      }

			      function getCurrentFolder() {
			        let node = state.root;
			        for (let i = 1; i < state.path.length; i++) {
			          const id = state.path[i];
			          node = node?.children?.find((c) => c.id === id);
			        }
			        if (!node || node.type !== 'folder') return state.root;
			        return node;
			      }

			      function updateBreadcrumb() {
			        const names = [];
			        let node = state.root;
			        names.push('æ ¹ç›®å½•');
			        for (let i = 1; i < state.path.length; i++) {
			          const id = state.path[i];
			          node = node?.children?.find((c) => c.id === id);
			          if (node) names.push(node.name);
			        }
			        breadcrumbEl.textContent = names.join(' / ');
			      }

			      function renderList() {
			        const folder = getCurrentFolder();
			        if (!folder) return;
			        const items = (folder.children || []).slice().sort((a, b) => a.name.localeCompare(b.name, 'zh-Hans-CN'));
			        listEl.innerHTML = '';
			        if (!items.length) {
			          emptyEl.style.display = 'block';
			          return;
			        }
			        emptyEl.style.display = 'none';
			        for (const item of items) {
			          const row = document.createElement('div');
			          row.className = 'cmdset-item';
			          const ico = document.createElement('div');
			          ico.className = 'ico';
			          ico.textContent = item.type === 'folder' ? 'ğŸ“‚' : 'â–¶ï¸';
			          const name = document.createElement('div');
			          name.className = 'name';
		          name.textContent = item.name;
			          const meta = document.createElement('div');
			          meta.className = 'meta';
			          if (item.type === 'folder') {
			            meta.textContent = 'æ–‡ä»¶å¤¹';
			          } else {
			            const preview = (item.content || '').slice(0, 60);
			            meta.textContent = (item.autoSend ? 'è‡ªåŠ¨å‘é€ Â· ' : '') + preview;
			          }
			        const del = document.createElement('button');
			        del.className = 'cmdset-edit';
			        del.textContent = 'ç¼–è¾‘';

			          row.appendChild(ico);
			          row.appendChild(name);
			          row.appendChild(meta);
			          row.appendChild(del);

			          row.onclick = (e) => {
			            e.preventDefault();
			            e.stopPropagation();
			            if (item.type === 'folder') {
			              state.path.push(item.id);
			              updateBreadcrumb();
			              renderList();
			              return;
			            }
			            const ok = pasteTextToActiveTerminal(item.content, { toastOk: item.autoSend ? 'âœ… å·²å‘é€æŒ‡ä»¤' : 'âœ… å·²ç²˜è´´æŒ‡ä»¤', toastEmpty: 'âš ï¸ æŒ‡ä»¤ä¸ºç©º' });
			            if (ok && item.autoSend) {
			              try {
			                const s = getActive();
			                setTimeout(() => { try { s?.ws?.send('\r'); } catch {} }, 20);
			              } catch {}
			            }
			            if (ok) closeCommandSetsPage();
			          };

			          del.onclick = (e) => {
			            e.preventDefault();
			            e.stopPropagation();
			            openEditModal(item);
			          };

			          listEl.appendChild(row);
			        }
			      }

			      function openPage() {
			        page.classList.add('open');
			        page.setAttribute('aria-hidden', 'false');
			        try { listEl.scrollTop = 0; } catch {}
			      }
			      function closeCommandSetsPage() {
			        page.classList.remove('open');
			        page.setAttribute('aria-hidden', 'true');
			      }

			      async function loadCommandSets() {
			        state.loading = true;
			        try {
			          const res = await fetch('/api/command-sets');
			          const data = await res.json();
			          if (data && data.root) state.root = data.root;
			        } catch (e) {
			          console.error('åŠ è½½æŒ‡ä»¤é›†å¤±è´¥', e);
			          state.root = { id: 'root', type: 'folder', name: 'root', children: [] };
			        } finally {
			          state.loading = false;
			          if (!state.root) state.root = { id: 'root', type: 'folder', name: 'root', children: [] };
			          state.path = [state.root.id || 'root'];
			        }
			      }

			      async function saveCommandSets() {
			        if (!state.root) return;
			        try {
			          await fetch('/api/command-sets', {
			            method: 'PUT',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ root: state.root }),
			          });
			        } catch (e) {
			          console.error('ä¿å­˜æŒ‡ä»¤é›†å¤±è´¥', e);
			          showToast('âš ï¸ ä¿å­˜å¤±è´¥');
			        }
			      }

				      function openCreateModal(mode, editingItem = null) {
				        state.modalMode = mode;
				        state.editingNode = editingItem || null;
				        modalTitle.textContent = editingItem
				          ? (mode === 'folder' ? 'ç¼–è¾‘æ–‡ä»¶å¤¹' : 'ç¼–è¾‘æŒ‡ä»¤')
				          : (mode === 'folder' ? 'æ–°å»ºæ–‡ä»¶å¤¹' : 'æ–°å»ºæŒ‡ä»¤');
				        const isFolder = mode === 'folder';
				        contentField.style.display = isFolder ? 'none' : 'block';
				        autoSendField.style.display = isFolder ? 'none' : 'block';

				        if (editingItem) {
				          nameInput.value = editingItem.name || '';
				          if (!isFolder) {
				            contentInput.value = editingItem.content || '';
				            autoSendInput.checked = Boolean(editingItem.autoSend);
				          } else {
				            contentInput.value = '';
				            autoSendInput.checked = false;
				          }
				          modalDeleteBtn.style.display = 'inline-flex';
				        } else {
				          nameInput.value = '';
				          contentInput.value = '';
				          autoSendInput.checked = false;
				          modalDeleteBtn.style.display = 'none';
				        }

				        modalBackdrop.classList.add('open');
				        modal.classList.add('open');
				        modal.setAttribute('aria-hidden', 'false');
				        setTimeout(() => { try { nameInput.focus(); } catch {} }, 0);
				      }

				      function closeCreateModal() {
				        modalBackdrop.classList.remove('open');
				        modal.classList.remove('open');
				        modal.setAttribute('aria-hidden', 'true');
				        state.editingNode = null;
				        modalDeleteBtn.onclick = null;
				      }

			      function openDeleteConfirm(item) {
			        state.pendingDelete = item;
			        confirmText.textContent = item.type === 'folder'
			          ? `ç¡®è®¤åˆ é™¤æ–‡ä»¶å¤¹â€œ${item.name}â€åŠå…¶ä¸­æ‰€æœ‰æŒ‡ä»¤ï¼Ÿ`
			          : `ç¡®è®¤åˆ é™¤æŒ‡ä»¤â€œ${item.name}â€ï¼Ÿ`;
			        confirmBackdrop.classList.add('open');
			        confirmModal.classList.add('open');
			        confirmModal.setAttribute('aria-hidden', 'false');
			      }

			      function closeDeleteConfirm() {
			        state.pendingDelete = null;
			        confirmBackdrop.classList.remove('open');
			        confirmModal.classList.remove('open');
			        confirmModal.setAttribute('aria-hidden', 'true');
			      }

			      function removeNodeById(targetId, node) {
			        if (!node || node.type !== 'folder' || !Array.isArray(node.children)) return false;
			        const idx = node.children.findIndex((c) => c.id === targetId);
			        if (idx !== -1) {
			          node.children.splice(idx, 1);
			          return true;
			        }
			        for (const ch of node.children) {
			          if (ch.type === 'folder' && removeNodeById(targetId, ch)) return true;
			        }
			        return false;
			      }

			      async function ensureLoadedThen(fn) {
			        if (!state.root) await loadCommandSets();
			        fn();
			      }

				      async function handleCreateOk() {
				        const name = nameInput.value.trim();
				        const content = contentInput.value;
				        if (!name) {
				          showToast('âš ï¸ åç§°ä¸èƒ½ä¸ºç©º');
				          return;
				        }
				        const folder = getCurrentFolder();
				        if (!folder || folder.type !== 'folder') return;
				        if (state.editingNode) {
				          state.editingNode.name = name;
				          if (state.editingNode.type === 'command') {
				            state.editingNode.content = content || '';
				            state.editingNode.autoSend = Boolean(autoSendInput.checked);
				          }
				        } else {
				          const node = state.modalMode === 'folder'
				            ? { id: genId(), type: 'folder', name, children: [] }
				            : { id: genId(), type: 'command', name, content: content || '', autoSend: Boolean(autoSendInput.checked) };
				          folder.children = folder.children || [];
				          folder.children.push(node);
				        }
				        await saveCommandSets();
				        closeCreateModal();
				        renderList();
				      }

			      async function handleDeleteOk() {
			        if (!state.pendingDelete) return;
			        removeNodeById(state.pendingDelete.id, state.root);
			        // åˆ é™¤æ—¶å¦‚æœå½“å‰è·¯å¾„å·²è¢«åˆ æ‰ï¼Œé€€å›ä¸Šä¸€çº§
			        const existsPath = (ids) => {
			          let n = state.root;
			          for (let i = 1; i < ids.length; i++) {
			            const id = ids[i];
			            n = n?.children?.find((c) => c.id === id);
			            if (!n) return false;
			          }
			          return true;
			        };
			        if (!existsPath(state.path)) {
			          state.path = [state.root?.id || 'root'];
			        }
			        await saveCommandSets();
			        closeDeleteConfirm();
			        updateBreadcrumb();
			        renderList();
			      }

				      function openCommandSetsPage() {
				        ensureLoadedThen(() => {
				          updateBreadcrumb();
				          renderList();
				          openPage();
				        });
				      }

				      function handleBack() {
				        if (state.path.length > 1) {
				          state.path.pop();
				          updateBreadcrumb();
				          renderList();
				        } else {
				          closeCommandSetsPage();
				        }
				      }

				      function openEditModal(item) {
				        openCreateModal(item.type, item);
				        modalDeleteBtn.onclick = (e) => {
				          e.preventDefault(); e.stopPropagation();
				          state.pendingDelete = item;
				          closeCreateModal();
				          openDeleteConfirm(item);
				        };
				      }

				      // äº‹ä»¶ç»‘å®š
				      floatingBtn.onclick = () => openCommandSetsPage();
				      newCmdBtn.onclick = () => openCreateModal('command', null);
				      newFolderBtn.onclick = () => openCreateModal('folder', null);
			      modalCancelBtn.onclick = closeCreateModal;
			      modalCloseBtn.onclick = closeCreateModal;
			      modalOkBtn.onclick = handleCreateOk;
			      backBtn.onclick = handleBack;

			      confirmCancelBtn.onclick = closeDeleteConfirm;
			      confirmCloseBtn.onclick = closeDeleteConfirm;
			      confirmOkBtn.onclick = handleDeleteOk;

			      // æš´éœ²åˆ°å…¨å±€
			      window.openCommandSetsPage = openCommandSetsPage;
			    }

			    function stripTerminalControl(text) {
			      try {
			        let s = String(text ?? '');
			        if (!s) return '';

			        // Some environments/loggers render ESC as the visible two-character sequence "^["
			        // (caret notation). If copied, it shows up as "^[[...". Strip those too.
			        // CSI: ^[[ ... command
			        s = s.replace(/\^\[\[[0-?]*[ -/]*[@-~]/g, '');
			        // OSC: ^[] ... ^[\
			        s = s.replace(/\^\[\][\s\S]*?\^\[\\/g, '');
			        // DCS/PM/APC: ^[P / ^[^ / ^[_ ... ^[\
			        s = s.replace(/\^\[[P^_][\s\S]*?\^\[\\/g, '');
			        // Single-character caret-notation ESC sequences
			        s = s.replace(/\^\[[@-Z\\-_]/g, '');

			        // OSC: ESC ] ... BEL or ESC \
			        s = s.replace(/\x1b\][^\x07\x1b]*(?:\x07|\x1b\\)/g, '');
			        // DCS/PM/APC: ESC P / ESC ^ / ESC _ ... ESC \
			        s = s.replace(/\x1b[P^_][\s\S]*?\x1b\\/g, '');
			        // CSI: ESC [ ... command
		        s = s.replace(/\x1b\[[0-?]*[ -/]*[@-~]/g, '');
		        // Single-character ESC sequences
		        s = s.replace(/\x1b[@-Z\\-_]/g, '');

		        // Control chars (keep \n and \t)
		        s = s.replace(/[\x00-\x08\x0B-\x1A\x1C-\x1F\x7F]/g, '');
		        // C1 controls
		        s = s.replace(/[\x80-\x9F]/g, '');

		        return s;
		      } catch {
		        return '';
		      }
		    }

			    // ========= Git å†å²é¡µï¼ˆé•¿æŒ‰â€œæŒ‡ä»¤é›†â€æŒ‰é’®è¿›å…¥ï¼‰ =========
			    function initGitPage() {
			      const page = document.getElementById('git-page');
			      const backBtn = document.getElementById('gitBackBtn');
			      const refreshBtn = document.getElementById('gitRefreshBtn');
			      const cwdText = document.getElementById('gitCwdText');
			      const infoBox = document.getElementById('gitInfoBox');
			      const listEl = document.getElementById('gitList');
			      const resetBackdrop = document.getElementById('git-reset-backdrop');
			      const resetModal = document.getElementById('git-reset-modal');
			      const resetCloseBtn = document.getElementById('gitResetCloseBtn');
			      const resetCancelBtn = document.getElementById('gitResetCancelBtn');
			      const revertBtn = document.getElementById('gitRevertBtn');
			      const resetSoftBtn = document.getElementById('gitResetSoftBtn');
			      const resetHardBtn = document.getElementById('gitResetHardBtn');
			      const resetDesc = document.getElementById('gitResetDesc');
			      if (!page || !backBtn || !refreshBtn || !cwdText || !infoBox || !listEl) return;
			      if (!resetBackdrop || !resetModal || !resetCloseBtn || !resetCancelBtn || !revertBtn || !resetSoftBtn || !resetHardBtn || !resetDesc) return;

			      const state = {
			        loading: false,
			        cwd: '.',
			        resetCommit: null,
			        resetSubject: '',
			        resetPushed: null,
			        resetIsUpstreamHead: false,
			      };

			      function getTargetCwd() {
			        try {
			          const s = getActive?.();
			          if (s?.cwd) return s.cwd;
			        } catch {}
			        try {
			          const v = document.getElementById('path')?.value;
			          if (v) return v;
			        } catch {}
			        return '.';
			      }

			      function openPage() {
			        page.classList.add('open');
			        page.setAttribute('aria-hidden', 'false');
			      }

			      function closePage() {
			        page.classList.remove('open');
			        page.setAttribute('aria-hidden', 'true');
			      }

			      function escapeHtml(s) {
			        return String(s ?? '')
			          .replace(/&/g, '&amp;')
			          .replace(/</g, '&lt;')
			          .replace(/>/g, '&gt;')
			          .replace(/\"/g, '&quot;')
			          .replace(/'/g, '&#39;');
			      }

			      function setInfo(text) {
			        infoBox.style.display = 'block';
			        infoBox.textContent = String(text ?? '');
			      }

			      function clearList() {
			        listEl.innerHTML = '';
			      }

			      function renderCommits(commits) {
			        clearList();
			        if (!Array.isArray(commits) || !commits.length) return;
			        infoBox.style.display = 'none';
			        const fmtTime = (iso) => {
			          try {
			            const d = new Date(iso);
			            if (!Number.isFinite(d.getTime())) return '';
			            const pad = (n) => String(n).padStart(2, '0');
			            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
			          } catch {
			            return '';
			          }
			        };
			        for (let idx = 0; idx < commits.length; idx += 1) {
			          const c = commits[idx];
			          const item = document.createElement('div');
			          let stClass = 'git-unknown';
			          if (c.pushed === true) stClass = 'git-pushed';
			          else if (c.pushed === false) stClass = 'git-unpushed';
			          item.className = `cmdset-item ${stClass}`;
			          const author = String(c.author || '').trim();
			          const time = fmtTime(c.date);
			          const meta = [time, author].filter(Boolean).join(' Â· ');
			          item.innerHTML = `
			            <span class="ico">â‡</span>
			            <span class="name">${escapeHtml(c.subject || '(no subject)')}</span>
			            <span class="meta">${escapeHtml(meta || '')}</span>
			          `;
			          item.onclick = async (e) => {
			            e.preventDefault();
			            e.stopPropagation();
			            const hash = String(c.hash || '').trim();
			            if (!hash) return;
			            const ok = await writeClipboard(hash);
			            showToast(ok ? 'âœ… å·²å¤åˆ¶æäº¤å“ˆå¸Œ' : 'âŒ å¤åˆ¶å¤±è´¥');
			          };
			          // é•¿æŒ‰ï¼šæ‰“å¼€æ“ä½œå¼¹çª—ï¼ˆreset ä»…æœªæ¨é€å¯ç”¨ï¼›revert å¯¹ä»»æ„æäº¤å¯ç”¨ï¼‰
			          {
			            let timer = null;
			            const longPressMs = 520;
			            const start = () => {
			              try {
			                if (timer) clearTimeout(timer);
			                timer = setTimeout(() => {
			                  state.resetCommit = String(c.hash || '').trim();
			                  state.resetSubject = String(c.subject || '').trim();
			                  state.resetPushed = c.pushed;
			                  state.resetIsUpstreamHead = Boolean(c.isUpstreamHead);
			                  openResetModal();
			                }, longPressMs);
			              } catch {}
			            };
			            const cancel = () => {
			              if (timer) clearTimeout(timer);
			              timer = null;
			            };
			            item.addEventListener('pointerdown', start);
			            item.addEventListener('pointerup', cancel);
			            item.addEventListener('pointercancel', cancel);
			            item.addEventListener('pointerleave', cancel);
			          }
			          listEl.appendChild(item);
			        }
			      }

			      async function fetchJson(url, options) {
			        const res = await fetch(url, options);
			        const data = await res.json().catch(() => ({}));
			        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
			        return data;
			      }

			      async function fetchBranches(cwd) {
			        return fetchJson(`/api/git/branches?cwd=${encodeURIComponent(cwd)}`);
			      }

			      const branchModal = {
			        backdrop: null,
			        modal: null,
			        filter: null,
			        localList: null,
			        remoteList: null,
			        forceChk: null,
			        status: null,
			        okBtn: null,
			        cancelBtn: null,
			        closeBtn: null,
			        data: { locals: [], remotes: [], current: '' },
			        selected: '',
			      };

			      function renderBranchList(listEl, branches, current) {
			        listEl.innerHTML = '';
			        branches.forEach((name) => {
			          const div = document.createElement('div');
			          div.className = 'branch-item';
			          if (name === current) div.classList.add('active');
			          div.innerHTML = `<span>${name === current ? 'â­' : 'ğŸ”€'}</span><span style="flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${name}</span>`;
			          div.onclick = () => {
			            branchModal.selected = name;
			            // é«˜äº®
			            try {
			              branchModal.localList.querySelectorAll('.branch-item').forEach(el => el.classList.toggle('active', false));
			              branchModal.remoteList.querySelectorAll('.branch-item').forEach(el => el.classList.toggle('active', false));
			            } catch {}
			            div.classList.add('active');
			          };
			          listEl.appendChild(div);
			        });
			      }

      function openBranchModal(data) {
        branchModal.data = data || { locals: [], remotes: [], current: '' };
        branchModal.selected = data?.current || '';
        branchModal.filter.value = '';
        renderBranchList(branchModal.localList, data.locals || [], data.current);
        renderBranchList(branchModal.remoteList, data.remotes || [], data.current);
        branchModal.forceChk.checked = false;
        branchModal.status.textContent = `å½“å‰åˆ†æ”¯ï¼š${data.current || '-'}`;
        branchModal.backdrop.style.display = 'block';
        branchModal.modal.style.display = 'block';
        branchModal.backdrop.classList.add('open');
        branchModal.modal.classList.add('open');
      }

      function closeBranchModal() {
        branchModal.backdrop.classList.remove('open');
        branchModal.modal.classList.remove('open');
        branchModal.backdrop.style.display = 'none';
        branchModal.modal.style.display = 'none';
      }

			      function filterBranches(keyword) {
			        const kw = keyword.trim().toLowerCase();
			        const locals = (branchModal.data.locals || []).filter(n => !kw || n.toLowerCase().includes(kw));
			        const remotes = (branchModal.data.remotes || []).filter(n => !kw || n.toLowerCase().includes(kw));
			        renderBranchList(branchModal.localList, locals, branchModal.data.current);
			        renderBranchList(branchModal.remoteList, remotes, branchModal.data.current);
			      }

			      async function submitBranchSwitch() {
			        const cwd = getTargetCwd();
			        const target = branchModal.selected || branchModal.data.current;
			        if (!target) { showToast('âš ï¸ è¯·é€‰æ‹©è¦åˆ‡æ¢çš„åˆ†æ”¯'); return; }
			        branchModal.okBtn.disabled = true;
			        branchModal.cancelBtn.disabled = true;
			        try {
			          const res = await fetch('/api/git/checkout', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd, branch: target, force: branchModal.forceChk.checked }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            if (res.status === 409) {
			              branchModal.status.textContent = 'å·¥ä½œåŒºæœ‰æœªæäº¤ä¿®æ”¹ï¼šè¯·æäº¤/æš‚å­˜ï¼Œæˆ–å‹¾é€‰â€œå¼ºåˆ¶åˆ‡æ¢â€åé‡è¯•ï¼ˆä¼šä¸¢å¼ƒä¿®æ”¹ï¼‰';
			              branchModal.forceChk.focus();
			              return;
			            }
			            throw new Error(data?.error || `HTTP ${res.status}`);
			          }
			          showToast(`âœ… å·²åˆ‡æ¢åˆ° ${data?.current || target}`);
			          closeBranchModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          branchModal.status.textContent = `âŒ åˆ‡æ¢å¤±è´¥ï¼š${e?.message || e}`;
			        } finally {
			          branchModal.okBtn.disabled = false;
			          branchModal.cancelBtn.disabled = false;
			        }
			      }

			      async function doCreateBranch() {
			        const cwd = getTargetCwd();
			        try {
			          const from = prompt('ä»å“ªä¸ªæäº¤/åˆ†æ”¯åˆ›å»ºï¼Ÿ(é»˜è®¤ HEAD)', 'HEAD') || 'HEAD';
			          const name = prompt('æ–°åˆ†æ”¯åç§°');
			          if (!name || !name.trim()) return;
			          const res = await fetch('/api/git/checkout-new', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd, branch: name.trim(), from: from.trim() }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            if (res.status === 409) throw new Error('å·¥ä½œåŒºè„ï¼Œè¯·å…ˆæäº¤/æš‚å­˜æˆ–æ¸…ç†');
			            throw new Error(data?.error || `HTTP ${res.status}`);
			          }
			          showToast(`âœ… å·²åˆ›å»ºå¹¶åˆ‡æ¢åˆ° ${data?.current || name.trim()}`);
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`âŒ æ–°å»ºåˆ†æ”¯å¤±è´¥ï¼š${e?.message || e}`);
			        }
			      }

			      async function refresh({ allowInitPrompt = false } = {}) {
			        if (state.loading) return;
			        state.loading = true;
			        const cwd = getTargetCwd();
			        state.cwd = cwd;
			        cwdText.textContent = cwd;
			        {
			          const raw = String(cwd || '').trim();
			          const parts = raw.split(/[\\/]+/).filter(Boolean);
			          const hasHidden = parts.some((p) => p.startsWith('.') && p !== '.' && p !== '..');
			          if (raw === '.') {
			            setInfo('âš ï¸ ä¸ºå®‰å…¨èµ·è§ï¼Œç¦æ­¢åœ¨æ ¹ç›®å½•ï¼ˆ.ï¼‰æ‰“å¼€ Git ç®¡ç†é¡µã€‚è¯·å…ˆè¿›å…¥å…·ä½“é¡¹ç›®ç›®å½•ã€‚');
			            clearList();
			            state.loading = false;
			            return;
			          }
			          if (hasHidden) {
			            setInfo('âš ï¸ ä¸ºå®‰å…¨èµ·è§ï¼Œéšè—ç›®å½•å†…ç¦æ­¢æ‰“å¼€ Git ç®¡ç†é¡µã€‚è¯·åˆ‡æ¢åˆ°ééšè—é¡¹ç›®ç›®å½•ã€‚');
			            clearList();
			            state.loading = false;
			            return;
			          }
			        }
			        setInfo('åŠ è½½ä¸­â€¦');
			        clearList();
			        try {
			          const info = await fetchJson(`/api/git/info?cwd=${encodeURIComponent(cwd)}`);
			          if (!info?.gitAvailable) {
			            setInfo('âš ï¸ å½“å‰ç¯å¢ƒæœªå®‰è£… Git æˆ–ä¸å¯ç”¨ã€‚');
			            return;
			          }
			          if (!info?.isRepo) {
			            if (allowInitPrompt) {
			              const ok = confirm(`å½“å‰æ–‡ä»¶å¤¹ï¼ˆ${cwd}ï¼‰æœªåˆå§‹åŒ– Gitï¼Œæ˜¯å¦æ‰§è¡Œ git initï¼Ÿ`);
			              if (!ok) return;
			              await fetchJson('/api/git/init', {
			                method: 'POST',
			                headers: { 'Content-Type': 'application/json' },
			                body: JSON.stringify({ cwd }),
			              });
			              showToast('âœ… å·²æ‰§è¡Œ git init');
			            } else {
			              setInfo('å½“å‰æ–‡ä»¶å¤¹æœªåˆå§‹åŒ– Gitã€‚');
			              return;
			            }
			          }

			          const commitsResp = await fetchJson(`/api/git/commits?cwd=${encodeURIComponent(cwd)}&limit=80`);
			          const branch = commitsResp?.branch ? `åˆ†æ”¯ï¼š${commitsResp.branch}` : '';
			          const root = commitsResp?.repoRoot ? `ä»“åº“ï¼š${commitsResp.repoRoot}` : '';
			          const upstream = commitsResp?.upstream ? `ä¸Šæ¸¸ï¼š${commitsResp.upstream}` : 'ä¸Šæ¸¸ï¼šæœªé…ç½®';
			          const header = `${branch}${branch && root ? ' Â· ' : ''}${root}`.trim();
			          if (!commitsResp?.commits?.length) {
			            setInfo(header ? `${header}ï¼ˆæš‚æ— æäº¤ï¼‰\n${upstream}` : `æš‚æ— æäº¤è®°å½•ã€‚\n${upstream}`);
			          } else {
			            setInfo(`${header || 'æäº¤å†å²'}\n${upstream}\næç¤ºï¼šç»¿è‰²=å·²æ¨é€ï¼Œæ©™è‰²=æœªæ¨é€ï¼Œç°è‰²=æœªçŸ¥ï¼›é•¿æŒ‰æ¡ç›®å¯ Reset/Revert`);
			          }
			          renderCommits(commitsResp?.commits || []);
			        } catch (e) {
			          setInfo(`âŒ åŠ è½½å¤±è´¥ï¼š${escapeHtml(e?.message || 'unknown')}`);
			        } finally {
			          state.loading = false;
			        }
			      }

			      function openGitPage({ promptInit = false } = {}) {
			        openPage();
			        refresh({ allowInitPrompt: promptInit }).catch(() => {});
			      }

			      function openResetModal() {
			        const subj = state.resetSubject ? `â€œ${state.resetSubject}â€` : '(æ— æ ‡é¢˜)';
			        const canReset = state.resetPushed === false || (state.resetPushed === true && state.resetIsUpstreamHead === true);
			        try { resetSoftBtn.disabled = !canReset; } catch {}
			        try { resetHardBtn.disabled = !canReset; } catch {}
			        try {
			          resetSoftBtn.title = canReset ? 'è½¯å›é€€ï¼šreset åˆ°è¯¥æäº¤' : 'ä»…æœªæ¨é€æäº¤æˆ–äº‘ç«¯æœ€æ–°æäº¤å¯ç”¨';
			          resetHardBtn.title = canReset ? 'ç¡¬å›é€€ï¼šreset åˆ°è¯¥æäº¤' : 'ä»…æœªæ¨é€æäº¤æˆ–äº‘ç«¯æœ€æ–°æäº¤å¯ç”¨';
			        } catch {}
			        resetDesc.textContent =
			          `å°†å›é€€åˆ°è¯¥æäº¤ï¼š${subj}\n\n` +
			          `è½¯å›é€€ï¼šä»…ç§»åŠ¨æŒ‡é’ˆåˆ°è¯¥æäº¤ï¼Œä¸æ”¹åŠ¨å·¥ä½œåŒºæ–‡ä»¶ï¼ˆå·®å¼‚ä¼šä¿ç•™ä¸ºæš‚å­˜åŒº/å¾…æäº¤çŠ¶æ€ï¼‰ã€‚\n` +
			          `ç¡¬å›é€€ï¼šæŒ‡é’ˆä¸å·¥ä½œåŒºæ–‡ä»¶ä¸€èµ·å›åˆ°è¯¥æäº¤ï¼ˆä¼šä¸¢å¼ƒæœªæäº¤çš„å·¥ä½œåŒºæ”¹åŠ¨ï¼‰ã€‚\n` +
			          `Revertï¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æäº¤æ¥ååšè¯¥æäº¤çš„æ”¹åŠ¨ï¼ˆå¯ç”¨äºå·²æ¨é€æäº¤ï¼Œä½†å¯èƒ½äº§ç”Ÿå†²çªï¼‰ã€‚\n\n` +
			          `æç¤ºï¼šReset å¯¹â€œæœªæ¨é€â€æäº¤å¼€æ”¾ï¼›å¯¹â€œå·²æ¨é€â€æäº¤ä»…å…è®¸å›é€€åˆ°äº‘ç«¯æœ€æ–°ï¼ˆç”¨äºä¸äº‘ç«¯åŒæ­¥ï¼‰ï¼›Revert å¯¹å†å²æäº¤æ›´å®‰å…¨ã€‚`;
			        resetBackdrop.classList.add('open');
			        resetModal.classList.add('open');
			        resetBackdrop.setAttribute('aria-hidden', 'false');
			        resetModal.setAttribute('aria-hidden', 'false');
			      }

			      function closeResetModal() {
			        resetBackdrop.classList.remove('open');
			        resetModal.classList.remove('open');
			        resetBackdrop.setAttribute('aria-hidden', 'true');
			        resetModal.setAttribute('aria-hidden', 'true');
			        state.resetCommit = null;
			        state.resetSubject = '';
			        state.resetPushed = null;
			        state.resetIsUpstreamHead = false;
			      }

			      async function doReset(mode) {
			        const commit = String(state.resetCommit || '').trim();
			        if (!commit) return;
			        try {
			          const body = { cwd: getTargetCwd(), mode, commit };
			          if (mode === 'hard') body.confirmHard = true;
			          const res = await fetch('/api/git/reset', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify(body),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
			          showToast(mode === 'soft' ? 'âœ… è½¯å›é€€å®Œæˆ' : 'âœ… ç¡¬å›é€€å®Œæˆ');
			          closeResetModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`âŒ å›é€€å¤±è´¥ï¼š${e?.message || 'unknown'}`);
			        }
			      }

			      async function doRevert() {
			        const commit = String(state.resetCommit || '').trim();
			        if (!commit) return;
			        try {
			          const res = await fetch('/api/git/revert', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd: getTargetCwd(), commit }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            const msg = data?.hint ? `${data?.error || `HTTP ${res.status}`}ï¼ˆ${data.hint}ï¼‰` : (data?.error || `HTTP ${res.status}`);
			            if (res.status === 409) throw new Error(`${msg}ï¼š${data?.hint || ''}`.trim());
			            throw new Error(msg);
			          }
			          showToast('âœ… Revert å®Œæˆï¼ˆå·²ç”Ÿæˆæ–°æäº¤ï¼‰');
			          closeResetModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`âŒ Revert å¤±è´¥ï¼š${e?.message || 'unknown'}`);
			        }
			      }

      backBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        closePage();
      };
      refreshBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        refresh({ allowInitPrompt: false }).catch(() => {});
      };
      // åˆ†æ”¯é€‰æ‹©å¼¹çª—ç»‘å®š
      branchModal.backdrop = document.getElementById('git-branch-backdrop');
      branchModal.modal = document.getElementById('git-branch-modal');
      branchModal.filter = document.getElementById('gitBranchFilter');
      branchModal.localList = document.getElementById('gitBranchLocalList');
      branchModal.remoteList = document.getElementById('gitBranchRemoteList');
      branchModal.forceChk = document.getElementById('gitBranchForce');
      branchModal.status = document.getElementById('branch-status');
      branchModal.okBtn = document.getElementById('gitBranchOkBtn');
      branchModal.cancelBtn = document.getElementById('gitBranchCancelBtn');
      branchModal.closeBtn = document.getElementById('gitBranchCloseBtn');

      const branchSwitchBtn = document.getElementById('gitBranchSwitchBtn');
      const branchNewBtn = document.getElementById('gitBranchNewBtn');

      if (branchSwitchBtn) branchSwitchBtn.onclick = async (e) => {
        e.preventDefault(); e.stopPropagation();
        try {
          // ç¡®ä¿æ‡’åŠ è½½æ ·å¼å¯ç”¨
          try { document.getElementById('git-branch-style')?.removeAttribute('disabled'); } catch {}
          // è‹¥ Git é¡µé¢æœªæ‰“å¼€ï¼Œå…ˆæ‰“å¼€å†æ‹‰å–åˆ†æ”¯ï¼Œç¡®ä¿å¼¹çª—å åœ¨ Git ç®¡ç†è§†å›¾ä¸Š
          const gitPage = document.getElementById('git-page');
          if (gitPage && gitPage.getAttribute('aria-hidden') !== 'false') {
            openGitPage({ promptInit: false });
          }
          const cwd = getTargetCwd();
          const data = await fetchBranches(cwd);
          if (!data?.isRepo) { showToast('âš ï¸ ä¸æ˜¯ Git ä»“åº“'); return; }
          openBranchModal(data);
        } catch (err) {
          showToast(`âŒ è·å–åˆ†æ”¯å¤±è´¥ï¼š${err?.message || err}`);
        }
      };
      if (branchNewBtn) branchNewBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); doCreateBranch(); };

      if (branchModal.cancelBtn) branchModal.cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeBranchModal(); };
      if (branchModal.closeBtn) branchModal.closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeBranchModal(); };
      if (branchModal.backdrop) branchModal.backdrop.onclick = () => closeBranchModal();
      if (branchModal.okBtn) branchModal.okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); submitBranchSwitch(); };
      if (branchModal.filter) branchModal.filter.oninput = (e) => filterBranches(e.target.value || '');

			      resetBackdrop.onclick = closeResetModal;
			      resetCloseBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeResetModal(); };
			      resetCancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeResetModal(); };
			      revertBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const ok = confirm('Revert ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æäº¤æ¥ååšæ”¹åŠ¨ï¼Œç¡®è®¤æ‰§è¡Œï¼Ÿ');
			        if (!ok) return;
			        doRevert();
			      };
			      resetSoftBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        doReset('soft');
			      };
			      resetHardBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const ok = confirm('ç¡¬å›é€€ä¼šä¸¢å¼ƒæœªæäº¤çš„å·¥ä½œåŒºæ”¹åŠ¨ï¼Œç¡®è®¤ç»§ç»­ï¼Ÿ');
			        if (!ok) return;
			        doReset('hard');
			      };

			      window.openGitPage = openGitPage;
			    }

				    function initSideActions() {
				      const toggleBtn = document.getElementById('drawerToggleBtn');
				      const floatingCmdBtn = document.getElementById('cmdsetFloatingBtn');
				      const drawer = document.getElementById('right-drawer');
				      const backdrop = document.getElementById('drawer-backdrop');
				      const closeBtn = document.getElementById('drawerCloseBtn');

				      const orientationBtn = document.getElementById('orientationLockBtn');
				      const ctrlToggleBtn = document.getElementById('ctrlToggleBtn');
				      const altToggleBtn = document.getElementById('altToggleBtn');
				      const comboBtn = document.getElementById('comboFloatingBtn');
				      const undoBtn = document.getElementById('undoBtn');
				      const tabBtn = document.getElementById('tabBtn');
				      const enterBtn = document.getElementById('enterBtn');
				      const continueBtn = document.getElementById('continueBtn');
				      const escBtn = document.getElementById('escBtn');
				      const ctrlCBtn = document.getElementById('ctrlCBtn');

			      const pasteModalBackdrop = document.getElementById('paste-modal-backdrop');
			      const pasteModal = document.getElementById('paste-modal');
			      const pasteModalCloseBtn = document.getElementById('pasteModalCloseBtn');
			      const pasteModalCancelBtn = document.getElementById('pasteModalCancelBtn');
				      const pasteModalOkBtn = document.getElementById('pasteModalOkBtn');
				      const pasteInput = document.getElementById('paste-input');

				      if (!toggleBtn || !floatingCmdBtn || !drawer || !backdrop || !closeBtn) return;
					      if (!orientationBtn || !undoBtn || !comboBtn || !tabBtn || !enterBtn || !continueBtn || !escBtn || !ctrlCBtn) return;
					      if (!pasteModalBackdrop || !pasteModal || !pasteModalCloseBtn || !pasteModalCancelBtn || !pasteModalOkBtn || !pasteInput) return;

				      // æ—‹è½¬é”ï¼šæ— æ³•è¯»å–â€œç³»ç»Ÿæ—‹è½¬é”â€çŠ¶æ€ï¼Œåªæä¾› App å†…å¼€å…³ï¼ˆPWA é»˜è®¤å¯ç”¨ç«–å±é”ï¼‰
				      {
				        const ORIENT_KEY = 'lan_shell_orient_lock'; // 'portrait' | 'off'
				        let isActuallyLocked = false;
				        const getPref = () => {
				          try { return localStorage.getItem(ORIENT_KEY); } catch { return null; }
				        };
				        const setPref = (v) => {
				          try { localStorage.setItem(ORIENT_KEY, v); } catch {}
				        };

				        // PWA/ç‹¬ç«‹æ¨¡å¼ä¸‹é»˜è®¤é”å®šç«–å±ï¼Œé¿å…è¯¯æ¨ªå±ï¼ˆå¯æ‰‹åŠ¨å…³é—­ï¼‰
				        try {
				          if (!getPref() && isPWA()) setPref('portrait');
				        } catch {}

				        const syncBtn = () => {
				          const v = getPref();
				          const wants = v === 'portrait';
				          const on = wants && isActuallyLocked;
				          try { orientationBtn.classList.toggle('active', on); } catch {}
				          try {
				            if (on) orientationBtn.title = 'æ—‹è½¬ï¼šå·²é”å®šç«–å±ï¼ˆç‚¹å‡»å…è®¸æ—‹è½¬ï¼‰';
				            else if (wants) orientationBtn.title = 'æ—‹è½¬ï¼šå°†å°è¯•é”å®šç«–å±ï¼ˆéœ€æµè§ˆå™¨æ”¯æŒ/å¯èƒ½éœ€PWAæˆ–HTTPSï¼‰';
				            else orientationBtn.title = 'æ—‹è½¬ï¼šå…è®¸æ—‹è½¬ï¼ˆç‚¹å‡»é”å®šç«–å±ï¼‰';
				          } catch {}
				        };

				        const unlock = () => {
				          try { screen?.orientation?.unlock?.(); } catch {}
				          isActuallyLocked = false;
				        };

				        const lockPortrait = async ({ silent = false } = {}) => {
				          try {
				            if (!window.isSecureContext) {
				              if (!silent) showToast('âš ï¸ é”å®šæ—‹è½¬éœ€è¦HTTPSå®‰å…¨ä¸Šä¸‹æ–‡ï¼ˆæˆ–localhostï¼‰');
				              return false;
				            }
				            if (!screen?.orientation?.lock) {
				              if (!silent) showToast('âš ï¸ å½“å‰æµè§ˆå™¨ä¸æ”¯æŒé”å®šæ—‹è½¬');
				              return false;
				            }
				            await screen.orientation.lock('portrait-primary');
				            isActuallyLocked = true;
				            return true;
				          } catch (e) {
				            // å¸¸è§ï¼šéœ€è¦ä¸€æ¬¡ç”¨æˆ·æ‰‹åŠ¿ / ä»… PWA æˆ–å…¨å±å¯ç”¨
				            if (!silent) showToast('âš ï¸ é”å®šæ—‹è½¬å¤±è´¥ï¼šå¯èƒ½éœ€è¦åœ¨PWA/å…¨å±æˆ–ç‚¹å‡»åç”Ÿæ•ˆ');
				            isActuallyLocked = false;
				            return false;
				          }
				        };

				        const applyPref = async ({ silent = false } = {}) => {
				          const v = getPref();
				          if (v === 'portrait') {
				            // å…ˆæ¸…ç©ºå®é™…é”å®šçŠ¶æ€ï¼Œé¿å…â€œå¾’æœ‰å…¶è¡¨â€
				            isActuallyLocked = false;
				            syncBtn();
				            const ok = await lockPortrait({ silent: true });
				            if (ok) {
				              syncBtn();
				              if (!silent) showToast('âœ… å·²é”å®šç«–å±');
				              return;
				            }

				            // å…œåº•ï¼šç­‰ä¸‹ä¸€æ¬¡ç”¨æˆ·äº¤äº’å†è¯•ä¸€æ¬¡ï¼Œæå‡æˆåŠŸç‡ï¼ˆåªæœ‰åœ¨å®‰å…¨ä¸Šä¸‹æ–‡ä¸”æ”¯æŒ API æ—¶æ‰å€¼å¾—é‡è¯•ï¼‰
				            if (window.isSecureContext && screen?.orientation?.lock) {
				              const retry = async () => {
				                document.removeEventListener('touchstart', retry, true);
				                document.removeEventListener('click', retry, true);
				                const ok2 = await lockPortrait({ silent });
				                syncBtn();
				                if (ok2 && !silent) showToast('âœ… å·²é”å®šç«–å±');
				                if (!ok2 && !silent) {
				                  setPref('off');
				                  unlock();
				                  syncBtn();
				                }
				              };
				              document.addEventListener('touchstart', retry, { capture: true, once: true, passive: true });
				              document.addEventListener('click', retry, { capture: true, once: true });
				              syncBtn();
				            } else {
				              // æ— æ³•é”å®šï¼šå›é€€ä¸º offï¼Œé¿å…æŒ‰é’®è¡¨ç°ä¸å®é™…ä¸ä¸€è‡´
				              if (!silent) showToast('âš ï¸ å½“å‰ç¯å¢ƒæ— æ³•é”å®šæ—‹è½¬ï¼ˆå»ºè®®ä½¿ç”¨HTTPSæˆ–å®‰è£…PWAï¼‰');
				              setPref('off');
				              unlock();
				              syncBtn();
				            }
				          } else {
				            unlock();
				            syncBtn();
				            if (!silent) showToast('âœ… å·²å…è®¸æ—‹è½¬');
				          }
				        };

				        orientationBtn.onclick = async (e) => {
				          e.preventDefault();
				          e.stopPropagation();
				          const v = getPref();
				          const next = v === 'portrait' ? 'off' : 'portrait';
				          setPref(next);
				          await applyPref();
				        };

				        // åˆå§‹åŒ–ï¼šæŒ‰åå¥½åº”ç”¨ä¸€æ¬¡ï¼ˆå°½é‡é™é»˜ï¼Œé¿å…é¦–æ¬¡å¼¹ toastï¼‰
				        applyPref({ silent: true }).catch(() => {});
				      }

				      // å°†â€œå¤åˆ¶/ç²˜è´´â€èƒ½åŠ›ä¿ç•™ä¸ºé€»è¾‘å‡½æ•°ï¼ˆä»å·¥å…·æ ç§»é™¤æŒ‰é’®ï¼Œä½†æ‰‹åŠ¿/å¿«æ·é”®ä»å¯è§¦å‘ï¼‰
				      async function copyLastOutput() {
				        const s = getActive();
				        if (!s?.term) {
				          showToast('âŒ æ²¡æœ‰æ´»åŠ¨çš„ç»ˆç«¯ä¼šè¯');
				          return;
				        }
				        const latest =
				          (s.lastReplyText && s.lastReplyText.trim())
				            ? s.lastReplyText.trimEnd()
				            : ((s.lastReplyLine && s.lastReplyLine.trim()) ? s.lastReplyLine : getLatestNonEmptyLine(s.term));
				        const cleaned = stripTerminalControl(latest).trimEnd();
				        if (!cleaned) {
				          showToast('âš ï¸ æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹');
				          return;
				        }
				        const ok = await writeClipboard(cleaned);
				        showToast(ok ? 'âœ… å·²å¤åˆ¶æœ€åä¸€æ¬¡è¾“å‡º' : 'âŒ å¤åˆ¶å¤±è´¥ï¼ˆè¯·å…è®¸å‰ªè´´æ¿æƒé™ï¼‰');
				      }

				      async function pasteClipboard() {
				        try {
				          const text = await readClipboard();
				          if (!text) {
				            // æ— æƒé™/ä¸ºç©ºï¼šæ”¹ä¸ºå¼¹å‡ºè¾“å…¥æ¡†ï¼Œä¿è¯â€œäºŒæŒ‡é•¿æŒ‰ç²˜è´´â€æ€»æœ‰å¯ç”¨å›é€€
				            openPasteModal();
				            showToast('âš ï¸ æ— æ³•è¯»å–å‰ªè´´æ¿ï¼Œå·²æ‰“å¼€ç²˜è´´è¾“å…¥æ¡†');
				            return;
				          }
				          pasteTextToActiveTerminal(text);
				        } catch {
				          openPasteModal();
				          showToast('âš ï¸ æ— æ³•è¯»å–å‰ªè´´æ¿ï¼Œå·²æ‰“å¼€ç²˜è´´è¾“å…¥æ¡†');
				        }
				      }

					      // åœ¨ç»ˆç«¯åŒºåŸŸå¯ç”¨æ‰‹åŠ¿ï¼šç»ˆç«¯åŒºåŸŸæ»šåŠ¨ï¼›åº•éƒ¨ç©ºç™½åŒºåŸŸå•æŒ‡æ»‘åŠ¨å‘é€æ–¹å‘é”®ï¼›äºŒæŒ‡ç‚¹æŒ‰å¤åˆ¶ï¼›äºŒæŒ‡é•¿æŒ‰ç²˜è´´
					      try {
					        initTerminalGestures({
					          termArea: document.getElementById('term-area'),
					          cursorPad: document.getElementById('cursor-pad'),
					          onCopy: copyLastOutput,
					          onPaste: pasteClipboard,
					        });
					      } catch {}

				      // è®©é”®ç›˜å¿«æ·é”®ï¼ˆç§»åŠ¨ç«¯ Ctrl+Shift+C / Ctrl+Shift+Vï¼‰å¯ä»¥å¤ç”¨
				      try {
				        window.__lanShellQuickActions = { copyLastOutput, pasteClipboard };
				      } catch {}

				      // æ’¤å›ï¼šç»ˆç«¯æ²¡æœ‰é€šç”¨â€œæ’¤é”€â€ï¼Œè¿™é‡Œæä¾›æœ€å¸¸ç”¨çš„ Ctrl+Uï¼ˆæ¸…ç©ºå½“å‰è¾“å…¥è¡Œï¼‰
				      undoBtn.onclick = (e) => {
				        e.preventDefault();
				        e.stopPropagation();
				        sendToTerminal('\x15', 'âœ… å·²å‘é€æ’¤å›ï¼ˆCtrl+Uï¼‰');
				      };

			      function openDrawer() {
			        try {
			          const w = drawer.getBoundingClientRect().width || drawer.offsetWidth || 0;
			          document.documentElement.style.setProperty('--drawer-w', `${w}px`);
			        } catch {}
			        drawer.classList.add('open');
			        backdrop.classList.add('open');
			        drawer.setAttribute('aria-hidden', 'false');
			        toggleBtn.parentElement?.classList?.add('open');
			      }
		      function closeDrawer() {
		        drawer.classList.remove('open');
		        backdrop.classList.remove('open');
		        drawer.setAttribute('aria-hidden', 'true');
		        toggleBtn.parentElement?.classList?.remove('open');
		      }
		      function toggleDrawer() {
		        if (drawer.classList.contains('open')) closeDrawer();
		        else openDrawer();
		      }

			      toggleBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        toggleDrawer();
			      };
			      floatingCmdBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        if (floatingCmdBtn.__suppressClickOnce) {
			          floatingCmdBtn.__suppressClickOnce = false;
			          return;
			        }
			        try { openCommandSetsPage(); } catch {}
			      };

			      // é•¿æŒ‰â€œæŒ‡ä»¤é›†â€æŒ‰é’®ï¼šè¿›å…¥ Git é¡µé¢ï¼ˆè‹¥æœªåˆå§‹åŒ– Gitï¼Œåˆ™æç¤ºæ˜¯å¦ git initï¼‰
			      {
			        let timer = null;
			        const longPressMs = 520;
			        const start = () => {
			          try {
			            if (timer) clearTimeout(timer);
			            timer = setTimeout(() => {
			              // ç¦æ­¢åœ¨æ ¹ç›®å½•ï¼ˆ.ï¼‰/éšè—ç›®å½•æ‰“å¼€ Git ç®¡ç†é¡µ
			              try {
			                const s = getActive?.();
			                const cwd = s?.cwd || document.getElementById('path')?.value || '.';
			                const raw = String(cwd || '').trim();
			                const parts = raw.split(/[\\/]+/).filter(Boolean);
			                const hasHidden = parts.some((p) => p.startsWith('.') && p !== '.' && p !== '..');
			                if (raw === '.') {
			                  showToast('âš ï¸ æ ¹ç›®å½•ï¼ˆ.ï¼‰ç¦æ­¢æ‰“å¼€ Git ç®¡ç†é¡µ');
			                  return;
			                }
			                if (hasHidden) {
			                  showToast('âš ï¸ éšè—ç›®å½•ç¦æ­¢æ‰“å¼€ Git ç®¡ç†é¡µ');
			                  return;
			                }
			              } catch {}
			              try { floatingCmdBtn.__suppressClickOnce = true; } catch {}
			              try { window.openGitPage?.({ promptInit: true }); } catch {}
			            }, longPressMs);
			          } catch {}
			        };
			        const cancel = () => {
			          if (timer) clearTimeout(timer);
			          timer = null;
			        };
			        floatingCmdBtn.addEventListener('pointerdown', start);
			        floatingCmdBtn.addEventListener('pointerup', cancel);
			        floatingCmdBtn.addEventListener('pointercancel', cancel);
			        floatingCmdBtn.addEventListener('pointerleave', cancel);
			      }
		      closeBtn.onclick = (e) => {
		        e.preventDefault();
		        e.stopPropagation();
		        closeDrawer();
		      };
		      backdrop.onclick = closeDrawer;

		      // Keep the toggle button aligned with drawer width
		      window.addEventListener('resize', () => {
		        if (!drawer.classList.contains('open')) return;
		        try {
		          const w = drawer.getBoundingClientRect().width || drawer.offsetWidth || 0;
		          document.documentElement.style.setProperty('--drawer-w', `${w}px`);
		        } catch {}
		      });

		      // copyLastOutput / pasteClipboard å·²ä¸Šç§»ï¼šå·¥å…·æ ç§»é™¤æŒ‰é’®åä»ä¾›æ‰‹åŠ¿/å¿«æ·é”®è°ƒç”¨

			      function openPasteModal() {
			        try {
			          pasteInput.value = '';
			          pasteModalBackdrop.classList.add('open');
			          pasteModal.classList.add('open');
			          pasteModalBackdrop.setAttribute('aria-hidden', 'false');
			          pasteModal.setAttribute('aria-hidden', 'false');
			          setTimeout(() => { try { pasteInput.focus(); } catch {} }, 0);
			        } catch {}
			      }

			      function closePasteModal() {
			        try {
			          pasteModalBackdrop.classList.remove('open');
			          pasteModal.classList.remove('open');
			          pasteModalBackdrop.setAttribute('aria-hidden', 'true');
			          pasteModal.setAttribute('aria-hidden', 'true');
			        } catch {}
			      }

				      function sendPasteText(text) {
				        return pasteTextToActiveTerminal(text);
				      }

			      function sendToTerminal(data, okMsg) {
			        const s = getActive();
			        if (s?.type === 'editor') {
			          showToast('âš ï¸ å½“å‰æ˜¯ç¼–è¾‘å™¨çª—å£ï¼Œè¯·åˆ‡æ¢åˆ°ç»ˆç«¯çª—å£å†å‘é€æŒ‰é”®');
			          return;
			        }
			        if (!s?.ws || s.ws.readyState !== 1) {
			          showToast('âŒ ç»ˆç«¯æœªè¿æ¥');
			          return;
			        }
			        s.ws.send(data);
			        if (okMsg) showToast(okMsg);
			      }

			      // è§¦æ§æ‰‹åŠ¿ï¼šé€šè¿‡æ‰‹åŠ¿è§¦å‘å³ä¾§å·¥å…·æ çš„æ—¢æœ‰èƒ½åŠ›ï¼ˆä¸æ”¹åŸå¿«æ·é”®/æŒ‰é’®é€»è¾‘ï¼‰
			      function initTerminalGestures({ termArea, cursorPad, onCopy, onPaste } = {}) {
			        if (!termArea || termArea.__lanShellGesturesInstalled) return;
			        termArea.__lanShellGesturesInstalled = true;

			        const TAP_MAX_MS = 260;
			        const LONG_PRESS_MS = 520;
			        const TAP_MAX_MOVE = 12; // px
			        const AXIS_LOCK_THRESHOLD = 10; // px
			        const STEP_PX = 18; // pxï¼šæ¯ç§»åŠ¨å¤šå°‘åƒç´ å‘é€ä¸€æ¬¡æ–¹å‘é”®

			        const state = {
			          one: null,
			          multi: null,
			        };

			        function followEditorCursorSmoothly(cm, { marginLines = 1 } = {}) {
			          try {
			            if (!cm) return;
			            const info = cm.getScrollInfo?.();
			            if (!info) return;
			            const lineH = (typeof cm.defaultTextHeight === 'function' ? cm.defaultTextHeight() : 18) || 18;
			            const marginPx = Math.max(0, Number.parseInt(String(marginLines), 10) || 0) * lineH;
			            const coords = cm.cursorCoords?.(null, 'local') || cm.charCoords?.(cm.getCursor?.(), 'local');
			            if (!coords) return;

			            const topEdge = marginPx;
			            const bottomEdge = info.clientHeight - marginPx;

			            // åªåœ¨å…‰æ ‡è§¦ç¢°åˆ°å¯è§†åŒºåŸŸè¾¹ç¼˜åâ€œè·Ÿéšæ»šåŠ¨â€ï¼Œä¸”æ¯æ¬¡æœ€å¤šæ»šåŠ¨ 1 è¡Œé«˜åº¦ï¼Œé¿å…è·³è¡Œçœ©æ™•
			            if (coords.top < topEdge) {
			              const delta = Math.min(lineH, topEdge - coords.top);
			              cm.scrollTo(null, Math.max(0, info.top - delta));
			            } else if (coords.bottom > bottomEdge) {
			              const delta = Math.min(lineH, coords.bottom - bottomEdge);
			              cm.scrollTo(null, info.top + delta);
			            }
			          } catch {}
			        }

			        // ç¼–è¾‘å™¨æ–¹å‘ç§»åŠ¨â€œèŠ‚æµ/åˆ†å¸§â€ï¼š
			        // è§¦æ§æ¿ä¸€æ¬¡æ»‘åŠ¨å¯èƒ½äº§ç”Ÿå¤§é‡ stepsï¼Œå¦‚æœåŒæ­¥å¾ªç¯æ‰§è¡Œï¼Œä¼šå‡ºç°â€œå…‰æ ‡è·‘å‡ºå±å¹•åæ‰çªç„¶è·³å›â€çš„è§‚æ„Ÿã€‚
			        // è¿™é‡ŒæŠŠç¼–è¾‘å™¨çš„æ–¹å‘ç§»åŠ¨æ‹†åˆ°å¤šå¸§é‡Œæ‰§è¡Œï¼Œè®©æ»šåŠ¨èƒ½æŒç»­è·Ÿä¸Šå…‰æ ‡ã€‚
			        const editorArrowQueue = {
			          esc: null,
			          remaining: 0,
			          raf: 0,
			        };

			        function pumpEditorArrowQueue() {
			          try {
			            editorArrowQueue.raf = 0;
			            const s = getActive();
			            if (!s || s.type !== 'editor' || !s.cm) {
			              editorArrowQueue.remaining = 0;
			              return;
			            }
			            const cm = s.cm;
			            const map = {
			              '\x1b[A': 'goLineUp',
			              '\x1b[B': 'goLineDown',
			              '\x1b[C': 'goCharRight',
			              '\x1b[D': 'goCharLeft',
			            };
			            const cmd = map[editorArrowQueue.esc];
			            if (!cmd) {
			              editorArrowQueue.remaining = 0;
			              return;
			            }

			            // æ¯å¸§æœ€å¤šç§»åŠ¨ N æ¬¡ï¼Œå…¼é¡¾â€œè·Ÿæ‰‹â€ä¸â€œå¹³æ»‘â€
			            const PER_FRAME = 3;
			            const n = Math.min(PER_FRAME, editorArrowQueue.remaining);
			            for (let i = 0; i < n; i += 1) {
			              try { cm.execCommand(cmd); } catch {}
			            }
			            editorArrowQueue.remaining -= n;
			            followEditorCursorSmoothly(cm, { marginLines: 1 });
			            try { cm.focus(); } catch {}

			            if (editorArrowQueue.remaining > 0) {
			              editorArrowQueue.raf = requestAnimationFrame(pumpEditorArrowQueue);
			            }
			          } catch {}
			        }

			        function enqueueEditorArrow(esc, steps) {
			          try {
			            if (!steps) return;
			            // å¦‚æœæ–¹å‘å˜äº†ï¼Œé‡ç½®é˜Ÿåˆ—ï¼ˆé¿å…â€œå…ˆä¸Šåä¸‹â€ç´¯è®¡åå»¶è¿Ÿæ‰§è¡Œï¼‰
			            if (editorArrowQueue.esc && editorArrowQueue.esc !== esc) editorArrowQueue.remaining = 0;
			            editorArrowQueue.esc = esc;
			            editorArrowQueue.remaining = Math.min(120, editorArrowQueue.remaining + Math.abs(steps));
			            if (!editorArrowQueue.raf) editorArrowQueue.raf = requestAnimationFrame(pumpEditorArrowQueue);
			          } catch {}
			        }

			        function sendArrowSilent(esc) {
			          const s = getActive();
			          if (!s) return false;

			          // ç¼–è¾‘å™¨ï¼šæŠŠæ–¹å‘é”®æ˜ å°„ä¸º CodeMirror å…‰æ ‡ç§»åŠ¨ï¼Œå¹¶è‡ªåŠ¨æ»šåŠ¨åˆ°å…‰æ ‡
			          if (s.type === 'editor') {
			            const cm = s.cm;
			            if (!cm) return false;
			            const map = {
			              '\x1b[A': 'goLineUp',
			              '\x1b[B': 'goLineDown',
			              '\x1b[C': 'goCharRight',
			              '\x1b[D': 'goCharLeft',
			            };
			            const cmd = map[esc];
			            if (!cmd) return false;
			            try {
			              cm.execCommand(cmd);
			              followEditorCursorSmoothly(cm, { marginLines: 1 });
			              cm.focus();
			            } catch {}
			            return true;
			          }

			          // ç»ˆç«¯ï¼šå‘é€çœŸå®æ–¹å‘é”®åºåˆ—
			          if (s.type === 'term') {
			            if (!s.ws || s.ws.readyState !== 1) {
			              showToast('âŒ ç»ˆç«¯æœªè¿æ¥');
			              return false;
			            }
			            try { s.ws.send(esc); } catch { return false; }
			            return true;
			          }

			          return false;
			        }

			        function fireCopyIfTerminal() {
			          const s = getActive();
			          if (s?.type !== 'term') return;
			          try { onCopy?.(); } catch {}
			        }

			        function firePasteIfTerminal() {
			          const s = getActive();
			          if (s?.type !== 'term') return;
			          try { onPaste?.(); } catch {}
			        }

			        function dist(x1, y1, x2, y2) {
			          const dx = x2 - x1;
			          const dy = y2 - y1;
			          return Math.hypot(dx, dy);
			        }

			        function startOneFinger(t) {
			          state.one = {
			            active: true,
			            startX: t.clientX,
			            startY: t.clientY,
			            lastX: t.clientX,
			            lastY: t.clientY,
			            totalX: 0,
			            totalY: 0,
			            axis: null, // 'x' | 'y'
			            accum: 0,
			          };
			          state.multi = null;
			        }

			        function startMultiFinger(e) {
			          const touches = Array.from(e.touches || []);
			          const count = touches.length;
			          const startMap = new Map();
			          for (const t of touches) startMap.set(t.identifier, { x: t.clientX, y: t.clientY });
			          state.multi = {
			            active: true,
			            count,
			            startTs: Date.now(),
			            startMap,
			            maxMove: 0,
			            endedCount: 0,
			            longPressTimer: null,
			            longPressFired: false,
			            cancelled: false,
			          };
			          state.one = null;

			          // äºŒæŒ‡é•¿æŒ‰ï¼šç²˜è´´ï¼ˆç­‰ä»·ç‚¹å‡»å³ä¾§ PASTEï¼‰
			          if (count === 2) {
			            try {
			              state.multi.longPressTimer = setTimeout(() => {
			                const m = state.multi;
			                if (!m?.active || m.longPressFired) return;
			                if (m.cancelled) return;
			                if (m.maxMove > TAP_MAX_MOVE) return;
			                m.longPressFired = true;
			                // é•¿æŒ‰å·²è§¦å‘ï¼šä¸å†å°†å…¶åˆ¤å®šä¸ºâ€œäºŒæŒ‡ç‚¹æŒ‰å¤åˆ¶â€
			                m.cancelled = true;
			                firePasteIfTerminal();
			              }, LONG_PRESS_MS);
			            } catch {}
			          }
			        }

			        function cancelMultiLongPressTimer() {
			          const m = state.multi;
			          if (!m) return;
			          if (m.longPressTimer) {
			            try { clearTimeout(m.longPressTimer); } catch {}
			            m.longPressTimer = null;
			          }
			        }

			        function updateMultiFingerByTouches(m, touches) {
			          for (const t of Array.from(touches || [])) {
			            const s = m.startMap.get(t.identifier);
			            if (!s) continue;
			            m.maxMove = Math.max(m.maxMove, dist(s.x, s.y, t.clientX, t.clientY));
			          }
			          if (m.maxMove > TAP_MAX_MOVE) m.cancelled = true;
			        }

			        function updateMultiFinger(e) {
			          const m = state.multi;
			          if (!m?.active) return;
			          if ((e.touches?.length || 0) !== m.count) {
			            m.cancelled = true;
			            cancelMultiLongPressTimer();
			            return;
			          }
			          updateMultiFingerByTouches(m, e.touches);
			          if (m.maxMove > TAP_MAX_MOVE) cancelMultiLongPressTimer();
			        }

			        function tryFireMultiTapIfDone({ force = false } = {}) {
			          const m = state.multi;
			          if (!m?.active) return;
			          cancelMultiLongPressTimer();
			          if (!force && m.endedCount < m.count) return;
			          const elapsed = Date.now() - m.startTs;
			          const ok = !m.cancelled && elapsed <= TAP_MAX_MS && m.maxMove <= TAP_MAX_MOVE;
			          const count = m.count;
			          state.multi = null;
			          if (!ok) return;
			          if (count === 2) {
			            fireCopyIfTerminal();
			          }
			        }

			        function handleOneFingerMove(e) {
			          const o = state.one;
			          if (!o?.active) return;
			          if ((e.touches?.length || 0) !== 1) return;

			          // å•æŒ‡ç§»åŠ¨ï¼šä»…åœ¨åº•éƒ¨â€œç©ºç™½è§¦æ§æ¿â€åŒºåŸŸå¯ç”¨ï¼Œé˜»æ­¢æ»šåŠ¨ï¼ŒæŠŠè§¦æ§å½“ä½œâ€œè§¦æ§æ¿/æ–¹å‘é”®â€
			          try { e.preventDefault(); } catch {}

			          const t = e.touches[0];
			          const dx = t.clientX - o.lastX;
			          const dy = t.clientY - o.lastY;
			          o.lastX = t.clientX;
			          o.lastY = t.clientY;

			          o.totalX = t.clientX - o.startX;
			          o.totalY = t.clientY - o.startY;

			          if (!o.axis) {
			            const ax = Math.abs(o.totalX);
			            const ay = Math.abs(o.totalY);
			            if (ax >= AXIS_LOCK_THRESHOLD || ay >= AXIS_LOCK_THRESHOLD) {
			              o.axis = ax >= ay ? 'x' : 'y';
			            }
			          }

			          if (!o.axis) return;

			          if (o.axis === 'x') {
			            o.accum += dx;
			            const steps = Math.trunc(o.accum / STEP_PX);
			            if (!steps) return;
			            o.accum -= steps * STEP_PX;
			            const key = steps > 0 ? '\x1b[C' : '\x1b[D';
			            const s = getActive();
			            if (s?.type === 'editor') enqueueEditorArrow(key, steps);
			            else for (let i = 0; i < Math.abs(steps); i += 1) sendArrowSilent(key);
			          } else {
			            o.accum += dy;
			            const steps = Math.trunc(o.accum / STEP_PX);
			            if (!steps) return;
			            o.accum -= steps * STEP_PX;
			            const key = steps > 0 ? '\x1b[B' : '\x1b[A';
			            const s = getActive();
			            if (s?.type === 'editor') enqueueEditorArrow(key, steps);
			            else for (let i = 0; i < Math.abs(steps); i += 1) sendArrowSilent(key);
			          }
			        }

			        // å¤šæŒ‡æ‰‹åŠ¿ä¾ç„¶åœ¨ç»ˆç«¯åŒºåŸŸè§¦å‘ï¼ˆä¸å¹²é¢„æ»šåŠ¨ï¼‰
			        termArea.addEventListener(
			          'touchstart',
			          (e) => {
			            const n = e.touches?.length || 0;
			            if (n === 2 || n === 3) startMultiFinger(e);
			            else {
			              state.multi = null;
			            }
			          },
			          { passive: true, capture: true }
			        );

			        termArea.addEventListener(
			          'touchmove',
			          (e) => {
			            if (state.multi?.active) {
			              updateMultiFinger(e);
			              return; // åŒæŒ‡æ»šåŠ¨/ä¸‰æŒ‡æ»‘åŠ¨ï¼šä¸å¹²é¢„
			            }
			          },
			          { passive: false, capture: true }
			        );

			        termArea.addEventListener(
			          'touchend',
			          (e) => {
			            if (state.multi?.active) {
			              // æ³¨æ„ï¼šå¤šæŒ‡ç‚¹æŒ‰ä¼šåˆ†å¤šæ¬¡è§¦å‘ touchendï¼ˆå…ˆæŠ¬èµ·ä¸€æ ¹ï¼Œå†æŠ¬èµ·å¦ä¸€æ ¹ï¼‰ï¼Œä¸èƒ½åœ¨ä¸­é€”ç›´æ¥å–æ¶ˆã€‚
			              state.multi.endedCount += (e.changedTouches?.length || 0);
			              // è®°å½•æ¾å¼€ç¬é—´çš„ä½ç½®ï¼ˆéƒ¨åˆ†æµè§ˆå™¨ touchmove ä¸ä¸€å®šè¦†ç›–åˆ°ï¼‰
			              updateMultiFingerByTouches(state.multi, e.changedTouches);
			              // äºŒæŒ‡é•¿æŒ‰å·²ç»è§¦å‘æ—¶ï¼Œä¸å†å°è¯•ç‚¹æŒ‰åˆ¤å®š
			              if (state.multi.longPressFired) {
			                cancelMultiLongPressTimer();
			                if ((e.touches?.length || 0) === 0) state.multi = null;
			              } else {
			              tryFireMultiTapIfDone({ force: (e.touches?.length || 0) === 0 });
			              }
			            }
			          },
			          { passive: true, capture: true }
			        );

			        termArea.addEventListener(
			          'touchcancel',
			          () => {
			            cancelMultiLongPressTimer();
			            state.multi = null;
			          },
			          { passive: true, capture: true }
			        );

			        // å•æŒ‡ç§»åŠ¨å…‰æ ‡ï¼šåªåœ¨åº•éƒ¨ç©ºç™½åŒºåŸŸå¯ç”¨ï¼›è‹¥æ²¡æœ‰ cursorPadï¼Œåˆ™å›é€€åˆ° termAreaï¼ˆå…¼å®¹æ—§å¸ƒå±€ï¼‰
			        const pad = cursorPad || termArea;
			        pad.addEventListener(
			          'touchstart',
			          (e) => {
			            const n = e.touches?.length || 0;
			            if (n === 1) startOneFinger(e.touches[0]);
			            else state.one = null;
			          },
			          { passive: true, capture: true }
			        );
			        pad.addEventListener(
			          'touchmove',
			          (e) => {
			            if (state.one?.active) handleOneFingerMove(e);
			          },
			          { passive: false, capture: true }
			        );
			        pad.addEventListener(
			          'touchend',
			          (e) => {
			            if ((e.touches?.length || 0) === 0) state.one = null;
			          },
			          { passive: true, capture: true }
			        );
			        pad.addEventListener(
			          'touchcancel',
			          () => {
			            state.one = null;
			          },
			          { passive: true, capture: true }
			        );
			      }

			      // Ctrl / Alt ç»„åˆé”®ä¸€æ¬¡æ€§å¼€å…³
			      let pendingCtrl = false;
			      let pendingAlt = false;
			      let pendingShift = false;

			      function resetModifiers() {
			        pendingCtrl = false;
			        pendingAlt = false;
			        pendingShift = false;
			        // ç§»é™¤æ—§çš„å·¥å…·æ çŠ¶æ€ï¼ˆå·²åˆ é™¤ï¼‰
			        try { document.getElementById('comboCtrlBtn')?.classList?.remove('active'); } catch {}
			        try { document.getElementById('comboAltBtn')?.classList?.remove('active'); } catch {}
			        try { document.getElementById('comboShiftBtn')?.classList?.remove('active'); } catch {}
			      }

			      function sendCtrlCombo(ch) {
			        const key = String(ch || '').toUpperCase();
			        if (!key || key.length !== 1) return false;
			        const code = key.charCodeAt(0);
			        // A-Z -> ctrl: code & 0x1f
			        if (code < 64 || code > 90) return false;
			        const ctrlChar = String.fromCharCode(code & 0x1f);
			        const s = getActive();
			        if (!s?.ws || s.ws.readyState !== 1) {
			          showToast('âŒ ç»ˆç«¯æœªè¿æ¥');
			          return false;
			        }
			        // Alt åŒæ—¶æŒ‰ä¸‹ï¼šESC å‰ç¼€
			        const payload = pendingAlt ? `\x1b${ctrlChar}` : ctrlChar;
			        s.ws.send(payload);
			        showToast(pendingAlt ? `âœ… å‘é€ Alt+Ctrl+${key}` : `âœ… å‘é€ Ctrl+${key}`);
			        resetModifiers();
			        return true;
			      }

			      function sendAltCombo(ch) {
			        const key = String(ch || '');
			        if (!key || key.length !== 1) return false;
			        const s = getActive();
			        if (!s?.ws || s.ws.readyState !== 1) {
			          showToast('âŒ ç»ˆç«¯æœªè¿æ¥');
			          return false;
			        }
			        s.ws.send(`\x1b${key}`);
			        showToast(`âœ… å‘é€ Alt+${key}`);
			        resetModifiers();
			        return true;
			      }

			      function handleModifierKeydown(e) {
			        // å¼¹å‡ºå¼ç»„åˆé”®æ¨¡å¼ä¸‹ä¸æ‹¦æˆªè¾“å…¥æ¡†çš„æŒ‰é”®
			        if (comboModal?.classList?.contains('open')) return;
			        if (!pendingCtrl && !pendingAlt) return;
			        // å¿½ç•¥åŠŸèƒ½é”®
			        if (e.key && e.key.length === 1) {
			          e.preventDefault();
			          e.stopPropagation();
			          const k = e.key;
			          if (pendingCtrl) {
			            const ok = sendCtrlCombo(k);
			            if (!ok && pendingAlt) sendAltCombo(k); // å›é€€ä¸º alt+key
			            else if (!ok) resetModifiers();
			          } else if (pendingAlt) {
			            sendAltCombo(k);
			          }
			        }
			        // ä»»ä½•æŒ‰é”®éƒ½æ¸…ç†çŠ¶æ€ï¼Œé¿å…å¡ä½
			        resetModifiers();
			      }

			      // ç»„åˆé”®å¼¹çª—é€»è¾‘
			      const comboBackdrop = document.getElementById('combo-modal-backdrop');
			      const comboModal = document.getElementById('combo-modal');
			      const comboCtrlBtn = document.getElementById('comboCtrlBtn');
			      const comboAltBtn = document.getElementById('comboAltBtn');
			      const comboShiftBtn = document.getElementById('comboShiftBtn');
			      const comboInput = document.getElementById('combo-input');
			      const comboCloseBtn = document.getElementById('comboModalCloseBtn');
			      const comboCancelBtn = document.getElementById('comboModalCancelBtn');
			      const comboOkBtn = document.getElementById('comboModalOkBtn');

			      function toggleCombo(btn, flagKey) {
			        btn.classList.toggle('active');
			        if (flagKey === 'ctrl') pendingCtrl = btn.classList.contains('active');
			        if (flagKey === 'alt') pendingAlt = btn.classList.contains('active');
			        if (flagKey === 'shift') pendingShift = btn.classList.contains('active');
			      }

			      function openComboModal() {
			        comboBackdrop.classList.add('open');
			        comboModal.classList.add('open');
			        comboBackdrop.setAttribute('aria-hidden', 'false');
			        comboModal.setAttribute('aria-hidden', 'false');
			        setTimeout(() => { try { comboInput.focus(); } catch {} }, 0);
			      }
			      function closeComboModal() {
			        comboBackdrop.classList.remove('open');
			        comboModal.classList.remove('open');
			        comboBackdrop.setAttribute('aria-hidden', 'true');
			        comboModal.setAttribute('aria-hidden', 'true');
			        resetModifiers();
			        comboInput.value = '';
			      }

			      function buildComboPayload(text) {
			        const chars = String(text || '').split('');
			        if (!chars.length) {
			          showToast('âš ï¸ è¯·è¾“å…¥è¦å‘é€çš„å­—ç¬¦');
			          return null;
			        }
			        let payload = '';
			        for (const ch of chars) {
			          let c = ch;
			          const upper = c.toUpperCase();
			          if (pendingCtrl) {
			            const code = upper.charCodeAt(0);
			            if (code >= 64 && code <= 95) {
			              c = String.fromCharCode(code & 0x1f);
			            }
			          } else if (pendingShift) {
			            c = upper;
			          }
			          if (pendingAlt) {
			            payload += `\x1b${c}`;
			          } else {
			            payload += c;
			          }
			        }
			        return payload;
			      }

			      function sendComboFromModal() {
			        const payload = buildComboPayload(comboInput.value);
			        if (!payload) return;
			        try {
			          const s = getActive();
			          s.ws.send(payload);
			          const mods = [
			            pendingCtrl ? 'Ctrl' : null,
			            pendingAlt ? 'Alt' : null,
			            pendingShift ? 'Shift' : null,
			          ].filter(Boolean).join('+');
			          showToast(`âœ… å·²å‘é€ ${mods ? mods + '+' : ''}${comboInput.value}`);
			        } catch {
			          showToast('âŒ å‘é€å¤±è´¥');
			        }
			        closeComboModal();
			      }

			      comboBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); openComboModal(); };
			      comboCloseBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeComboModal(); };
			      comboCancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeComboModal(); };
			      comboOkBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); sendComboFromModal(); };
			      comboCtrlBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); toggleCombo(comboCtrlBtn, 'ctrl'); };
			      comboAltBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); toggleCombo(comboAltBtn, 'alt'); };
			      comboShiftBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); toggleCombo(comboShiftBtn, 'shift'); };

			      comboInput.addEventListener('keydown', (e) => {
			        if (e.key === 'Escape') {
			          e.preventDefault(); closeComboModal(); return;
			        }
			        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
			          e.preventDefault();
			          sendComboFromModal();
			        }
			      });
			      // removed: COPY/PASTE/UP/DOWN buttons in toolbar
				      tabBtn.onclick = (e) => {
				        e.preventDefault();
				        e.stopPropagation();
				        sendToTerminal('\t', 'âœ… TAB');
				      };
				      enterBtn.onclick = (e) => {
				        e.preventDefault();
				        e.stopPropagation();
				        sendToTerminal('\r', 'âœ… ENTER');
				      };
			      escBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        sendToTerminal('\x1b', 'âœ… å·²å‘é€ ESC');
			      };
			      ctrlCBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        sendToTerminal('\x03', 'âœ… å·²å‘é€ Ctrl+C');
			      };

			      continueBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const s = getActive();
			        if (!s?.ws || s.ws.readyState !== 1) {
		          showToast('âŒ ç»ˆç«¯æœªè¿æ¥');
		          return;
		        }
		        // Macro: ESC -> "continue" -> Enter
		        // IMPORTANT: avoid sending ESC immediately followed by "c" (ESC c == RIS reset in many terminals),
		        // which can swallow the "c" and make it look like "ontinue".
		        s.ws.send('\x1b');
		        setTimeout(() => {
		          try { s.ws.send('continue'); } catch {}
		          setTimeout(() => {
		            try { s.ws.send('\r'); } catch {}
		          }, 30);
		        }, 80);
			        showToast('âœ… CONT');
			      };

			      // æ•è·é˜¶æ®µä¼˜å…ˆæˆªè·ï¼Œé˜²æ­¢æŒ‰é”®å…ˆè¢« xterm åƒæ‰ï¼ˆå°¤å…¶ç§»åŠ¨ç«¯ï¼‰
			      document.addEventListener('keydown', (e) => {
			        if (e.key === 'Escape' && drawer.classList.contains('open')) {
			          closeDrawer();
			          return;
			        }
			        handleModifierKeydown(e);
			      }, true);

			      // removed: PASTE button long-press (use two-finger long-press or fallback modal)

			      pasteModalBackdrop.onclick = closePasteModal;
			      pasteModalCloseBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closePasteModal(); };
			      pasteModalCancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closePasteModal(); };
			      pasteModalOkBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const ok = sendPasteText(pasteInput.value);
			        if (ok) closePasteModal();
			      };
			      pasteInput.addEventListener('keydown', (e) => {
			        if (e.key === 'Escape') {
			          e.preventDefault();
			          closePasteModal();
			          return;
			        }
			        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
			          e.preventDefault();
			          const ok = sendPasteText(pasteInput.value);
			          if (ok) closePasteModal();
			        }
			      });
			    }

				    function removeTerminal(id) {
		      const idx = sessions.findIndex(s => s.id === id);
		      if (idx === -1) return;
		      const s = sessions[idx];
		      if (s.ws) { s.suppressClose = true; s.ws.close(); }
		      s.inputDisposable?.dispose();
		      s.resizeListener?.dispose();
		      s.resizeObserver?.disconnect();
		      try { if (s._termFlushTimer) clearTimeout(s._termFlushTimer); } catch {}
	      s.term.dispose();
	      s.pane.remove();
	      s.tab.remove();
	      sessions.splice(idx,1);
		      if (activeId === id) {
		        if (sessions.length) setActive(sessions[0].id);
		        else activeId = null;
		      }
		    }

	    // Close terminal: delete the unique session id so it won't be restored.
		    function closeTerminal(id) {
		      const s = sessions.find(s => s.id === id);
		      if (!s) return;

		      if (s.sessionId) {
		        fetch(
		          `/api/sessions/${encodeURIComponent(s.sessionId)}?clientId=${encodeURIComponent(clientId)}&token=${encodeURIComponent(authToken)}`,
		          { method: 'DELETE' }
		        ).catch(() => {});
		      }

		      removeTerminal(id);
		    }

    document.getElementById('load').onclick = () => {
      const p = document.getElementById('path').value;
      loadDir(p);
    };
    document.getElementById('newTerm').onclick = () => {
      const p = document.getElementById('path').value;
      createTerminal(p);
    };

    // åˆå§‹åŒ–ï¼šå°è¯•æ¢å¤ç°æœ‰ä¼šè¯æˆ–åˆ›å»ºæ–°ä¼šè¯
	    async function initializeTerminals() {
	      const existingSessions = await loadExistingSessions();

	      if (existingSessions.length > 0) {
	        // Restore ALL sessions that still exist on the server for this clientId.
	        const sorted = existingSessions
	          .slice()
	          .sort((a, b) => new Date(a.created || 0) - new Date(b.created || 0))
	          .slice(-50); // safety cap

	        console.log('æ¢å¤ç°æœ‰ä¼šè¯æ•°é‡:', sorted.length);
	        const restored = sorted.map(s => createTerminal(s?.cwd || '.', null, s.id));

	        // Focus the most recently active session (fallback: first).
	        const focusId =
	          sorted
	            .slice()
	            .sort((a, b) => new Date(b.lastActivity || 0) - new Date(a.lastActivity || 0))[0]?.id || restored[0]?.id;
	        if (focusId) setActive(focusId);
	        return;
	      }

	      // No existing sessions: create a new one.
	      console.log('åˆ›å»ºæ–°ç»ˆç«¯ä¼šè¯');
	      const created = createTerminal('.');
	      setActive(created.id);
	    }

	    let hasInitialized = false;
	    function initializeOnce() {
      if (hasInitialized) return;
      hasInitialized = true;

      console.log('å¼€å§‹åˆå§‹åŒ–...');

      // æ£€æµ‹Edgeå¹¶åº”ç”¨ä¸“ç”¨æ ·å¼
      if (/Edg/i.test(navigator.userAgent)) {
        console.log('æ£€æµ‹åˆ°Edgeæµè§ˆå™¨');
        applyEdgePWAStyles();
      }

      // åº”ç”¨PWAæ ·å¼
      applyPWAStyles();

      // å¼ºåˆ¶ç§»åŠ¨ç«¯å…¨å±
      forceMobileFullscreen();

      // å¦‚æœæ˜¯PWAæ¨¡å¼ï¼Œéšè—åœ°å€æ 
      if (isPWA()) {
        console.log('PWAæ¨¡å¼å·²æ¿€æ´»');
        hideAddressBar();
      }

	      // å¯åŠ¨å•è®¾å¤‡tokenç®¡ç†
	      if (authToken) {
	        startSingleDeviceTokenManagement();
	        console.log('âœ… å•è®¾å¤‡Tokenç®¡ç†å·²å¯åŠ¨');
	      }

      // åˆå§‹åŒ–æŒ‡ä»¤é›†é¡µé¢
      initCommandSets();

      // åˆå§‹åŒ– Git é¡µé¢
      initGitPage();

      // åˆå§‹åŒ–æ–‡ä»¶æ–°å»º/ä¸Šä¼ 
      installFileModal();
      // åˆå§‹åŒ–è§£å‹å¼¹çª—
      installExtractModal();
      // åˆå§‹åŒ–â€œæ˜¾ç¤ºéšè—æ–‡ä»¶â€å¼€å…³
      installHiddenToggle();

      initSideActions();
      loadDir('.');
      initializeTerminals();
    }

    // é¡µé¢åˆå§‹åŒ–ï¼ˆç¡®ä¿åªæ‰§è¡Œä¸€æ¬¡ï¼Œé¿å…é‡å¤åˆ›å»ºç»ˆç«¯ä¼šè¯ï¼‰
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded');
      initializeOnce();
    });

    if (document.readyState !== 'loading') {
      console.log('DOMå·²å°±ç»ªï¼ˆreadyStateï¼‰');
      initializeOnce();
    }

    // å•è®¾å¤‡Tokenç®¡ç†åŠŸèƒ½ - ä¸¥æ ¼æ¨¡å¼
    let activityRefreshInterval;
    let sseConnection = null;
    
    // TokenæŒä¹…åŒ–ç®¡ç†
    const TOKEN_STORAGE_KEY = 'lanshell_auth_token';
    const TOKEN_EXPIRY_KEY = 'lanshell_token_expiry';
    
    // æ¸…é™¤ä¿å­˜çš„token
    function clearSavedToken() {
      try {
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        localStorage.removeItem(TOKEN_EXPIRY_KEY);
        console.log('ğŸ—‘ï¸ å·²æ¸…é™¤ä¿å­˜çš„token');
      } catch (error) {
        console.error('æ¸…é™¤tokenå¤±è´¥:', error);
      }
    }
    
    // å¼ºåˆ¶ç™»å‡ºå¤„ç†
    function handleForceLogout(reason, message) {
      console.log(`ğŸš¨ æ”¶åˆ°å¼ºåˆ¶ç™»å‡ºé€šçŸ¥: ${reason}`);
      
      // æ¸…é™¤æœ¬åœ°token
      clearSavedToken();
      
      // åœæ­¢æ‰€æœ‰æ´»åŠ¨
      stopTokenManagement();
      
      // å…³é—­SSEè¿æ¥
      if (sseConnection) {
        sseConnection.close();
        sseConnection = null;
      }
      
      // æ˜¾ç¤ºé€šçŸ¥
      showToast(`ğŸš¨ ${message || 'æ‚¨å·²è¢«å¼ºåˆ¶ç™»å‡º'}`);
      
      // å»¶è¿Ÿè·³è½¬åˆ°ç™»å½•é¡µé¢
      setTimeout(() => {
        window.location.href = '/';
      }, 3000);
    }
    
    // å»ºç«‹SSEè¿æ¥ç›‘å¬å¼ºåˆ¶ç™»å‡º
    function establishSSEConnection() {
      if (!authToken) return;
      
      try {
        console.log('ğŸ“¡ å»ºç«‹SSEè¿æ¥ç›‘å¬å¼ºåˆ¶ç™»å‡º...');
        sseConnection = new EventSource(`/api/events?token=${encodeURIComponent(authToken)}`);
        
        sseConnection.onopen = function(event) {
          console.log('âœ… SSEè¿æ¥å·²å»ºç«‹');
        };
        
        sseConnection.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            console.log('ğŸ“¡ æ”¶åˆ°SSEæ¶ˆæ¯:', data);
            
            switch (data.type) {
              case 'connected':
                console.log(`ğŸ“¡ SSEè¿æ¥ç¡®è®¤: ${data.connectionId}`);
                break;
                
              case 'heartbeat':
                // å¿ƒè·³æ¶ˆæ¯ï¼Œä¿æŒè¿æ¥æ´»è·ƒ
                break;
                
              case 'force_logout':
                console.log('ğŸš¨ æ”¶åˆ°å¼ºåˆ¶ç™»å‡ºæŒ‡ä»¤');
                handleForceLogout(data.reason, data.message);
                break;
                
              default:
                console.log('ğŸ“¡ æœªçŸ¥SSEæ¶ˆæ¯ç±»å‹:', data.type);
            }
          } catch (error) {
            console.error('è§£æSSEæ¶ˆæ¯å¤±è´¥:', error);
          }
        };
        
        sseConnection.onerror = function(event) {
          console.error('âŒ SSEè¿æ¥é”™è¯¯:', event);
          
          // é‡è¿é€»è¾‘
          setTimeout(() => {
            if (authToken && !sseConnection) {
              console.log('ğŸ”„ å°è¯•é‡æ–°å»ºç«‹SSEè¿æ¥...');
              establishSSEConnection();
            }
          }, 5000);
        };
        
        sseConnection.onclose = function(event) {
          console.log('ğŸ“¡ SSEè¿æ¥å·²å…³é—­');
          sseConnection = null;
        };
        
      } catch (error) {
        console.error('å»ºç«‹SSEè¿æ¥å¤±è´¥:', error);
      }
    }
    
    // å®‰å…¨ç™»å‡ºåŠŸèƒ½
    function secureLogout() {
      if (confirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿè¿™å°†ç»“æŸæ‰€æœ‰è®¾å¤‡ä¸Šçš„ä¼šè¯ã€‚')) {
        // æ¸…é™¤æœ¬åœ°ä¿å­˜çš„token
        clearSavedToken();
        
        // å…³é—­SSEè¿æ¥
        if (sseConnection) {
          sseConnection.close();
          sseConnection = null;
        }
        
        // é€šçŸ¥æœåŠ¡å™¨ç™»å‡º
        fetch(`/api/logout?token=${encodeURIComponent(authToken)}`, {
          method: 'POST'
        }).then(() => {
          console.log('âœ… å·²å®‰å…¨ç™»å‡º');
        }).catch(error => {
          console.error('ç™»å‡ºè¯·æ±‚å¤±è´¥:', error);
        }).finally(() => {
          // è·³è½¬åˆ°ç™»å½•é¡µé¢
          window.location.href = '/';
        });
      }
    }
    
    function startSingleDeviceTokenManagement() {
      // å»ºç«‹SSEè¿æ¥ç›‘å¬å¼ºåˆ¶ç™»å‡º
      establishSSEConnection();
      
      // æ¯10åˆ†é’Ÿåˆ·æ–°ä¸€æ¬¡æ´»è·ƒçŠ¶æ€ï¼ˆæ›´å®½æ¾ï¼‰
      activityRefreshInterval = setInterval(async () => {
        try {
          const response = await fetch(`/api/refresh-activity?token=${encodeURIComponent(authToken)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (!response.ok) {
            console.log('âš ï¸ å®šæ—¶Tokenåˆ·æ–°å¤±è´¥ï¼Œä½†ä¸å¼ºåˆ¶é€€å‡º');
            // ä¸å¼ºåˆ¶é€€å‡ºï¼Œè®©ç”¨æˆ·ç»§ç»­ä½¿ç”¨
            // åªæœ‰åœ¨çœŸæ­£éœ€è¦è®¤è¯çš„æ“ä½œæ—¶æ‰ä¼šæç¤ºé‡æ–°ç™»å½•
          } else {
            console.log('âœ… å®šæ—¶æ´»è·ƒçŠ¶æ€å·²åˆ·æ–°');
          }
        } catch (error) {
          console.error('âš ï¸ å®šæ—¶æ´»è·ƒçŠ¶æ€åˆ·æ–°å¤±è´¥ï¼ˆå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜ï¼‰:', error);
          // ç½‘ç»œé”™è¯¯ä¸åº”è¯¥å¯¼è‡´å¼ºåˆ¶é€€å‡º
        }
      }, 10 * 60 * 1000); // 10åˆ†é’Ÿåˆ·æ–°ä¸€æ¬¡
    }
    
    function stopTokenManagement() {
      if (activityRefreshInterval) {
        clearInterval(activityRefreshInterval);
        activityRefreshInterval = null;
      }
      
      if (sseConnection) {
        sseConnection.close();
        sseConnection = null;
      }
    }

    // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶çš„å¤„ç† - å•è®¾å¤‡ç®€åŒ–ç‰ˆ
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // é¡µé¢å˜ä¸ºå¯è§æ—¶
        console.log('ğŸ“± é¡µé¢å˜ä¸ºå¯è§ï¼Œå¼€å§‹éªŒè¯token');
        if (isPWA()) {
          setTimeout(hideAddressBar, 100);
        }
        
        // åˆ·æ–°æ´»è·ƒçŠ¶æ€ï¼ˆé™é»˜å¤„ç†ï¼Œä¸å¼ºåˆ¶è·³è½¬ï¼‰
        if (authToken) {
          console.log(`ğŸ” å‘é€æ´»è·ƒçŠ¶æ€åˆ·æ–°è¯·æ±‚ï¼Œtoken: ${authToken ? authToken.substring(0, 8) + '...' : 'null'}`);
          fetch(`/api/refresh-activity?token=${encodeURIComponent(authToken)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
          .then(response => {
            console.log(`ğŸ“¡ æ´»è·ƒçŠ¶æ€åˆ·æ–°å“åº”: ${response.status}`);
            if (!response.ok) {
              console.log('âš ï¸ TokenéªŒè¯å¤±è´¥ï¼Œä½†ä¸å¼ºåˆ¶é€€å‡ºï¼ˆå¯èƒ½æ˜¯çŸ­æš‚çš„ç½‘ç»œé—®é¢˜ï¼‰');
              // ä¸ç«‹å³è·³è½¬ï¼Œç»™ç”¨æˆ·ç»§ç»­ä½¿ç”¨çš„æœºä¼š
              // åªåœ¨çœŸæ­£éœ€è¦è®¤è¯çš„æ“ä½œæ—¶æ‰ä¼šå¤±è´¥
            } else {
              console.log('âœ… åˆ‡å±å›æ¥ï¼Œæ´»è·ƒçŠ¶æ€å·²åˆ·æ–°');
              return response.json();
            }
          })
          .then(data => {
            if (data) {
              console.log('ğŸ“Š æ´»è·ƒçŠ¶æ€åˆ·æ–°ç»“æœ:', data);
            }
          })
          .catch(error => {
            console.error('âš ï¸ æ´»è·ƒçŠ¶æ€åˆ·æ–°å¤±è´¥ï¼ˆç½‘ç»œé—®é¢˜ï¼‰ï¼Œç»§ç»­ä½¿ç”¨:', error);
            // ç½‘ç»œé”™è¯¯ä¸åº”è¯¥å¯¼è‡´é€€å‡ºç™»å½•
          });
        }
      } else {
        console.log('ğŸ“± é¡µé¢å˜ä¸ºéšè—');
      }
    });
				  </script>
</body>
</html>
