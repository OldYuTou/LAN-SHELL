<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>LAN Shell</title>
  
  <!-- 强制全屏模式 -->
  <meta name="apple-touch-fullscreen" content="yes" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="msapplication-tap-highlight" content="no" />
  
  <!-- 防止缩放和滚动 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  
  <!-- PWA配置 -->
  <meta name="theme-color" content="#0f1115" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="LAN Shell" />
  <meta name="mobile-web-app-capable" content="yes" />
  
  <!-- Edge PWA 专用配置 -->
  <meta name="msapplication-TileColor" content="#0f1115" />
  <meta name="msapplication-config" content="none" />
  <meta name="msapplication-tap-highlight" content="no" />
  <meta name="msapplication-navbutton-color" content="#0f1115" />
  <meta name="msapplication-starturl" content="/?pwa=true&edge=true" />
  <meta name="msapplication-window" content="width=device-width;height=device-height" />
  
  <!-- 安卓PWA强制全屏 -->
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f1115" />
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#0f1115" />
  <meta name="color-scheme" content="dark" />
  
  <!-- 强制隐藏浏览器UI -->
  <meta name="mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="msapplication-navbutton-color" content="#0f1115" />
  <meta name="application-name" content="LAN Shell" />
  
  <!-- 防止显示浏览器控件 -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-touch-fullscreen" content="yes" />
  <meta name="full-screen" content="yes" />
  <meta name="browsermode" content="application" />
  
  <!-- Web App Manifest -->
  <link rel="manifest" href="/manifest.json" />
  
  <!-- 图标 -->
  <link rel="apple-touch-icon" sizes="180x180" href="/icon-192.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/icon-192.png" />
  
  <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css">
  <!-- 文本编辑器（CodeMirror 5）：行号、滚动、光标移动等基础能力 -->
  <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.16/lib/codemirror.css">
  <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.16/theme/material-darker.css">
  <style id="git-branch-style" disabled>
    /* Git 分支选择弹窗（懒加载，避免初始渲染出现在终端） */
    #git-branch-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 10110; /* higher than git-page (10050) */
    }
    #git-branch-backdrop.open { display:block; }
    #git-branch-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 620px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 10111; /* above git-page/backdrop */
      color:#fff;
    }
    #git-branch-modal.open { display:block; }
    #git-branch-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #git-branch-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #git-branch-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .branch-filter { width:100%; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:rgba(0,0,0,0.18); color:#fff; padding:10px 12px; box-sizing:border-box; font-size:13px; margin-bottom:10px; }
    .branch-columns { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .branch-list { max-height: 48vh; overflow:auto; border:1px solid rgba(255,255,255,0.10); border-radius:12px; padding:6px; background: rgba(0,0,0,0.08); }
    .branch-item { padding:10px 12px; border-radius:10px; cursor:pointer; display:flex; align-items:center; gap:8px; font-size:13px; }
    .branch-item:hover { background: rgba(255,255,255,0.08); }
    .branch-item.active { background: rgba(45,140,255,0.25); border:1px solid rgba(45,140,255,0.55); }
    .branch-tag { font-size:11px; opacity:0.8; padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,0.15); }
    #branch-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    #branch-actions button { border-radius: 12px; padding: 10px 14px; font-size: 13px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.08); color: #fff; cursor: pointer; font-weight: 700; }
    #branch-actions button.primary { background: rgba(45, 140, 255, 0.92); border-color: rgba(45, 140, 255, 0.65); }
    #branch-actions button.danger { background: rgba(255, 80, 80, 0.24); border-color: rgba(255, 80, 80, 0.60); color:#ff6b6b; }
    #branch-status { font-size:12px; opacity:0.8; margin-top:8px; line-height:1.4; }

    /* Git 新建分支弹窗 */
    #git-new-branch-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 10110;
    }
    #git-new-branch-backdrop.open { display:block; }
    #git-new-branch-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 520px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 10111;
      color:#fff;
    }
    #git-new-branch-modal.open { display:block; }
    #git-new-branch-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #git-new-branch-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #git-new-branch-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .new-branch-field { margin-top:10px; }
    .new-branch-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .new-branch-field input, .new-branch-field select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    #git-new-branch-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    #git-new-branch-actions button { border-radius: 12px; padding: 10px 14px; font-size: 13px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.08); color: #fff; cursor: pointer; font-weight: 700; }
    #git-new-branch-actions button.primary { background: rgba(45, 140, 255, 0.92); border-color: rgba(45, 140, 255, 0.65); }
  </style>
  <style>
    :root { 
      --bg:#0f1115; 
      --panel:#f5f5f7; 
      --accent:#2d8cff; 
      --sidebar-width:380px;
      --vh: 1vh;
    }
    
    html {
      height: 100%;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
    }
    
    body { 
      margin:0; 
      display:flex; 
      flex-direction:column; 
      height:100vh; 
      height: calc(var(--vh, 1vh) * 100);
      font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background:var(--bg); 
      color:#eee;
      overflow-x:hidden;
      width:100vw;
      max-width:100vw;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    #top { 
      display:flex; 
      gap:8px; 
      padding:12px; 
      align-items:center; 
      background:#131722; 
      box-shadow:0 2px 8px rgba(0,0,0,.4); 
      border-bottom:1px solid #2a2d3a;
      transition:margin-left 0.3s;
      margin-left:var(--sidebar-width);
      flex-wrap:wrap;
    }
    body.sidebar-collapsed #top {
      margin-left:0;
    }
    
	    /* removed: logout button + mobile toolbar */
    #path { flex:1; padding:10px 12px; border-radius:8px; border:1px solid #3a3d4a; background:#1c1f2b; color:#f7f7f7; font-size:14px; transition:border-color 0.2s; }
    #path:focus { outline:none; border-color:var(--accent); }
    button { padding:10px 16px; border:none; border-radius:8px; background:var(--accent); color:#fff; cursor:pointer; font-weight:600; font-size:14px; transition:all 0.2s; }
    button:hover { background:#1e7ae8; transform:translateY(-1px); }
    button:active { transform:translateY(0); }
    #main { 
      display:flex; 
      flex:1; 
      min-height:0; 
      position:relative;
      overflow:hidden;
      width:100%;
      max-width:100vw;
    }
    
    /* 折叠状态下的布局调整 */
    body.sidebar-collapsed #main {
      margin-left:0;
    }
    body.sidebar-collapsed #top {
      padding-left:60px; /* 为展开按钮留空间 */
    }
    
    /* 侧边栏样式 */
    #sidebar { 
      width:var(--sidebar-width); 
      height:100%; 
      background:var(--panel); 
      color:#111; 
      display:flex; 
      flex-direction:column; 
      box-shadow:2px 0 10px rgba(0,0,0,.15);
      transition:transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position:fixed;
      left:0;
      top:0;
      z-index:10;
    }
    #sidebar.collapsed { 
      transform:translateX(-100%); 
    }
    
	    /* 折叠按钮 */
	    #toggle-sidebar {
	      position:absolute;
	      left:calc(var(--sidebar-width) - 20px);
	      top:50%;
	      transform:translateY(-50%);
	      width:40px;
	      height:60px;
	      background: rgba(45, 140, 255, 0.18);
	      border: 1px solid rgba(45, 140, 255, 0.28);
	      border-radius:0 8px 8px 0;
	      color:#fff;
	      cursor:pointer;
	      display:flex;
	      align-items:center;
	      justify-content:center;
	      font-size:16px;
	      transition:all 0.3s;
	      box-shadow:2px 0 12px rgba(0,0,0,.22);
	      z-index:12;
	    }
    body.sidebar-collapsed #toggle-sidebar {
      left:10px !important;
      border-radius:8px !important;
    }
	    #toggle-sidebar:hover {
	      background: rgba(45, 140, 255, 0.30);
	      border-color: rgba(45, 140, 255, 0.55);
	      width:45px;
	    }
    
    /* 侧边栏头部 */
    #sidebar-header {
      padding:16px;
      background:#e8e8ea;
      border-bottom:1px solid #d1d1d6;
      font-weight:600;
      font-size:16px;
      color:#1d1d1f;
      display:flex;
      align-items:center;
      gap:8px;
    }
    #sidebar-header .spacer { flex:1; }
    #sidebar-actions {
      display:flex;
      gap:8px;
      margin-left:auto;
      align-items:center;
    }
    #sidebar-actions button {
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
      font-weight:700;
      background: rgba(26, 30, 44, 0.92);
      border: 1px solid rgba(0,0,0,0.10);
      color:#111;
      cursor:pointer;
    }
    #sidebar-actions button:hover { background: rgba(26, 30, 44, 0.84); }
    #sidebar-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.55);
      color:#fff;
    }
    #sidebar-actions button.ghost {
      background: rgba(255,255,255,0.12);
      border-color: rgba(0,0,0,0.12);
      color:#111;
    }

    /* 新建/上传弹窗 */
    #file-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #file-modal-backdrop.open { display:block; }
    #file-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 520px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #file-modal.open { display:block; }
    .file-modal-row {
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom: 12px;
    }
    .file-modal-title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    .file-modal-close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .file-modal-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .file-modal-field input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    .file-modal-actions {
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .file-modal-actions button {
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 700;
    }
    .file-modal-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }

    /* 解压弹窗 + 目录选择 */
    #extract-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #extract-modal-backdrop.open { display:block; }
    #extract-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 560px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #extract-modal.open { display:block; }
    #extract-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #extract-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #extract-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .extract-field { margin-top:10px; }
    .extract-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .extract-field input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    .extract-inline {
      display:flex;
      gap:10px;
      align-items:center;
    }
    .extract-inline input { flex:1; min-width:0; }
    .extract-inline button {
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 800;
      white-space:nowrap;
    }
    .extract-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    .extract-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }
    .extract-actions button.danger {
      background: rgba(255, 80, 80, 0.24);
      border-color: rgba(255, 80, 80, 0.60);
      color:#ff6b6b;
    }

    #dirpicker {
      margin-top:12px;
      border-top:1px solid rgba(255,255,255,0.10);
      padding-top:12px;
      display:none;
    }
    #dirpicker.open { display:block; }
    #dirpicker .hint { font-size:12px; opacity:0.8; margin-bottom:8px; }
    #dirpicker-list {
      max-height: 42vh;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:12px;
      padding:8px;
      background: rgba(0,0,0,0.10);
    }
    .dir-item {
      padding:10px 10px;
      border-radius:10px;
      cursor:pointer;
      display:flex;
      gap:10px;
      align-items:center;
      font-size:13px;
    }
    .dir-item:hover { background: rgba(255,255,255,0.07); }
    #dirpicker-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:10px; }

    /* 文件操作：长按菜单 */
    #op-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #op-modal-backdrop.open { display:block; }
    #op-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 560px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #op-modal.open { display:block; }
    #op-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #op-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #op-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    #op-path {
      font-size:12px;
      opacity:0.85;
      word-break: break-all;
      margin-bottom: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(0,0,0,0.10);
    }
    #op-actions { display:flex; gap:10px; flex-wrap:wrap; }
    #op-actions button {
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 800;
    }
    #op-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }
    #op-actions button.danger {
      background: rgba(255, 80, 80, 0.24);
      border-color: rgba(255, 80, 80, 0.60);
      color:#ff6b6b;
    }

    /* 复制/剪切：选择目标目录 + 命名 */
    #xfer-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 1000;
    }
    #xfer-modal-backdrop.open { display:block; }
    #xfer-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92vw, 600px);
      background: rgba(26, 30, 44, 0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,0.5);
      display: none;
      z-index: 1001;
      color:#fff;
    }
    #xfer-modal.open { display:block; }
    #xfer-modal .row { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    #xfer-modal .title { font-weight:800; font-size:14px; letter-spacing:0.2px; }
    #xfer-modal .close {
      margin-left:auto;
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.85);
      font-size: 20px;
      cursor:pointer;
    }
    .xfer-field { margin-top:10px; }
    .xfer-field label { display:block; font-size: 12px; opacity:0.85; margin-bottom: 6px; }
    .xfer-field input, .xfer-field select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: #fff;
      padding: 10px 12px;
      box-sizing: border-box;
      font-size: 13px;
      outline: none;
    }
    #xfer-dir-list {
      margin-top: 10px;
      max-height: 42vh;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:12px;
      padding:8px;
      background: rgba(0,0,0,0.10);
    }
    #xfer-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
    #xfer-actions button.primary {
      background: rgba(45, 140, 255, 0.92);
      border-color: rgba(45, 140, 255, 0.65);
    }
    #xfer-actions button.danger {
      background: rgba(255, 80, 80, 0.24);
      border-color: rgba(255, 80, 80, 0.60);
      color:#ff6b6b;
    }

    /* 文件列表 */
    #list { 
      flex:1; 
      overflow:auto; 
      padding:12px; 
      scrollbar-width:thin;
      scrollbar-color:#ccc transparent;
    }
    #list::-webkit-scrollbar { width:6px; }
    #list::-webkit-scrollbar-track { background:transparent; }
    #list::-webkit-scrollbar-thumb { background:#ccc; border-radius:3px; }
    #list::-webkit-scrollbar-thumb:hover { background:#999; }
    
    #term-wrap { 
      flex:1; 
      min-width:0; 
      display:flex; 
      flex-direction:column; 
      transition:margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      margin-left:var(--sidebar-width);
      will-change:margin-left;
    }
    body.sidebar-collapsed #term-wrap {
      margin-left:0;
    }
    
    #tabs { 
      display:flex; 
      gap:8px; 
      padding:12px; 
      background:#1b2030; 
      border-bottom:1px solid #2a2d3a; 
      overflow-x:auto;
      scrollbar-width:none;
    }
    #tabs::-webkit-scrollbar { display:none; }
    
    .tab { 
      padding:8px 12px; 
      background:#2a3045; 
      color:#eee; 
      border-radius:8px; 
      cursor:pointer; 
      display:flex; 
      align-items:center; 
      gap:8px; 
      white-space:nowrap;
      transition:all 0.2s;
      border:1px solid transparent;
    }
    .tab:hover { background:#3a4055; }
    .tab.active { 
      background:#3c83f6; 
      border-color:#5a9cff;
      box-shadow:0 2px 8px rgba(60,131,246,0.3);
    }
    .tab .close { 
      font-weight:bold; 
      cursor:pointer; 
      padding:2px 4px;
      border-radius:4px;
      transition:background 0.2s;
    }
    .tab .close:hover { background:rgba(255,255,255,0.2); }
    
		    #term-area { 
		      position:relative; 
		      flex:1; 
		      background:#0f1115;
		      overflow:hidden;
	      /* 触控手势：终端区域优先用于滚动；底部“空白触控板”区域用于单指移动光标 */
	      touch-action: pan-x pan-y;
		      overscroll-behavior: contain;
		      width:100%;
		      max-width:100%;
		      /* 底部不留内边距：让终端内容区域与下方触摸板紧贴，避免出现“空隙” */
		      padding:5px 5px 0 5px;
		      box-sizing:border-box;
		    }
		    .term-pane { 
		      position:absolute; 
		      /* 底部不留空：让终端内容区域直接贴到触摸板上 */
		      inset:5px 5px 0 5px;
		      overflow:hidden;
		      /* 绝对定位时由 inset 决定尺寸，避免同时指定 width/height 造成底部错误留白 */
		      display:flex;
		    }
		    /* 修复部分移动端浏览器（如 Android Edge）出现“终端底部死区”：
		       xterm 的 .xterm 可能按 rows 自然高度渲染，未撑满容器，导致底部留下可见但不可交互的空白带。 */
		    .term-pane > .xterm {
		      flex:1 1 auto;
		      width:100%;
		      height:100%;
		    }
		    .term-pane .xterm-viewport {
		      height:100% !important;
		    }

		    /* 文本编辑器面板：与终端 pane 同级，复用 tabs/右侧内容区 */
		    .editor-pane {
		      position:absolute;
		      inset:5px;
		      overflow:hidden;
		      display:flex;
		      flex-direction:column;
		      background:#0f1115;
		      border:1px solid rgba(255,255,255,0.06);
		      border-radius:10px;
		    }
		    .editor-toolbar {
		      display:flex;
		      align-items:center;
		      gap:10px;
		      padding:8px 10px;
		      background:#1b2030;
		      border-bottom:1px solid rgba(255,255,255,0.08);
		      box-sizing:border-box;
		    }
		    .editor-title {
		      flex:1;
		      min-width:0;
		      font-size:13px;
		      color:rgba(255,255,255,0.85);
		      white-space:nowrap;
		      overflow:hidden;
		      text-overflow:ellipsis;
		    }
		    .editor-actions {
		      display:flex;
		      gap:8px;
		    }
		    .mini-btn {
		      padding:8px 10px;
		      border-radius:10px;
		      font-size:12px;
		      font-weight:700;
		      background:rgba(45, 140, 255, 0.92);
		      border:1px solid rgba(45, 140, 255, 0.55);
		      color:#fff;
		    }
		    .mini-btn.secondary {
		      background:rgba(255,255,255,0.08);
		      border-color:rgba(255,255,255,0.12);
		      color:rgba(255,255,255,0.9);
		    }
		    .mini-btn.danger {
		      background:rgba(255, 80, 80, 0.24);
		      border-color:rgba(255, 80, 80, 0.60);
		      color:#ff6b6b;
		    }
		    .editor-body {
		      flex:1;
		      min-height:0;
		      height:0; /* 避免部分移动端/Safari 下 % 高度在 flex 容器里计算不稳定 */
		      overflow:hidden;
		    }
    .editor-pane .CodeMirror {
      height:100%;
      font-size:13px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    /* VS Code Dark+ 风格配色（自定义主题 vsc-dark-plus） */
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus {
      background:#1e1e1e;
      color:#d4d4d4;
    }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-gutters {
      background:#1e1e1e;
      border-right:1px solid #2d2d2d;
      color:#858585;
    }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-linenumber { color:#858585; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-cursor { border-left:2px solid #aeafad; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-selected { background:#264f78; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-line::selection,
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-line > span::selection {
      background:#264f78;
    }
    /* 语法高亮映射 VS Code Dark+ 颜色 */
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-comment { color:#6a9955; font-style:italic; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-string,
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-string-2 { color:#ce9178; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-number { color:#b5cea8; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-keyword { color:#c586c0; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-atom { color:#569cd6; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-def { color:#4fc1ff; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-variable { color:#d4d4d4; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-variable-2 { color:#9cdcfe; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-variable-3 { color:#4ec9b0; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-property { color:#9cdcfe; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-operator { color:#d4d4d4; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-qualifier,
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-builtin { color:#dcdcaa; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-meta { color:#c8c8c8; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-tag { color:#569cd6; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-attribute { color:#9cdcfe; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-error { background:transparent; color:#f44747; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .cm-matchhighlight { background:rgba(255,255,255,0.08); }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-matchingbracket { color:#ffcc00; font-weight:700; }
    .editor-pane .CodeMirror.cm-s-vsc-dark-plus .CodeMirror-nonmatchingbracket { color:#f44747; font-weight:700; }
		    /* 触屏设备上底部有 #cursor-pad：给编辑器滚动区留出“安全底部”，避免最后几行被触控板视觉/交互遮挡 */
		    @media (pointer: coarse) {
		      .editor-pane .CodeMirror-scroll {
		        padding-bottom: calc(clamp(64px, 18vh, 240px) + env(safe-area-inset-bottom, 0px));
		        box-sizing: content-box;
		      }
		    }

	    /* 底部空白触控板：仅在触屏设备上显示，用于单指滑动移动光标 */
	    #cursor-pad {
	      display:none;
	      flex:0 0 auto;
	      height:64px;
	      background:#0f1115;
	      border-top:1px solid rgba(255,255,255,0.08);
	      touch-action:none;
	      user-select:none;
	      -webkit-user-select:none;
	      -webkit-touch-callout:none;
	      box-sizing:border-box;
	    }
	    @media (pointer: coarse) {
	      #cursor-pad {
	        display:block;
	        /* 触屏设备上尽量把“终端下方的空白”分配给光标触控板，提升可用面积 */
	        height: clamp(64px, 18vh, 240px);
	        /* iOS 底部安全区也并入触控板区域，避免出现“看得见但摸不到”的空白 */
	        padding-bottom: env(safe-area-inset-bottom, 0px);
	      }
	    }

	    /* 编辑器页面不需要底部触控板：让编辑器占满可用空间 */
	    body.editor-active #cursor-pad {
	      display: none !important;
	    }
    
    .item { 
      padding:10px 12px; 
      border-radius:8px; 
      margin-bottom:6px; 
      cursor:pointer; 
      transition:all 0.2s;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
      font-weight:500;
    }
    .item:hover { 
      background:rgba(0,0,0,0.08); 
      transform:translateX(2px);
    }
    .item .file-name { 
      flex:1; 
      color:#1d1d1f;
      font-weight:600;
      font-size:15px;
    }
    .item .file-tag { 
      color:#666; 
      font-size:11px; 
      background:#f0f0f0;
      padding:3px 7px;
      border-radius:4px;
      font-weight:500;
    }
    
    /* PWA样式优化 - 全屏模式 */
    @media (display-mode: fullscreen), (display-mode: standalone) {
      body {
        /* 全屏模式下的额外样式 */
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        height: 100vh;
        height: 100dvh; /* 动态视口高度 */
        overflow: hidden;
      }
      
      #top {
        /* 状态栏适配 */
        padding-top: calc(12px + env(safe-area-inset-top));
      }
      
      /* 隐藏所有可能的浏览器UI */
      html {
        overflow: hidden;
        height: 100%;
        height: 100dvh;
      }
      
      /* 强制全屏 */
      body {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
      }
    }
    
    /* 防止页面被拉动 */
    body {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }
    
    /* 禁用文本选择和长按菜单 */
    * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* 允许输入框选择文本 */
    input, textarea, .xterm-helper-textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    
    /* 确保按钮可以接收触摸事件 */
    button {
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
    }
    @media (max-width: 768px) {
      :root { --sidebar-width:300px; }
      
      body {
        overflow-x:hidden !important;
        position:fixed;
        width:100vw;
        height:100vh;
      }
      
      #top { 
        padding:8px;
        width:100%;
        box-sizing:border-box;
        overflow:hidden;
        justify-content:space-between;
      }
      
	      /* removed: mobile toolbar */
      
      /* 手机端隐藏部分按钮文字 */
      #load, #newTerm {
        font-size:12px;
        padding:6px 8px;
      }
      
      #path {
        flex:1;
        min-width:120px;
        font-size:12px;
      }
      
      #main {
        overflow:hidden !important;
        width:100vw;
        max-width:100vw;
      }
      
      #sidebar {
        max-width:100vw;
        box-sizing:border-box;
      }
      
      #term-wrap {
        max-width:100vw;
        box-sizing:border-box;
        overflow:hidden;
      }
      
      #term-area {
        overflow:hidden !important;
        width:100% !important;
        max-width:100vw !important;
        touch-action: pan-x pan-y;
        overscroll-behavior: contain;
      }
      
      .term-pane {
        overflow:hidden !important;
        width:100% !important;
        max-width:100vw !important;
      }
      
      /* 强制终端内容不超出屏幕 */
      .xterm-viewport {
        overflow-x:hidden !important;
        width:100% !important;
        max-width:100vw !important;
      }
      
      .xterm-screen {
        overflow-x:hidden !important;
        width:100% !important;
        max-width:100vw !important;
      }
      
      #tabs {
        overflow-x:auto;
        scrollbar-width:none;
        -ms-overflow-style:none;
      }
      
      #tabs::-webkit-scrollbar {
        display:none;
      }
      
      button { padding:8px 12px; font-size:13px; }
	    }

	    /* 右侧悬浮入口 + 抽屉 */
	    #side-actions {
	      position: fixed;
	      right: calc(12px + env(safe-area-inset-right, 0px));
	      top: 50%;
	      transform: translate(0, -50%);
	      transition: transform 0.22s ease;
	      z-index: 9999;
	      display: flex;
	      flex-direction: column;
	      align-items: center;
	      gap: 10px;
	    }
	    #side-actions.open {
	      transform: translate(calc(-1 * var(--drawer-w, 0px)), -50%);
	    }

	    #drawerToggleBtn {
	      width: 52px;
	      height: 52px;
	      border-radius: 14px;
	      border: 1px solid rgba(255,255,255,0.20);
	      background: transparent;
	      color: #fff;
	      cursor: pointer;
	      box-shadow: 0 10px 26px rgba(0,0,0,0.40);
	      font-size: 20px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	    }
	    #drawerToggleBtn:hover {
	      background: rgba(45, 140, 255, 0.12);
	      border-color: rgba(45, 140, 255, 0.45);
	    }

	    #cmdsetFloatingBtn {
	      width: 52px;
	      height: 52px;
	      border-radius: 14px;
	      border: 1px solid rgba(255,255,255,0.20);
	      background: transparent;
	      color: #fff;
	      cursor: pointer;
	      box-shadow: 0 10px 26px rgba(0,0,0,0.40);
	      font-size: 18px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	    }
	    #cmdsetFloatingBtn:hover {
	      background: rgba(45, 140, 255, 0.12);
	      border-color: rgba(45, 140, 255, 0.45);
	    }

	    #comboFloatingBtn {
	      width: 52px;
	      height: 52px;
	      border-radius: 14px;
	      border: 1px solid rgba(255,255,255,0.20);
	      background: transparent;
	      color: #fff;
	      cursor: pointer;
	      box-shadow: 0 10px 26px rgba(0,0,0,0.40);
	      font-size: 16px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	    }
	    #comboFloatingBtn:hover {
	      background: rgba(45, 140, 255, 0.12);
	      border-color: rgba(45, 140, 255, 0.45);
	    }

	    #drawer-backdrop {
	      position: fixed;
	      inset: 0;
	      background: rgba(0,0,0,0.55);
	      z-index: 9998;
	      display: none;
	    }
	    #drawer-backdrop.open { display: block; }

	    #right-drawer {
	      position: fixed;
	      top: 0;
	      right: 0;
	      height: 100vh;
	      height: 100dvh;
	      width: auto;
	      padding: 12px 10px;
	      box-sizing: border-box;
	      background: rgba(19, 23, 34, 0.96);
	      border-left: 1px solid rgba(255,255,255,0.08);
	      transform: translateX(110%);
	      transition: transform 0.22s ease;
	      z-index: 9999;
	      display: flex;
	      flex-direction: column;
	      gap: 12px;
	      backdrop-filter: blur(10px);
	    }
	    #right-drawer.open { transform: translateX(0); }

	    #right-drawer .drawer-header {
	      display: flex;
	      align-items: center;
	      justify-content: space-between;
	      gap: 10px;
	      padding-top: calc(6px + env(safe-area-inset-top, 0px));
	    }
	    #right-drawer .drawer-title {
	      display: none;
	    }
	    #right-drawer .drawer-title {
	      font-weight: 700;
	      letter-spacing: 0.2px;
	    }
	    #drawerCloseBtn {
	      width: 40px;
	      height: 40px;
	      border-radius: 12px;
	      border: 1px solid rgba(255,255,255,0.10);
	      background: rgba(26, 30, 44, 0.92);
	      color: #fff;
	      cursor: pointer;
	    }
	    #right-drawer .drawer-actions {
	      display: flex;
	      flex-direction: column;
	      gap: 10px;
	      margin-top: 8px;
	    }
	    #right-drawer .drawer-actions button {
	      width: 84px;
	      border-radius: 12px;
	      border: 1px solid rgba(255,255,255,0.10);
	      background: rgba(26, 30, 44, 0.92);
	      color: #fff;
	      padding: 10px 12px;
	      font-size: 13px;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	      gap: 10px;
	    }
	    #right-drawer .drawer-actions button .k {
	      opacity: 0.75;
	      font-size: 12px;
	      border: 1px solid rgba(255,255,255,0.12);
	      padding: 2px 8px;
	      border-radius: 999px;
	    }
	    #right-drawer .drawer-actions button.active {
	      background: rgba(45, 140, 255, 0.16);
	      border-color: rgba(45, 140, 255, 0.65);
	      box-shadow: 0 0 0 1px rgba(45, 140, 255, 0.25);
	    }

		    /* Paste modal (long-press on PASTE) */
		    #paste-modal-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.60);
		      z-index: 10000;
		      display: none;
		    }
		    #paste-modal-backdrop.open { display: block; }
		    #paste-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 680px);
		      max-height: min(80vh, 720px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
		      z-index: 10001;
		      display: none;
		      padding: 14px;
		      box-sizing: border-box;
		    }
		    #paste-modal.open { display: block; }
		    #paste-modal .row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 10px;
		    }
		    #paste-modal .title {
		      font-weight: 700;
		      font-size: 14px;
		      opacity: 0.9;
		    }
		    #paste-modal .close {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #paste-input {
		      width: 100%;
		      height: min(46vh, 420px);
		      resize: vertical;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.12);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      box-sizing: border-box;
		      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		      font-size: 13px;
		      line-height: 1.35;
		      outline: none;
		    }
		    #paste-modal .actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		      margin-top: 10px;
		    }
		    #paste-modal .actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		    }
		    #paste-modal .actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }

		    /* 组合键弹窗 */
		    #combo-modal-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.60);
		      z-index: 10020;
		      display: none;
		    }
		    #combo-modal-backdrop.open { display: block; }
		    #combo-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 520px);
		      max-height: min(80vh, 520px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
		      z-index: 10021;
		      display: none;
		      padding: 14px;
		      box-sizing: border-box;
		    }
		    #combo-modal.open { display: block; }
		    #combo-modal .row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 12px;
		    }
		    #combo-modal .title {
		      font-weight: 800;
		      font-size: 14px;
		      opacity: 0.9;
		    }
		    #combo-modal .close {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    .combo-toggle {
		      display: flex;
		      gap: 8px;
		      margin-bottom: 10px;
		    }
		    .combo-toggle button {
		      flex: 1;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      font-size: 13px;
		      cursor: pointer;
		    }
		    .combo-toggle button.active {
		      background: rgba(45, 140, 255, 0.22);
		      border-color: rgba(45, 140, 255, 0.65);
		    }
		    #combo-input {
		      width: 100%;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.12);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      box-sizing: border-box;
		      font-size: 14px;
		      outline: none;
		      margin-bottom: 12px;
		    }
		    #combo-modal .actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		    }
		    #combo-modal .actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #combo-modal .actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }

		    /* 指令集页面（全屏覆盖） */
		    #cmdset-page {
		      position: fixed;
		      inset: 0;
		      background: rgba(15, 17, 21, 0.98);
		      z-index: 10050;
		      display: none;
		      flex-direction: column;
		      box-sizing: border-box;
		      padding: calc(env(safe-area-inset-top, 0px)) calc(env(safe-area-inset-right, 0px)) calc(env(safe-area-inset-bottom, 0px)) calc(env(safe-area-inset-left, 0px));
		    }
		    #cmdset-page.open { display: flex; }

		    /* Git 页面（复用指令集样式） */
		    #git-page {
		      position: fixed;
		      inset: 0;
		      background: rgba(15, 17, 21, 0.98);
		      z-index: 10050;
		      display: none;
		      flex-direction: column;
		      box-sizing: border-box;
		      padding: calc(env(safe-area-inset-top, 0px)) calc(env(safe-area-inset-right, 0px)) calc(env(safe-area-inset-bottom, 0px)) calc(env(safe-area-inset-left, 0px));
		    }
		    #git-page.open { display: flex; }

		    #gitCwdText {
		      margin-top: 3px;
		      font-size: 12px;
		      opacity: 0.75;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }

		    /* Git 回退弹窗 */
		    #git-reset-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.55);
		      z-index: 10090;
		      display: none;
		    }
		    #git-reset-backdrop.open { display: block; }
		    #git-reset-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 520px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      z-index: 10100;
		      display: none;
		      padding: 12px;
		      box-sizing: border-box;
		    }
		    #git-reset-modal.open { display: block; }
		    #git-reset-modal .row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 10px;
		    }
		    #git-reset-modal .title { font-weight: 800; font-size: 14px; }
		    #git-reset-modal .close {
		      width: 32px;
		      height: 32px;
		      border-radius: 10px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #git-reset-modal .desc {
		      font-size: 13px;
		      opacity: 0.9;
		      white-space: pre-wrap;
		      line-height: 1.5;
		      padding: 6px 2px 10px;
		    }
		    #git-reset-modal .actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		    }
		    #git-reset-modal .actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    #git-reset-modal .actions button:disabled {
		      opacity: 0.45;
		      cursor: not-allowed;
		    }
		    #git-reset-modal .actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }
		    #git-reset-modal .actions button.danger {
		      background: rgba(255, 80, 80, 0.24);
		      border-color: rgba(255, 80, 80, 0.60);
		      color: #ff6b6b;
		    }

		    .cmdset-topbar {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      padding: 12px;
		      border-bottom: 1px solid rgba(255,255,255,0.08);
		      background: rgba(19, 23, 34, 0.98);
		    }
		    .cmdset-icon-btn {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		      display: inline-flex;
		      align-items: center;
		      justify-content: center;
		      font-size: 16px;
		      padding: 0;
		    }
		    .cmdset-title-wrap { flex: 1; min-width: 0; }
		    .cmdset-title { font-weight: 800; font-size: 14px; letter-spacing: 0.2px; }
		    .cmdset-breadcrumb {
		      margin-top: 3px;
		      font-size: 12px;
		      opacity: 0.75;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }
		    .cmdset-top-actions {
		      display: flex;
		      gap: 8px;
		      flex-wrap: wrap;
		      justify-content: flex-end;
		    }
		    .cmdset-small-btn {
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      font-size: 13px;
		      cursor: pointer;
		      white-space: nowrap;
		    }
		    .cmdset-small-btn.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }

		    .cmdset-body {
		      flex: 1;
		      min-height: 0;
		      overflow: auto;
		      padding: 12px;
		      box-sizing: border-box;
		    }
		    .cmdset-empty {
		      padding: 18px 12px;
		      opacity: 0.75;
		      font-size: 13px;
		    }

		    .cmdset-item {
		      display: flex;
		      align-items: center;
		      gap: 10px;
		      padding: 10px 12px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.08);
		      background: rgba(26, 30, 44, 0.62);
		      cursor: pointer;
		      margin-bottom: 10px;
		      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
		    }
		    .cmdset-item:hover {
		      transform: translateX(2px);
		      background: rgba(26, 30, 44, 0.82);
		      border-color: rgba(45, 140, 255, 0.20);
		    }
		    /* Git 提交状态：已推送 / 未推送 / 未知 */
		    .cmdset-item.git-pushed {
		      background: rgba(16, 185, 129, 0.12);
		      border-color: rgba(16, 185, 129, 0.28);
		    }
		    .cmdset-item.git-unpushed {
		      background: rgba(245, 158, 11, 0.12);
		      border-color: rgba(245, 158, 11, 0.28);
		    }
		    .cmdset-item.git-unknown {
		      background: rgba(148, 163, 184, 0.10);
		      border-color: rgba(148, 163, 184, 0.22);
		    }
		    .cmdset-item .ico { width: 22px; text-align: center; opacity: 0.9; }
		    .cmdset-item .name {
		      flex: 1;
		      min-width: 0;
		      font-weight: 750;
		      font-size: 14px;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }
		    .cmdset-item .meta {
		      font-size: 12px;
		      opacity: 0.7;
		      white-space: nowrap;
		      max-width: 40%;
		      overflow: hidden;
		      text-overflow: ellipsis;
		    }
		    .cmdset-edit {
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.18);
		      background: rgba(255,255,255,0.08);
		      color: #fff;
		      padding: 8px 10px;
		      font-size: 13px;
		      cursor: pointer;
		    }
		    .cmdset-edit:hover {
		      background: rgba(45, 140, 255, 0.18);
		      border-color: rgba(45, 140, 255, 0.45);
		    }

		    /* 指令集：通用弹窗 */
		    #cmdset-modal-backdrop, #cmdset-confirm-backdrop {
		      position: fixed;
		      inset: 0;
		      background: rgba(0,0,0,0.60);
		      z-index: 10060;
		      display: none;
		    }
		    #cmdset-modal-backdrop.open, #cmdset-confirm-backdrop.open { display: block; }

		    #cmdset-modal, #cmdset-confirm-modal {
		      position: fixed;
		      left: 50%;
		      top: 50%;
		      transform: translate(-50%, -50%);
		      width: min(92vw, 720px);
		      max-height: min(82vh, 760px);
		      background: rgba(19, 23, 34, 0.98);
		      border: 1px solid rgba(255,255,255,0.10);
		      border-radius: 16px;
		      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
		      z-index: 10061;
		      display: none;
		      padding: 14px;
		      box-sizing: border-box;
		    }
		    #cmdset-modal.open, #cmdset-confirm-modal.open { display: block; }

		    .cmdset-modal-row {
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      gap: 10px;
		      margin-bottom: 10px;
		    }
		    .cmdset-modal-title { font-weight: 800; font-size: 14px; opacity: 0.95; }
		    .cmdset-modal-close {
		      width: 40px;
		      height: 40px;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    .cmdset-field { margin-top: 10px; }
		    .cmdset-field label { display:block; font-size: 12px; opacity:0.8; margin-bottom: 6px; }
		    .cmdset-field input, .cmdset-field textarea {
		      width: 100%;
		      border-radius: 12px;
		      border: 1px solid rgba(255,255,255,0.12);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      padding: 10px 12px;
		      box-sizing: border-box;
		      font-size: 13px;
		      outline: none;
		    }
		    .cmdset-field textarea {
		      height: min(34vh, 340px);
		      resize: vertical;
		      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		      line-height: 1.35;
		    }
		    .cmdset-modal-actions {
		      display: flex;
		      justify-content: flex-end;
		      gap: 10px;
		      margin-top: 12px;
		    }
		    .cmdset-modal-actions button {
		      border-radius: 12px;
		      padding: 10px 14px;
		      font-size: 13px;
		      border: 1px solid rgba(255,255,255,0.10);
		      background: rgba(26, 30, 44, 0.92);
		      color: #fff;
		      cursor: pointer;
		    }
		    .cmdset-modal-actions button.primary {
		      background: rgba(45, 140, 255, 0.92);
		      border-color: rgba(45, 140, 255, 0.65);
		    }
		    .cmdset-modal-actions button.danger {
		      background: rgba(255, 80, 80, 0.24);
		      border-color: rgba(255, 80, 80, 0.60);
		      color: #ff6b6b;
		    }
		  </style>
		</head>
		<body>
  <div id="top">
    <input id="path" value="." />
    <button id="load">打开目录</button>
    <button id="newTerm">在此启动终端</button>
	    <!-- removed: mobile toolbar + logout -->
	  </div>
  <div id="main">
    <button id="toggle-sidebar" title="折叠/展开侧边栏">‹</button>
    <div id="sidebar">
      <div id="sidebar-header">
        <span>📁</span>
        <span>文件浏览器</span>
        <span class="spacer"></span>
        <div id="sidebar-actions">
          <button id="toggleHiddenBtn" class="ghost" title="显示隐藏文件">显示隐藏</button>
          <button id="newFileBtn" class="primary" title="新建/上传">＋</button>
        </div>
      </div>
      <div id="list"></div>
    </div>
		    <div id="term-wrap">
		      <div id="tabs"></div>
		      <div id="term-area"></div>
		      <div id="cursor-pad" aria-hidden="true"></div>
		    </div>
		  </div>

	  <!-- 右侧悬浮入口 + 抽屉 -->
	  <div id="side-actions">
	    <button id="drawerToggleBtn" title="Tools">≡</button>
	    <button id="cmdsetFloatingBtn" title="指令集">⌘</button>
	    <button id="comboFloatingBtn" title="组合键">⌥⌘</button>
	  </div>
		  <div id="drawer-backdrop"></div>
		  <aside id="right-drawer" aria-hidden="true">
		    <div class="drawer-header">
		      <div class="drawer-title">Tools</div>
		      <button id="drawerCloseBtn" title="Close">×</button>
		    </div>
			    <div class="drawer-actions">
		      <button id="orientationLockBtn" title="旋转：锁定竖屏/允许旋转">
		        <span class="k">ROT</span>
		      </button>
		      <button id="undoBtn" title="撤回（发送 Ctrl+U 清空当前输入行）">
		        <span class="k">UNDO</span>
		      </button>
			      <button id="tabBtn" title="Tab">
			        <span class="k">TAB</span>
			      </button>
			      <button id="enterBtn" title="Enter">
			        <span class="k">ENTER</span>
			      </button>
			      <button id="continueBtn" title="ESC, then continue, then Enter">
		        <span class="k">CONT</span>
		      </button>
		      <button id="escBtn" title="Send ESC">
		        <span class="k">ESC</span>
		      </button>
		      <button id="ctrlCBtn" title="Send Ctrl+C">
		        <span class="k">^C</span>
		      </button>
		    </div>
		  </aside>

			  <!-- 长按 PASTE 弹出输入框 -->
		  <div id="paste-modal-backdrop" aria-hidden="true"></div>
			  <div id="paste-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">PASTE</div>
			      <button class="close" id="pasteModalCloseBtn" title="Close">×</button>
			    </div>
			    <textarea id="paste-input" placeholder="Paste text here…" spellcheck="false" autocapitalize="off" autocorrect="off"></textarea>
			    <div class="actions">
			      <button id="pasteModalCancelBtn">Cancel</button>
			      <button id="pasteModalOkBtn" class="primary">OK</button>
			    </div>
			  </div>

			  <!-- 新建/上传文件弹窗 -->
			  <div id="file-modal-backdrop" aria-hidden="true"></div>
			  <div id="file-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="file-modal-row">
			      <div class="file-modal-title">新建 / 上传文件</div>
			      <button class="file-modal-close" id="fileModalCloseBtn" title="Close">×</button>
			    </div>
			    <div class="file-modal-field">
			      <label>当前目录</label>
			      <input id="fileModalDir" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="file-modal-field" style="margin-top:10px;">
			      <label>名称</label>
			      <input id="newEntryNameInput" placeholder="例如：notes.txt 或 docs" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <input id="uploadFileInput" type="file" style="display:none;" />
			    <div class="file-modal-actions">
			      <button id="uploadBtn">上传文件</button>
			      <button id="createEmptyFileBtn" class="primary">新建文件</button>
			      <button id="createEmptyDirBtn" class="primary">新建文件夹</button>
			    </div>
			  </div>

			  <!-- 解压弹窗（含目录选择器） -->
			  <div id="extract-modal-backdrop" aria-hidden="true"></div>
			  <div id="extract-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">解压</div>
			      <button class="close" id="extractModalCloseBtn" title="Close">×</button>
			    </div>
			    <div class="extract-field">
			      <label>压缩包路径</label>
			      <input id="extractArchivePath" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="extract-field">
			      <label>解压到目录</label>
			      <div class="extract-inline">
			        <input id="extractDestPath" spellcheck="false" autocapitalize="off" autocorrect="off" />
			        <button id="pickDestBtn" title="选择目录">选择</button>
			      </div>
			    </div>
			    <div class="extract-field" style="margin-top:10px;">
			      <label style="display:flex;align-items:center;gap:8px;">
			        <input type="checkbox" id="extractOverwrite" style="width:16px;height:16px;" />
			        <span>允许覆盖同名文件</span>
			      </label>
			    </div>
			    <div class="extract-actions">
			      <button id="extractCancelBtn" class="danger">取消</button>
			      <button id="extractOkBtn" class="primary">开始解压</button>
			    </div>

			    <div id="dirpicker">
			      <div class="hint">选择解压目录（点击文件夹进入；点击 ⬆️ 返回上级）</div>
			      <div class="extract-field" style="margin-top:0;">
			        <label>当前浏览目录</label>
			        <input id="dirpickerPath" spellcheck="false" autocapitalize="off" autocorrect="off" />
			      </div>
			      <div id="dirpicker-list"></div>
			      <div id="dirpicker-actions">
			        <button id="dirpickerCancelBtn">取消选择</button>
			        <button id="dirpickerOkBtn" class="primary">使用该目录</button>
			      </div>
			    </div>
			  </div>

			  <!-- 文件操作：长按菜单 -->
			  <div id="op-modal-backdrop" aria-hidden="true"></div>
			  <div id="op-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title" id="op-title">文件操作</div>
			      <button class="close" id="opCloseBtn" title="Close">×</button>
			    </div>
			    <div id="op-path"></div>
			    <div id="op-actions"></div>
			  </div>

			  <!-- 复制/剪切：选择目标目录并命名 -->
			  <div id="xfer-modal-backdrop" aria-hidden="true"></div>
			  <div id="xfer-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title" id="xfer-title">复制/移动</div>
			      <button class="close" id="xferCloseBtn" title="Close">×</button>
			    </div>
			    <div class="xfer-field">
			      <label>源路径</label>
			      <input id="xfer-src" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="xfer-field">
			      <label>目标目录（点击文件夹进入；点击 ⬆️ 返回上级）</label>
			      <input id="xfer-dest-dir" spellcheck="false" autocapitalize="off" autocorrect="off" />
			      <div id="xfer-dir-list"></div>
			    </div>
			    <div class="xfer-field">
			      <label>新名称</label>
			      <input id="xfer-dest-name" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="xfer-field">
			      <label>同名处理（目录合并时也生效）</label>
			      <select id="xfer-conflict">
			        <option value="error">遇到同名就报错</option>
			        <option value="skip">跳过同名文件</option>
			        <option value="overwrite">覆盖同名文件</option>
			      </select>
			    </div>
			    <div id="xfer-actions">
			      <button id="xferCancelBtn" class="danger">取消</button>
			      <button id="xferOkBtn" class="primary">执行</button>
			    </div>
			  </div>

			  <!-- 组合键弹窗 -->
			  <div id="combo-modal-backdrop" aria-hidden="true"></div>
			  <div id="combo-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="row">
			      <div class="title">发送组合键</div>
			      <button class="close" id="comboModalCloseBtn" title="Close">×</button>
			    </div>
			    <div class="combo-toggle">
			      <button id="comboCtrlBtn">Ctrl</button>
			      <button id="comboAltBtn">Alt</button>
			      <button id="comboShiftBtn">Shift</button>
			    </div>
			    <input id="combo-input" placeholder="输入要配合的字符，如：x" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    <div class="actions">
			      <button id="comboModalCancelBtn">取消</button>
			      <button id="comboModalOkBtn" class="primary">确定</button>
			    </div>
			  </div>

			  <!-- 指令集页面 -->
			  <div id="cmdset-page" aria-hidden="true">
			    <div class="cmdset-topbar">
			      <button id="cmdsetBackBtn" class="cmdset-icon-btn" title="返回">←</button>
			      <div class="cmdset-title-wrap">
			        <div class="cmdset-title">指令集</div>
			        <div id="cmdsetBreadcrumb" class="cmdset-breadcrumb"></div>
			      </div>
			      <div class="cmdset-top-actions">
			        <button id="cmdsetNewCommandBtn" class="cmdset-small-btn primary">新建指令</button>
			        <button id="cmdsetNewFolderBtn" class="cmdset-small-btn">新建文件夹</button>
			      </div>
			    </div>
			    <div id="cmdsetBody" class="cmdset-body">
			      <div id="cmdsetEmpty" class="cmdset-empty" style="display:none;">暂无指令或文件夹</div>
			      <div id="cmdsetList"></div>
			    </div>
			  </div>

			  <!-- Git 页面（长按“指令集”按钮进入） -->
			  <div id="git-page" aria-hidden="true">
			    <div class="cmdset-topbar">
			      <button id="gitBackBtn" class="cmdset-icon-btn" title="返回">←</button>
			      <div class="cmdset-title-wrap">
			        <div class="cmdset-title">Git</div>
			        <div class="cmdset-subtitle" id="gitCwdText">—</div>
			      </div>
        <div class="cmdset-actions">
          <button id="gitRefreshBtn" class="cmdset-icon-btn" title="刷新">⟳</button>
          <button id="gitBranchSwitchBtn" class="cmdset-icon-btn" title="切换分支">⤴</button>
        </div>
      </div>
			    <div class="cmdset-body">
			      <div id="gitInfoBox" class="cmdset-empty"></div>
			      <div id="gitList"></div>
			    </div>
			  </div>

			  <!-- Git 分支选择弹窗 -->
			  <div id="git-branch-backdrop" aria-hidden="true" style="display:none;"></div>
			  <div id="git-branch-modal" role="dialog" aria-modal="true" aria-hidden="true" style="display:none;">
			    <div class="row">
			      <div class="title">切换分支</div>
			      <button class="close" id="gitBranchCloseBtn" title="Close">×</button>
			    </div>
			    <input id="gitBranchFilter" class="branch-filter" placeholder="搜索分支（本地/远程）" />
			    <div class="branch-columns">
			      <div>
			        <div style="font-size:12px;opacity:0.8;margin-bottom:6px;">本地分支</div>
			        <div id="gitBranchLocalList" class="branch-list"></div>
			      </div>
			      <div>
			        <div style="font-size:12px;opacity:0.8;margin-bottom:6px;">远程分支</div>
			        <div id="gitBranchRemoteList" class="branch-list"></div>
			      </div>
			    </div>
			    <div class="extract-field" style="margin-top:10px;">
			      <label style="display:flex;align-items:center;gap:8px;">
			        <input type="checkbox" id="gitBranchForce" style="width:16px;height:16px;" />
			        <span>强制切换（丢弃未提交改动）</span>
			      </label>
			    </div>
			    <div id="branch-status"></div>
			    <div id="branch-actions">
			      <button id="gitBranchCancelBtn" class="danger">取消</button>
			      <button id="gitBranchOkBtn" class="primary">切换</button>
			    </div>
			  </div>

			  <!-- Git 新建分支弹窗 -->
			  <div id="git-new-branch-backdrop" aria-hidden="true" style="display:none;"></div>
			  <div id="git-new-branch-modal" role="dialog" aria-modal="true" aria-hidden="true" style="display:none;">
			    <div class="row">
			      <div class="title">新建分支</div>
			      <button class="close" id="gitNewBranchCloseBtn" title="Close">×</button>
			    </div>
			    <div class="new-branch-field">
			      <label>基于哪个提交/分支创建</label>
			      <select id="gitNewBranchFrom"></select>
			    </div>
			    <div class="new-branch-field">
			      <label>新分支名称</label>
			      <input id="gitNewBranchName" placeholder="例如：feature/login" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div id="git-new-branch-actions">
			      <button id="gitNewBranchCancelBtn" class="danger">取消</button>
			      <button id="gitNewBranchOkBtn" class="primary">创建并切换</button>
			    </div>
			  </div>

			  <!-- Git 回退弹窗（长按最新未推送提交） -->
			  <div id="git-reset-backdrop" aria-hidden="true"></div>
    <div id="git-reset-modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="row">
        <div class="title">回退到此提交</div>
        <button class="close" id="gitResetCloseBtn" title="Close">×</button>
      </div>
      <div id="gitResetDesc" class="desc"></div>
      <div class="actions">
        <button id="gitBranchFromCommitBtn">新分支</button>
        <button id="gitRevertBtn">Revert</button>
        <button id="gitResetSoftBtn" class="primary">软回退</button>
        <button id="gitResetHardBtn" class="danger">硬回退</button>
      </div>
    </div>

			  <!-- 指令集：新建弹窗 -->
			  <div id="cmdset-modal-backdrop" aria-hidden="true"></div>
			  <div id="cmdset-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="cmdset-modal-row">
			      <div class="cmdset-modal-title" id="cmdsetModalTitle">新建指令</div>
			      <button class="cmdset-modal-close" id="cmdsetModalCloseBtn" title="Close">×</button>
			    </div>
			    <div class="cmdset-field">
			      <label for="cmdsetNameInput">名称</label>
			      <input id="cmdsetNameInput" placeholder="例如：打开frp" spellcheck="false" autocapitalize="off" autocorrect="off" />
			    </div>
			    <div class="cmdset-field" id="cmdsetContentField">
			      <label for="cmdsetContentInput">内容</label>
			      <textarea id="cmdsetContentInput" placeholder="例如：start frp" spellcheck="false" autocapitalize="off" autocorrect="off"></textarea>
			    </div>
			    <div class="cmdset-field" id="cmdsetAutoSendField">
			      <label style="display:flex;align-items:center;gap:8px;">
			        <input type="checkbox" id="cmdsetAutoSendInput" style="width:16px;height:16px;" />
			        <span>创建后点击自动发送（会自动回车）</span>
			      </label>
			    </div>
			    <div class="cmdset-modal-actions" style="justify-content:space-between;">
			      <button id="cmdsetModalDeleteBtn" class="danger" style="margin-right:auto; display:none;">删除</button>
			      <div style="display:flex; gap:10px; margin-left:auto;">
			        <button id="cmdsetModalCancelBtn">取消</button>
			        <button id="cmdsetModalOkBtn" class="primary">确定</button>
			      </div>
			    </div>
			  </div>

			  <!-- 指令集：删除确认弹窗 -->
			  <div id="cmdset-confirm-backdrop" aria-hidden="true"></div>
			  <div id="cmdset-confirm-modal" role="dialog" aria-modal="true" aria-hidden="true">
			    <div class="cmdset-modal-row">
			      <div class="cmdset-modal-title">确认删除</div>
			      <button class="cmdset-modal-close" id="cmdsetConfirmCloseBtn" title="Close">×</button>
			    </div>
			    <div id="cmdsetConfirmText" style="font-size:13px; opacity:0.85; line-height:1.5;"></div>
			    <div class="cmdset-modal-actions">
			      <button id="cmdsetConfirmCancelBtn">取消</button>
			      <button id="cmdsetConfirmOkBtn" class="danger">删除</button>
			    </div>
			  </div>

			  <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
			  <!-- 可选：WebGL 渲染加速（加载失败时自动降级） -->
			  <script src="https://unpkg.com/xterm-addon-webgl/lib/xterm-addon-webgl.js"></script>
			  <script src="https://unpkg.com/codemirror@5.65.16/lib/codemirror.js"></script>
			  <script>
    // PWA全屏和隐藏地址栏功能
    function hideAddressBar() {
      // 强制滚动隐藏地址栏
      setTimeout(() => {
        window.scrollTo(0, 1);
        window.scrollTo(0, 0);
      }, 100);
      
      // 请求全屏模式
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(() => {
          // 全屏请求失败时的备用方案
          console.log('全屏模式请求被拒绝');
        });
      }
    }

    // 检测PWA模式
    function isPWA() {
      // 检查URL参数
      const urlParams = new URLSearchParams(window.location.search);
      const isPWAParam = urlParams.get('pwa') === 'true';
      const isSourcePWA = urlParams.get('source') === 'pwa';
      const isEdgeParam = urlParams.get('edge') === 'true';
      
      // 检查User Agent是否为Edge
      const isEdge = /Edg/i.test(navigator.userAgent);
      
      // 检查display-mode
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                          window.matchMedia('(display-mode: fullscreen)').matches ||
                          window.navigator.standalone === true;
      
      // PWA检测（支持新旧参数）
      const isPWAMode = isPWAParam || isSourcePWA || isStandalone;
      
      // Edge特殊检测
      const isEdgePWA = isEdge && (isPWAMode || isEdgeParam);
      
      return isPWAMode || isEdgePWA;
    }

    // Edge PWA模式下的特殊处理
    function applyEdgePWAStyles() {
      const isEdge = /Edg/i.test(navigator.userAgent);
      
      if (isEdge && isPWA()) {
        console.log('Edge PWA模式激活，应用特殊样式');
        
        // Edge专用样式
        const style = document.createElement('style');
        style.textContent = `
          /* Edge PWA 专用样式 */
          html {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
          }
          
          body {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            margin: 0 !important;
            padding: 0 !important;
          }
          
          /* 确保顶部工具栏在Edge中可见 */
          #top {
            position: relative !important;
            z-index: 1000 !important;
            display: flex !important;
            flex-shrink: 0 !important;
          }
          
	          /* removed: mobile toolbar */
          
          /* Edge 调整主内容区域 */
          #main {
            height: calc(100vh - 60px) !important;
            height: calc(100dvh - 60px) !important;
            overflow: hidden !important;
            flex: 1 !important;
            position: relative !important;
          }
          
          /* Edge 特殊处理 */
          @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
            body {
              -ms-content-zooming: none;
              -ms-user-select: none;
              -ms-touch-action: manipulation;
            }
          }
        `;
        document.head.appendChild(style);
        
        // 设置Edge PWA标识
        document.body.classList.add('edge-pwa-mode');
        document.documentElement.classList.add('edge-pwa-mode');
        
        // Edge特殊的全屏请求
        setTimeout(() => {
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(() => {
              console.log('Edge全屏请求被拒绝');
            });
          }
        }, 1000);
      }
    }

    // PWA模式下的特殊处理
    function applyPWAStyles() {
      if (isPWA()) {
        console.log('PWA模式激活，应用全屏样式');
        
        // 添加PWA专用样式
        const style = document.createElement('style');
        style.textContent = `
          html {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
          }
          
          body {
            overflow: hidden !important;
            height: 100vh !important;
            height: 100dvh !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            margin: 0 !important;
            /* 保留顶部工具栏空间 */
            padding: 0 !important;
          }
          
          /* 确保顶部工具栏可见 */
          #top {
            position: relative !important;
            z-index: 1000 !important;
            display: flex !important;
            flex-shrink: 0 !important;
          }
          
	          /* removed: mobile toolbar */
          
          /* 调整主内容区域 */
          #main {
            height: calc(100vh - 60px) !important;
            height: calc(100dvh - 60px) !important;
            overflow: hidden !important;
            flex: 1 !important;
          }
          
          /* 隐藏可能的浏览器UI */
          body::before {
            content: '';
            position: fixed;
            top: -100px;
            left: 0;
            right: 0;
            height: 100px;
            background: #0f1115;
            z-index: -1;
          }
          
          body::after {
            content: '';
            position: fixed;
            bottom: -100px;
            left: 0;
            right: 0;
            height: 100px;
            background: #0f1115;
            z-index: -1;
          }
        `;
        document.head.appendChild(style);
        
        // 设置PWA标识
        document.body.classList.add('pwa-mode');
        document.documentElement.classList.add('pwa-mode');
      }
    }

	    // 强制隐藏移动端地址栏和底部栏
	    function forceMobileFullscreen() {
	      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
	        let __lastAppliedViewportHeight = 0;
	        // 设置视口高度
	        const setViewportHeight = () => {
	          // 优先使用 VisualViewport：iOS/Android 的软键盘弹出通常只会触发 visualViewport.resize，
	          // 不一定会触发 window.resize；如果只用 innerHeight，终端区域不会跟着“变矮”，输入行就会被键盘挡住。
	          const vv = window.visualViewport;
	          const winH = Math.max(0, Math.floor(window.innerHeight || 0));
	          const vvH = Math.max(0, Math.floor(vv?.height || 0));
	          // Android Edge 等浏览器在页面初始化/切后台回前台/地址栏动画阶段，visualViewport.height 可能短暂变成极小值，
	          // 这会把 body 强制压到几像素，表现为“页面空白/被裁切”。这里给一个下限防抖。
	          const MIN_VALID_H = 180;
	          const height = (vvH >= MIN_VALID_H ? vvH : winH);
	          if (!height) return;
	          // 防抖：避免 visualViewport 的频繁微小抖动导致编辑器 refresh，从而出现“触底轻微回弹/跳动”
	          if (__lastAppliedViewportHeight && Math.abs(height - __lastAppliedViewportHeight) < 2) return;
	          __lastAppliedViewportHeight = height;

	          const vh = (height * 0.01);
	          document.documentElement.style.setProperty('--vh', `${vh}px`);

	          // 强制设置高度，驱动 #term-area 触发 ResizeObserver -> xterm resize
	          document.body.style.height = height + 'px';
	          document.documentElement.style.height = height + 'px';

	          // 编辑器同样需要跟随视口变化刷新，否则会出现顶部/底部被裁切、滚动高度不正确等问题
	          try { refreshAllEditors(); } catch {}
	        };
	        
	        setViewportHeight();
	        window.addEventListener('resize', setViewportHeight);

	        // 键盘弹出/收起时：更可靠的事件源
	        try {
	          const vv = window.visualViewport;
	          if (vv) {
	            vv.addEventListener('resize', setViewportHeight);
	            // 注意：Android Edge 上 visualViewport.scroll 可能在内容滚动时频繁触发，
	            // 会导致 setViewportHeight -> refreshAllEditors，从而出现“触底轻微回弹/跳动”。
	            // 键盘弹出/收起主要依赖 resize 已足够，因此不绑定 scroll。
	          }
	        } catch {}

	        // 终端聚焦时（点击输出区域会触发 xterm 的隐藏 textarea focus），再补几次延迟刷新，
	        // 适配不同浏览器键盘动画时序，确保输入行不被挡住。
	        const scheduleKeyboardRelayout = () => {
	          setViewportHeight();
	          setTimeout(setViewportHeight, 50);
	          setTimeout(setViewportHeight, 250);
	          setTimeout(() => {
	            try {
	              const s = getActive?.();
	              if (!s?.term) return;
	              // 如果当前在底部，尽量保持光标/输入行可见
	              if (isTermAtBottom(s.term) && typeof s.term.scrollToBottom === 'function') {
	                s.term.scrollToBottom();
	              }
	              s.resizeTerminal?.();
	            } catch {}
	          }, 80);
	        };

	        document.addEventListener('focusin', (e) => {
	          const t = e?.target;
	          if (t && t.classList && t.classList.contains('xterm-helper-textarea')) {
	            scheduleKeyboardRelayout();
	            // 兜底：部分机型/浏览器会重建 textarea，确保 IME 监听存在
	            try {
	              const s = getActive?.();
	              installImeWorkaround?.(s);
	            } catch {}
	          }
	        }, true);

	        // 在终端区域点击时也触发一次（某些机型 focusin 事件时机偏晚）
	        try {
	          document.getElementById('term-area')?.addEventListener('pointerdown', () => {
	            scheduleKeyboardRelayout();
	          }, { passive: true });
	        } catch {}

	        window.addEventListener('orientationchange', () => {
	          setTimeout(setViewportHeight, 100);
	          setTimeout(setViewportHeight, 500);
	        });
        
        // 多次尝试隐藏地址栏
        const hideAddressBarMultiple = () => {
          for (let i = 0; i < 10; i++) {
            setTimeout(() => {
              window.scrollTo(0, 1);
              setTimeout(() => window.scrollTo(0, 0), 10);
            }, i * 100);
          }
        };
        
        hideAddressBarMultiple();
        
        // 页面获得焦点时重新隐藏
        window.addEventListener('focus', hideAddressBarMultiple);
        window.addEventListener('pageshow', hideAddressBarMultiple);
        
        // 安卓特殊处理
        if (/Android/i.test(navigator.userAgent)) {
          // 强制全屏模式
          document.documentElement.style.overflow = 'hidden';
          document.body.style.overflow = 'hidden';
          
          // 尝试请求全屏
          const requestFullscreen = () => {
            const element = document.documentElement;
            if (element.requestFullscreen) {
              element.requestFullscreen().catch(() => {});
            } else if (element.webkitRequestFullscreen) {
              element.webkitRequestFullscreen().catch(() => {});
            } else if (element.mozRequestFullScreen) {
              element.mozRequestFullScreen().catch(() => {});
            } else if (element.msRequestFullscreen) {
              element.msRequestFullscreen().catch(() => {});
            }
          };
          
          // 延迟请求全屏
          setTimeout(requestFullscreen, 1000);
          
          // 用户交互后再次尝试
          document.addEventListener('touchstart', requestFullscreen, { once: true });
          document.addEventListener('click', requestFullscreen, { once: true });
        }
      }
    }

    // PWA安装提示
    let deferredPrompt;
    
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      
      // 显示安装提示
      const installBanner = document.createElement('div');
      installBanner.innerHTML = `
        <div style="position: fixed; top: 0; left: 0; right: 0; background: #2d8cff; color: white; padding: 10px; text-align: center; z-index: 1000;">
          <span>📱 添加到主屏幕以获得更好的体验</span>
          <button onclick="installPWA()" style="margin-left: 10px; background: white; color: #2d8cff; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">安装</button>
          <button onclick="this.parentElement.parentElement.remove()" style="margin-left: 5px; background: transparent; color: white; border: 1px solid white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">稍后</button>
        </div>
      `;
      document.body.appendChild(installBanner);
    });
    
    window.installPWA = async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        console.log(`PWA安装结果: ${outcome}`);
        deferredPrompt = null;
        
        // 移除安装横幅
        const banner = document.querySelector('[style*="position: fixed"]');
        if (banner) banner.parentElement.remove();
      }
    };
    
    // Register Service Worker (required for "Install/Add to Home screen" standalone PWA on Android Edge)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration.scope);
          })
          .catch((error) => {
            console.log('SW registration failed: ', error);
          });
      });
    }

    // 取消鉴权：不再需要 token
    const urlParams = new URLSearchParams(window.location.search);
    const authToken = urlParams.get('token');

	    // removed: mobile toolbar (copy/paste via side buttons)
	    function initMobileToolbar() {}

    // 显示提示消息
    function showToast(message) {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 1000;
        pointer-events: none;
        max-width: 80%;
        text-align: center;
      `;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    // 备用复制方法（使用传统方法）
    function fallbackCopyText(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      try {
        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);
        return successful;
      } catch (err) {
        document.body.removeChild(textArea);
        return false;
      }
    }

	    // 侧边栏折叠功能
	    const sidebar = document.getElementById('sidebar');
	    const toggleBtn = document.getElementById('toggle-sidebar');
	    // Default: collapsed when entering the page
	    let sidebarCollapsed = true;
	    sidebar.classList.toggle('collapsed', sidebarCollapsed);
	    document.body.classList.toggle('sidebar-collapsed', sidebarCollapsed);
	    toggleBtn.textContent = sidebarCollapsed ? '›' : '‹';
	    toggleBtn.title = sidebarCollapsed ? '展开侧边栏' : '折叠侧边栏';

	    toggleBtn.onclick = () => {
	      sidebarCollapsed = !sidebarCollapsed;
	      sidebar.classList.toggle('collapsed', sidebarCollapsed);
	      document.body.classList.toggle('sidebar-collapsed', sidebarCollapsed);
      toggleBtn.textContent = sidebarCollapsed ? '›' : '‹';
      toggleBtn.title = sidebarCollapsed ? '展开侧边栏' : '折叠侧边栏';
      
      // 侧边栏状态改变后，强制重新计算所有终端的尺寸
      setTimeout(() => {
        sessions.forEach(session => {
          if (session.resizeTerminal) {
            session.resizeTerminal();
          } else if (session.type === 'editor') {
            refreshEditorSession(session);
          }
        });
      }, 350); // 等待CSS动画完成
    };



	    // 键盘快捷键：Ctrl+B 切换侧边栏
	    document.addEventListener('keydown', (e) => {
	      if (e.ctrlKey && e.key === 'b') {
	        e.preventDefault();
	        toggleBtn.click();
	      }

	      // 编辑器快捷键：Ctrl+S 保存，Ctrl+W 关闭
	      if (e.ctrlKey && (e.key === 's' || e.key === 'S')) {
	        const s = getActive();
	        if (s?.type === 'editor') {
	          e.preventDefault();
	          saveEditorFile(s).catch(() => {});
	          return;
	        }
	      }
	      if (e.ctrlKey && (e.key === 'w' || e.key === 'W')) {
	        const s = getActive();
	        if (s?.type === 'editor') {
	          e.preventDefault();
	          closeEditor(s.id);
	          return;
	        }
	      }
	      
	      // 手机端额外快捷键
	      if (window.innerWidth <= 768) {
	        if (e.ctrlKey && e.key === 'c' && e.shiftKey) {
	          // Ctrl+Shift+C 复制
	          e.preventDefault();
	          try { window.__lanShellQuickActions?.copyLastOutput?.(); } catch {}
	        } else if (e.ctrlKey && e.key === 'v' && e.shiftKey) {
	          // Ctrl+Shift+V 粘贴
	          e.preventDefault();
	          try { window.__lanShellQuickActions?.pasteClipboard?.(); } catch {}
	        }
	      }
	    });

		    // 会话管理（以服务端为准：关闭=删除，刷新=恢复剩余会话）
		    const CLIENT_ID_KEY = 'lanshell_client_id';

		    function getClientId() {
		      try {
		        const existing = localStorage.getItem(CLIENT_ID_KEY);
		        if (existing) return existing;
		        const id =
		          (crypto && typeof crypto.randomUUID === 'function' && crypto.randomUUID()) ||
		          `${Date.now().toString(16)}-${Math.random().toString(16).slice(2)}`;
		        localStorage.setItem(CLIENT_ID_KEY, id);
		        return id;
		      } catch {
		        return `anon-${Date.now().toString(16)}-${Math.random().toString(16).slice(2)}`;
		      }
		    }

    const clientId = getClientId();

    let sessions = [];
    let activeId = null;
    let counter = 1;
    let showHiddenFiles = false;

    // 加载现有会话
	    async function loadExistingSessions() {
	      try {
	        const response = await fetch(
	          `/api/sessions?clientId=${encodeURIComponent(clientId)}&token=${encodeURIComponent(authToken)}`
	        );
	        if (response.ok) {
	          const data = await response.json();
	          return data.sessions;
	        }
      } catch (error) {
        console.error('加载会话失败:', error);
      }
      return [];
    }

    async function loadDir(p) {
      const res = await fetch(`/api/fs?path=${encodeURIComponent(p)}&token=${encodeURIComponent(authToken)}`);
      if (res.status === 401) {
        console.log('❌ 文件系统访问需要重新认证');
        showToast('🔐 登录已过期，请重新登录');
        setTimeout(() => {
          window.location.href = '/';
        }, 2000);
        return;
      }
      const data = await res.json();
      document.getElementById('path').value = data.cwd;
      const list = document.getElementById('list');
      list.innerHTML = '';

      // add parent shortcut if not root
      if (data.cwd !== data.root) {
        const parent = document.createElement('div');
        parent.textContent = '⬆️ ..';
        parent.className = 'item';
        parent.onclick = () => {
          const up = data.cwd.split('/').slice(0,-1).join('/') || '/';
          loadDir(up);
        };
        list.appendChild(parent);
      }
      data.items
        .filter(it => showHiddenFiles || !String(it?.name || '').startsWith('.'))
        .forEach(it => {
        const div = document.createElement('div');
        div.className = 'item';
        
        const icon = document.createElement('span');
        icon.textContent = it.isDir ? '📁' : (it.isExe ? '⚡' : '📄');
        div.appendChild(icon);
        
        const name = document.createElement('span');
        name.className = 'file-name';
        name.textContent = it.name;
        div.appendChild(name);
        
        const tag = document.createElement('span');
        tag.className = 'file-tag';
        tag.textContent = it.isDir ? 'dir' : (it.isExe ? 'exec' : `${it.size}B`);
        div.appendChild(tag);
        
        div.onclick = () => {
          // 长按菜单触发后，避免随后的 click 再执行“打开/进入”
          try {
            if (div.__lanFsLongPressFiredAt && (Date.now() - div.__lanFsLongPressFiredAt) < 800) return;
          } catch {}
          if (it.isDir) {
            const next = join(data.cwd, it.name);
            loadDir(next);
          } else if (it.isExe) {
            const confirmed = confirm(`在 ${data.cwd} 运行 ./${it.name} ?`);
            if (confirmed) createTerminal(data.cwd, `./${it.name}`);
          } else {
            // 桌面端：双击打开更符合习惯；移动端没有双击概念，因此单击也打开
            const full = join(data.cwd, it.name);
            if (isArchiveFileName(it.name)) {
              try { window.__lanShellOpenExtractModal?.({ archivePath: full, defaultDest: data.cwd }); } catch {}
            } else {
              openEditor(full);
            }
          }
        };

        // 桌面端双击打开文件编辑器（不影响目录单击进入）
        div.ondblclick = () => {
          try {
            if (div.__lanFsLongPressFiredAt && (Date.now() - div.__lanFsLongPressFiredAt) < 800) return;
          } catch {}
          if (!it.isDir && !it.isExe) {
            const full = join(data.cwd, it.name);
            if (isArchiveFileName(it.name)) {
              try { window.__lanShellOpenExtractModal?.({ archivePath: full, defaultDest: data.cwd }); } catch {}
            } else {
              openEditor(full);
            }
          }
        };

        // 长按/右键：弹出文件操作菜单
        installItemLongPress(div, {
          cwd: data.cwd,
          root: data.root,
          item: it,
          fullPath: join(data.cwd, it.name),
        });

        div.oncontextmenu = (e) => {
          e.preventDefault();
          e.stopPropagation();
          try { openOpMenu({ cwd: data.cwd, item: it, fullPath: join(data.cwd, it.name) }); } catch {}
          return false;
        };
        list.appendChild(div);
      });
    }

    function join(base, name){
      if (base === '/') return `/${name}`;
      return base.replace(/\/$/, '') + '/' + name;
    }

	    function isArchiveFileName(name) {
	      const n = String(name || '').toLowerCase();
	      return (
	        n.endsWith('.zip') ||
	        n.endsWith('.tar') ||
	        n.endsWith('.tar.gz') ||
	        n.endsWith('.tgz') ||
	        n.endsWith('.tar.bz2') ||
	        n.endsWith('.tbz2') ||
	        n.endsWith('.tar.xz') ||
	        n.endsWith('.txz')
	      );
	    }

	    function dirname(p) {
	      try {
	        const s = String(p || '');
	        const i = s.lastIndexOf('/');
	        if (i <= 0) return '/';
	        return s.slice(0, i) || '/';
	      } catch {
	        return '.';
	      }
	    }

	    function installHiddenToggle() {
	      const btn = document.getElementById('toggleHiddenBtn');
	      if (!btn) return;

	      const KEY = 'lanshell_show_hidden';
	      try {
	        const saved = localStorage.getItem(KEY);
	        showHiddenFiles = saved === '1';
	      } catch {}

	      function sync() {
	        btn.textContent = showHiddenFiles ? '隐藏隐藏' : '显示隐藏';
	        btn.title = showHiddenFiles ? '不显示以 . 开头的文件' : '显示以 . 开头的文件';
	      }
	      sync();

	      btn.onclick = () => {
	        showHiddenFiles = !showHiddenFiles;
	        try { localStorage.setItem(KEY, showHiddenFiles ? '1' : '0'); } catch {}
	        sync();
	        loadDir(document.getElementById('path')?.value || '.');
	      };
	    }

	    // -----------------------
	    // 解压（归档）
	    // -----------------------
	    function installExtractModal() {
	      const backdrop = document.getElementById('extract-modal-backdrop');
	      const modal = document.getElementById('extract-modal');
	      const closeBtn = document.getElementById('extractModalCloseBtn');
	      const cancelBtn = document.getElementById('extractCancelBtn');
	      const okBtn = document.getElementById('extractOkBtn');
	      const archiveInput = document.getElementById('extractArchivePath');
	      const destInput = document.getElementById('extractDestPath');
	      const overwriteInput = document.getElementById('extractOverwrite');
	      const pickBtn = document.getElementById('pickDestBtn');

	      const picker = document.getElementById('dirpicker');
	      const pickerPath = document.getElementById('dirpickerPath');
	      const pickerList = document.getElementById('dirpicker-list');
	      const pickerCancel = document.getElementById('dirpickerCancelBtn');
	      const pickerOk = document.getElementById('dirpickerOkBtn');

	      if (!backdrop || !modal) return;

	      let currentPick = '.';

	      async function renderPickerDir(p) {
	        const res = await fetch(`/api/fs?path=${encodeURIComponent(p)}&token=${encodeURIComponent(authToken)}`);
	        if (!res.ok) {
	          showToast('❌ 无法读取目录');
	          return;
	        }
	        const data = await res.json();
	        const cwd = data.cwd;
	        currentPick = cwd;
	        pickerPath.value = cwd;
	        pickerList.innerHTML = '';

	        if (data.cwd !== data.root) {
	          const up = document.createElement('div');
	          up.className = 'dir-item';
	          up.textContent = '⬆️ ..';
	          up.onclick = () => {
	            const parent = cwd.split('/').slice(0, -1).join('/') || '/';
	            renderPickerDir(parent);
	          };
	          pickerList.appendChild(up);
	        }

	        (data.items || []).forEach((it) => {
	          if (!it?.isDir) return;
	          const row = document.createElement('div');
	          row.className = 'dir-item';
	          row.innerHTML = `<span>📁</span><span style="flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${it.name}</span>`;
	          row.onclick = () => renderPickerDir(join(cwd, it.name));
	          pickerList.appendChild(row);
	        });
	      }

	      function openPicker(initial) {
	        picker.classList.add('open');
	        currentPick = initial || '.';
	        pickerPath.value = currentPick;
	        renderPickerDir(currentPick).catch(() => {});
	      }

	      function closePicker() {
	        picker.classList.remove('open');
	      }

	      function open({ archivePath, defaultDest } = {}) {
	        archiveInput.value = archivePath || '';
	        destInput.value = defaultDest || dirname(archivePath || '') || '.';
	        overwriteInput.checked = false;
	        backdrop.classList.add('open');
	        modal.classList.add('open');
	        modal.setAttribute('aria-hidden', 'false');
	        backdrop.setAttribute('aria-hidden', 'false');
	        closePicker();
	      }

	      function close() {
	        closePicker();
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	        modal.setAttribute('aria-hidden', 'true');
	        backdrop.setAttribute('aria-hidden', 'true');
	      }

	      async function doExtract() {
	        const archive = (archiveInput.value || '').trim();
	        const dest = (destInput.value || '').trim();
	        if (!archive) { showToast('⚠️ 缺少压缩包路径'); return; }
	        if (!dest) { showToast('⚠️ 请选择解压目录'); return; }

	        okBtn.disabled = true;
	        cancelBtn.disabled = true;
	        pickBtn.disabled = true;
	        showToast('⏳ 开始解压...');
	        try {
	          const res = await fetch(`/api/archive/extract?token=${encodeURIComponent(authToken)}`, {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ path: archive, dest, overwrite: Boolean(overwriteInput.checked) }),
	          });
	          if (!res.ok) {
	            let msg = `解压失败（${res.status}）`;
	            try { const j = await res.json(); if (j?.error) msg = `解压失败：${j.error}`; } catch {}
	            showToast(`❌ ${msg}`);
	            return;
	          }
	          showToast('✅ 解压完成');
	          close();
	          try { await loadDir(document.getElementById('path')?.value || '.'); } catch {}
	        } catch (e) {
	          showToast(`❌ 解压失败：${e?.message || e}`);
	        } finally {
	          okBtn.disabled = false;
	          cancelBtn.disabled = false;
	          pickBtn.disabled = false;
	        }
	      }

	      backdrop.onclick = close;
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };
	      cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };
	      okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); doExtract(); };
	      pickBtn.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        const init = (destInput.value || '').trim() || '.';
	        openPicker(init);
	      };

	      pickerCancel.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closePicker(); };
	      pickerOk.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        destInput.value = currentPick;
	        closePicker();
	      };

	      document.addEventListener('keydown', (e) => {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
	          close();
	        }
	      }, true);

	      window.__lanShellOpenExtractModal = open;
	    }

	    // -----------------------
	    // 文件操作：长按菜单 + 复制/剪切/重命名/删除/粘贴
	    // -----------------------
	    let fsClipboard = null; // { mode:'copy'|'move', src, name, isDir }

	    function openOpMenu({ cwd, item, fullPath }) {
	      const backdrop = document.getElementById('op-modal-backdrop');
	      const modal = document.getElementById('op-modal');
	      const closeBtn = document.getElementById('opCloseBtn');
	      const title = document.getElementById('op-title');
	      const pathEl = document.getElementById('op-path');
	      const actions = document.getElementById('op-actions');
	      if (!backdrop || !modal) return;

	      function close({ clearClipboard = false } = {}) {
	        if (clearClipboard) fsClipboard = null;
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	      }

	      backdrop.onclick = close;
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };

	      title.textContent = item.isDir ? '文件夹操作' : '文件操作';
	      pathEl.textContent = fullPath;
	      actions.innerHTML = '';

	      function addBtn(text, cls, handler) {
	        const b = document.createElement('button');
	        b.textContent = text;
	        if (cls) b.className = cls;
	        b.onclick = (e) => { e.preventDefault(); e.stopPropagation(); handler(); };
	        actions.appendChild(b);
	      }

	      addBtn('重命名', '', () => {
	        close();
	        const nn = prompt('输入新名称', item.name);
	        if (!nn || nn.trim() === item.name) return;
	        renameEntry(fullPath, nn.trim());
	      });

	      addBtn('复制', '', () => {
	        close();
	        // 立即弹出目录选择器；同时把剪贴板同步为备用
	        fsClipboard = { mode: 'copy', src: fullPath, name: item.name, isDir: !!item.isDir };
	        openXferModal({
	          mode: 'copy',
	          src: fullPath,
	          defaultDest: cwd,
	          defaultName: item.name,
	        });
	      });

	      addBtn('剪切', '', () => {
	        close();
	        fsClipboard = { mode: 'move', src: fullPath, name: item.name, isDir: !!item.isDir };
	        openXferModal({
	          mode: 'move',
	          src: fullPath,
	          defaultDest: cwd,
	          defaultName: item.name,
	        });
	      });

	      addBtn('删除', 'danger', () => {
	        close();
	        const ok = confirm(`确定删除：${fullPath} ?\n该操作不可撤销。`);
	        if (!ok) return;
	        deleteEntry(fullPath);
	      });

	      if (isArchiveFileName(item.name)) {
	        addBtn('解压', 'primary', () => {
	          close();
	          try { window.__lanShellOpenExtractModal?.({ archivePath: fullPath, defaultDest: cwd }); } catch {}
	        });
	      }

	      // 若剪贴板有内容且当前对象为目录，可在此目录中粘贴
	      if (fsClipboard && item.isDir) {
	        addBtn('粘贴到此', 'primary', () => {
	          close();
	          openXferModal({
	            mode: fsClipboard.mode,
	            src: fsClipboard.src,
	            defaultDest: fullPath,
	            defaultName: fsClipboard.name,
	          });
	        });
	      }

	      backdrop.classList.add('open');
	      modal.classList.add('open');

	      document.addEventListener('keydown', function esc(e) {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
          close();
	          document.removeEventListener('keydown', esc, true);
	        }
	      }, true);
	    }

	    function installItemLongPress(el, ctx) {
	      let timer = null;
	      const delay = 520;
	      const MOVE_CANCEL_PX = 12;
	      let startX = 0;
	      let startY = 0;
	      el.addEventListener('touchstart', (e) => {
	        const t = e.touches?.[0];
	        if (!t) return;
	        startX = t.clientX;
	        startY = t.clientY;
	        timer = setTimeout(() => {
	          try { openOpMenu(ctx); } catch {}
	          try { el.__lanFsLongPressFiredAt = Date.now(); } catch {}
	        }, delay);
	      }, { passive: true });
	      el.addEventListener('touchmove', (e) => {
	        if (!timer) return;
	        const t = e.touches?.[0];
	        if (!t) return;
	        const dx = Math.abs(t.clientX - startX);
	        const dy = Math.abs(t.clientY - startY);
	        if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) {
	          clearTimeout(timer);
	          timer = null;
	        }
	      }, { passive: true });
	      el.addEventListener('touchend', () => { if (timer) clearTimeout(timer); timer = null; }, { passive: true });
	      el.addEventListener('touchcancel', () => { if (timer) clearTimeout(timer); timer = null; }, { passive: true });
	      // 兼容桌面长按（mouse）
	      el.addEventListener('mousedown', (e) => {
	        if (e.buttons !== 1) return;
	        timer = setTimeout(() => {
	          try { openOpMenu(ctx); } catch {}
	        }, delay);
	      });
	      el.addEventListener('mouseup', () => { if (timer) clearTimeout(timer); timer = null; });
	      el.addEventListener('mouseleave', () => { if (timer) clearTimeout(timer); timer = null; });
	    }

	    async function deleteEntry(pathStr) {
	      try {
	        const res = await fetch(`/api/fs/delete?token=${encodeURIComponent(authToken)}`, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({ path: pathStr }),
	        });
	        if (!res.ok) {
	          let msg = `删除失败（${res.status}）`;
	          try { const j = await res.json(); if (j?.error) msg = `删除失败：${j.error}`; } catch {}
	          showToast(`❌ ${msg}`);
	          return;
	        }
	        showToast('✅ 已删除');
	        await loadDir(document.getElementById('path')?.value || '.');
	      } catch (e) {
	        showToast(`❌ 删除失败：${e?.message || e}`);
	      }
	    }

	    async function renameEntry(pathStr, newName) {
	      try {
	        const res = await fetch(`/api/fs/rename?token=${encodeURIComponent(authToken)}`, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({ path: pathStr, newName }),
	        });
	        if (!res.ok) {
	          let msg = `重命名失败（${res.status}）`;
	          try { const j = await res.json(); if (j?.error) msg = `重命名失败：${j.error}`; } catch {}
	          showToast(`❌ ${msg}`);
	          return;
	        }
	        showToast('✅ 已重命名');
	        await loadDir(document.getElementById('path')?.value || '.');
	      } catch (e) {
	        showToast(`❌ 重命名失败：${e?.message || e}`);
	      }
	    }

	    function openXferModal({ mode, src, defaultDest, defaultName } = {}) {
	      const backdrop = document.getElementById('xfer-modal-backdrop');
	      const modal = document.getElementById('xfer-modal');
	      const closeBtn = document.getElementById('xferCloseBtn');
	      const cancelBtn = document.getElementById('xferCancelBtn');
	      const okBtn = document.getElementById('xferOkBtn');
	      const title = document.getElementById('xfer-title');
	      const srcInput = document.getElementById('xfer-src');
	      const destDirInput = document.getElementById('xfer-dest-dir');
	      const destNameInput = document.getElementById('xfer-dest-name');
	      const conflictSel = document.getElementById('xfer-conflict');
	      const dirList = document.getElementById('xfer-dir-list');

	      if (!backdrop || !modal) return;

	      let browsing = defaultDest || '.';

	      async function renderDir(dir) {
	        const res = await fetch(`/api/fs?path=${encodeURIComponent(dir)}&token=${encodeURIComponent(authToken)}`);
	        if (!res.ok) {
	          showToast('❌ 读取目录失败');
	          return;
	        }
          const data = await res.json();
	        browsing = data.cwd;
	        destDirInput.value = browsing;
	        dirList.innerHTML = '';
	        if (data.cwd !== data.root) {
	          const up = document.createElement('div');
	          up.className = 'dir-item';
	          up.textContent = '⬆️ ..';
	          up.onclick = () => {
	            const parent = browsing.split('/').slice(0, -1).join('/') || '/';
	            renderDir(parent);
	          };
	          dirList.appendChild(up);
	        }
	        (data.items || []).forEach((it) => {
	          if (!it?.isDir) return;
	          const row = document.createElement('div');
	          row.className = 'dir-item';
	          row.innerHTML = `<span>📁</span><span style="flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${it.name}</span>`;
	          row.onclick = () => renderDir(join(browsing, it.name));
	          dirList.appendChild(row);
	        });
	      }

	      function close() {
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	      }

	      async function submit() {
	        const destDir = (destDirInput.value || '').trim() || '.';
	        const destName = (destNameInput.value || '').trim() || defaultName || '';
	        if (!src || !destDir) { showToast('⚠️ 参数缺失'); return; }

	        okBtn.disabled = true; cancelBtn.disabled = true;
	        try {
	          const payload = { src, destDir, destName, conflict: conflictSel.value };
	          const api = mode === 'move' ? '/api/fs/move' : '/api/fs/copy';
	          const res = await fetch(`${api}?token=${encodeURIComponent(authToken)}`, {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify(payload),
	          });
	          if (!res.ok) {
	            let msg = `${mode === 'move' ? '移动' : '复制'}失败（${res.status}）`;
	            try { const j = await res.json(); if (j?.error) msg = `${mode === 'move' ? '移动' : '复制'}失败：${j.error}`; } catch {}
	            showToast(`❌ ${msg}`);
	            return;
	          }
	          showToast(mode === 'move' ? '✅ 已移动' : '✅ 已复制');
	          fsClipboard = null; // 剪切完成后清空
	          close({ clearClipboard: true });
	          await loadDir(document.getElementById('path')?.value || '.');
	        } catch (e) {
	          showToast(`❌ ${mode === 'move' ? '移动' : '复制'}失败：${e?.message || e}`);
	        } finally {
	          okBtn.disabled = false; cancelBtn.disabled = false;
	        }
	      }

	      title.textContent = mode === 'move' ? '移动到...' : '复制到...';
	      srcInput.value = src || '';
	      destNameInput.value = defaultName || '';
	      conflictSel.value = 'error';
	      backdrop.classList.add('open');
	      modal.classList.add('open');
	      renderDir(defaultDest || '.');

	      backdrop.onclick = () => close({ clearClipboard: true });
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close({ clearClipboard: true }); };
	      cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close({ clearClipboard: true }); };
	      okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); submit(); };

	      document.addEventListener('keydown', function esc(e) {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
	          close({ clearClipboard: true });
	          document.removeEventListener('keydown', esc, true);
	        }
	      }, true);
	    }

	    // -----------------------
	    // 文件创建/上传
	    // -----------------------
	    function installFileModal() {
	      const newFileBtn = document.getElementById('newFileBtn');
	      const backdrop = document.getElementById('file-modal-backdrop');
	      const modal = document.getElementById('file-modal');
	      const closeBtn = document.getElementById('fileModalCloseBtn');
	      const dirInput = document.getElementById('fileModalDir');
	      const nameInput = document.getElementById('newEntryNameInput');
	      const createBtn = document.getElementById('createEmptyFileBtn');
	      const createDirBtn = document.getElementById('createEmptyDirBtn');
	      const uploadBtn = document.getElementById('uploadBtn');
	      const uploadInput = document.getElementById('uploadFileInput');

	      if (!newFileBtn || !backdrop || !modal) return;

	      function open() {
	        try {
	          const cwd = document.getElementById('path')?.value || '.';
	          dirInput.value = cwd;
	        } catch {}
	        backdrop.classList.add('open');
	        modal.classList.add('open');
	        modal.setAttribute('aria-hidden', 'false');
	        backdrop.setAttribute('aria-hidden', 'false');
	        setTimeout(() => { try { nameInput?.focus?.(); } catch {} }, 0);
	      }

	      function close() {
	        backdrop.classList.remove('open');
	        modal.classList.remove('open');
	        modal.setAttribute('aria-hidden', 'true');
	        backdrop.setAttribute('aria-hidden', 'true');
	      }

	      newFileBtn.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        open();
	      };
	      backdrop.onclick = close;
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); close(); };

	      async function refreshDir() {
	        try {
	          const p = document.getElementById('path')?.value || '.';
	          await loadDir(p);
	        } catch {}
	      }

	      createBtn.onclick = async (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        const dir = (dirInput.value || '').trim() || '.';
	        const name = (nameInput.value || '').trim();
	        if (!name) {
	          showToast('⚠️ 请输入文件名');
	          return;
	        }
	        const full = join(dir, name);
	        try {
	          const res = await fetch(`/api/file?token=${encodeURIComponent(authToken)}`, {
	            method: 'PUT',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ path: full, content: '' }),
	          });
	          if (!res.ok) {
	            let msg = `新建失败（${res.status}）`;
	            try { const j = await res.json(); if (j?.error) msg = `新建失败：${j.error}`; } catch {}
	            showToast(`❌ ${msg}`);
	            return;
	          }
	          showToast('✅ 已新建文件');
	          close();
	          await refreshDir();
	          openEditor(full);
	        } catch (err) {
	          showToast(`❌ 新建失败：${err?.message || err}`);
	        }
	      };

	      createDirBtn.onclick = async (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        const dir = (dirInput.value || '').trim() || '.';
	        const name = (nameInput.value || '').trim();
	        if (!name) {
	          showToast('⚠️ 请输入文件夹名');
	          return;
	        }
	        try {
	          const res = await fetch(`/api/fs/mkdir?token=${encodeURIComponent(authToken)}`, {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ dir, name }),
	          });
	          if (!res.ok) {
	            let msg = `新建文件夹失败（${res.status}）`;
	            try { const j = await res.json(); if (j?.error) msg = `新建文件夹失败：${j.error}`; } catch {}
	            showToast(`❌ ${msg}`);
	            return;
	          }
	          showToast('✅ 已新建文件夹');
	          close();
	          await refreshDir();
	        } catch (err) {
	          showToast(`❌ 新建文件夹失败：${err?.message || err}`);
	        }
	      };

	      uploadBtn.onclick = (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        try { uploadInput.value = ''; } catch {}
	        uploadInput.click();
	      };

	      uploadInput.onchange = async () => {
	        const file = uploadInput.files?.[0];
	        if (!file) return;
	        const dir = (dirInput.value || '').trim() || '.';
	        const name = file.name || 'upload.bin';
	        try {
	          async function doUploadRaw({ overwrite = false } = {}) {
	            const q = new URLSearchParams({
	              dir,
	              name,
	              overwrite: overwrite ? '1' : '0',
	              token: authToken || '',
	            });
	            const res = await fetch(`/api/upload-raw?${q.toString()}`, {
	              method: 'POST',
	              headers: { 'Content-Type': 'application/octet-stream' },
	              body: file,
	            });
	            if (res.status === 409) return { ok: false, conflict: true };
	            if (!res.ok) {
	              let msg = `上传失败（${res.status}）`;
	              try { const j = await res.json(); if (j?.error) msg = `上传失败：${j.error}`; } catch {}
	              showToast(`❌ ${msg}`);
	              return { ok: false, conflict: false };
	            }
	            return { ok: true };
	          }

	          const r1 = await doUploadRaw({ overwrite: false });
	          if (!r1.ok && r1.conflict) {
	            const ok = confirm(`文件已存在：${name}\n\n“确定”=覆盖\n“取消”=不上传`);
	            if (!ok) return;
	            const r2 = await doUploadRaw({ overwrite: true });
	            if (!r2.ok) return;
	          } else if (!r1.ok) {
	            return;
	          }

	          showToast('✅ 上传成功');
	          close();
	          await refreshDir();
	        } catch (err) {
	          showToast(`❌ 上传失败：${err?.message || err}`);
	        }
	      };

	      // ESC 关闭
	      document.addEventListener('keydown', (e) => {
	        if (e.key === 'Escape' && modal.classList.contains('open')) {
	          e.preventDefault();
	          close();
	        }
	      }, true);
	    }

	    // -----------------------
	    // 文本编辑器（CodeMirror）
	    // -----------------------
	    let editorCounter = 1;

	    function basename(p) {
	      try {
	        const s = String(p || '');
	        const i = s.lastIndexOf('/');
	        return i >= 0 ? s.slice(i + 1) : s;
	      } catch {
	        return String(p || '');
	      }
	    }

	    function findEditorByPath(filePath) {
	      return sessions.find(s => s?.type === 'editor' && s.filePath === filePath);
	    }

	    function updateEditorTabTitle(s) {
	      if (!s?.tab) return;
	      const title = s.displayName || basename(s.filePath);
	      // tab 的结构是：文本节点 + close span；这里直接改第一个 child 的 textContent 更稳定
	      try {
	        const textNode = s.tab.childNodes?.[0];
	        if (textNode) textNode.textContent = s.dirty ? `${title} *` : title;
	        else s.tab.textContent = s.dirty ? `${title} *` : title;
	      } catch {
	        s.tab.textContent = s.dirty ? `${title} *` : title;
	      }
	    }

	    async function loadEditorFile(s) {
	      if (!s?.filePath) return false;
	      try {
	        const res = await fetch(`/api/file?path=${encodeURIComponent(s.filePath)}&token=${encodeURIComponent(authToken)}`);
	        if (!res.ok) {
	          let msg = `打开失败（${res.status}）`;
	          try {
	            const j = await res.json();
	            if (j?.error) msg = `打开失败：${j.error}`;
	          } catch {}
	          showToast(`❌ ${msg}`);
	          return false;
	        }
	        const data = await res.json();
	        s._suppressDirty = true;
	        s.cm.setValue(data?.content ?? '');
	        s.cm.setCursor({ line: 0, ch: 0 });
	        s.cm.scrollTo(0, 0);
	        s._suppressDirty = false;
	        s.dirty = false;
	        s.mtimeMs = data?.mtimeMs;
	        s.size = data?.size;
	        updateEditorTabTitle(s);
	        try { s.titleEl.textContent = data?.path || s.filePath; } catch {}
	        return true;
	      } catch (e) {
	        showToast(`❌ 打开失败：${e?.message || e}`);
	        return false;
	      }
	    }

	    async function saveEditorFile(s, { force = false } = {}) {
	      if (!s?.filePath || !s?.cm) return false;
	      try {
	        const payload = {
	          path: s.filePath,
	          content: s.cm.getValue(),
	        };
	        if (!force) payload.mtimeMs = s.mtimeMs;

	        const res = await fetch(`/api/file?token=${encodeURIComponent(authToken)}`, {
	          method: 'PUT',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify(payload),
	        });

	        if (res.status === 409) {
	          // 乐观锁冲突：提示覆盖或重载
	          let currentMtimeMs = null;
	          try {
	            const j = await res.json();
	            currentMtimeMs = j?.currentMtimeMs ?? null;
	          } catch {}
	          const ok = confirm('文件已在磁盘上被修改。\n\n“确定”=强制覆盖保存\n“取消”=不保存（建议点“重载”再对比）');
	          if (ok) return await saveEditorFile(s, { force: true });
	          showToast('⚠️ 已取消保存');
	          return false;
	        }

	        if (!res.ok) {
	          let msg = `保存失败（${res.status}）`;
	          try {
	            const j = await res.json();
	            if (j?.error) msg = `保存失败：${j.error}`;
	          } catch {}
	          showToast(`❌ ${msg}`);
	          return false;
	        }

	        const data = await res.json();
	        s.dirty = false;
	        s.mtimeMs = data?.mtimeMs;
	        s.size = data?.size;
	        updateEditorTabTitle(s);
	        showToast('✅ 已保存');
	        return true;
	      } catch (e) {
	        showToast(`❌ 保存失败：${e?.message || e}`);
	        return false;
	      }
	    }

	    function removeEditor(id) {
	      const idx = sessions.findIndex(s => s.id === id);
	      if (idx === -1) return;
	      const s = sessions[idx];
	      try { s.cm?.toTextArea?.(); } catch {}
	      try { s.pane?.remove?.(); } catch {}
	      try { s.tab?.remove?.(); } catch {}
	      sessions.splice(idx, 1);
	      if (activeId === id) {
	        if (sessions.length) setActive(sessions[0].id);
	        else activeId = null;
	      }
	    }

	    function closeEditor(id) {
	      const s = sessions.find(s => s.id === id);
	      if (!s) return;
	      if (s.dirty) {
	        const ok = confirm('文件尚未保存，确定关闭吗？');
	        if (!ok) return;
	      }
	      removeEditor(id);
	    }

	    async function openEditor(filePath) {
	      const existing = findEditorByPath(filePath);
	      if (existing) {
	        setActive(existing.id);
	        try { existing.cm.focus(); } catch {}
	        return existing;
	      }

	      if (typeof CodeMirror !== 'function') {
	        showToast('❌ 编辑器组件未加载（请检查网络/CDN）');
	        return null;
	      }

	      const id = `edit-${editorCounter++}`;
	      const tabs = document.getElementById('tabs');
	      const tab = document.createElement('div');
	      tab.className = 'tab';
	      tab.appendChild(document.createTextNode(basename(filePath)));
	      const close = document.createElement('span');
	      close.className = 'close';
	      close.textContent = '×';
	      close.onclick = (e) => { e.stopPropagation(); closeEditor(id); };
	      tab.appendChild(close);
	      tab.onclick = () => setActive(id);
	      tabs.appendChild(tab);

	      const pane = document.createElement('div');
	      pane.className = 'editor-pane';
	      const toolbar = document.createElement('div');
	      toolbar.className = 'editor-toolbar';
	      const titleEl = document.createElement('div');
	      titleEl.className = 'editor-title';
	      titleEl.textContent = filePath;
	      const actions = document.createElement('div');
	      actions.className = 'editor-actions';
	      const saveBtn = document.createElement('button');
	      saveBtn.className = 'mini-btn';
	      saveBtn.textContent = '保存';
	      const reloadBtn = document.createElement('button');
	      reloadBtn.className = 'mini-btn secondary';
	      reloadBtn.textContent = '重载';
	      const closeBtn = document.createElement('button');
	      closeBtn.className = 'mini-btn danger';
	      closeBtn.textContent = '关闭';
	      actions.appendChild(saveBtn);
	      actions.appendChild(reloadBtn);
	      actions.appendChild(closeBtn);
	      toolbar.appendChild(titleEl);
	      toolbar.appendChild(actions);
	      const body = document.createElement('div');
	      body.className = 'editor-body';
	      pane.appendChild(toolbar);
	      pane.appendChild(body);
	      document.getElementById('term-area').appendChild(pane);

      const cm = CodeMirror(body, {
        value: '',
        lineNumbers: true,
        theme: 'vsc-dark-plus',
        indentUnit: 2,
        tabSize: 2,
        lineWrapping: false,
        viewportMargin: 20,
      });
	      try { cm.setSize('100%', '100%'); } catch {}

	      const session = {
	        type: 'editor',
	        id,
	        filePath,
	        displayName: basename(filePath),
	        tab,
	        pane,
	        cm,
	        titleEl,
	        dirty: false,
	        _suppressDirty: false,
	        mtimeMs: null,
	        size: null,
	      };
	      sessions.push(session);

	      cm.on('change', () => {
	        if (session._suppressDirty) return;
	        if (!session.dirty) {
	          session.dirty = true;
	          updateEditorTabTitle(session);
	        }
	      });

	      saveBtn.onclick = async (e) => { e.preventDefault(); e.stopPropagation(); await saveEditorFile(session); };
	      reloadBtn.onclick = async (e) => {
	        e.preventDefault();
	        e.stopPropagation();
	        if (session.dirty) {
	          const ok = confirm('当前有未保存修改，仍要重载吗？');
	          if (!ok) return;
	        }
	        await loadEditorFile(session);
	      };
	      closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeEditor(id); };

	      setActive(id);
	      const ok = await loadEditorFile(session);
	      if (!ok) {
	        // 打开失败时自动回收 tab/pane，避免留下空白窗口
	        removeEditor(id);
	        return null;
	      }
	      try { cm.focus(); } catch {}
	      return session;
	    }

	    // 将后端 PTY 输出做“合帧/合批”写入，避免长对话下高频 term.write 导致滚动卡顿
	    function isTermAtBottom(term) {
	      try {
	        const buf = term?.buffer?.active;
	        if (!buf) return true;
	        const viewportY = (typeof buf.viewportY === 'number') ? buf.viewportY : buf.baseY;
	        return viewportY === buf.baseY;
	      } catch {
	        return true;
	      }
	    }

	    function scheduleTermFlush(session) {
	      try {
	        if (!session?.term) return;
	        if (session._termFlushScheduled) return;
	        session._termFlushScheduled = true;

	        const active = session.id === activeId;
	        const fast = active && isTermAtBottom(session.term) && !document.hidden;

	        if (fast && typeof requestAnimationFrame === 'function') {
	          requestAnimationFrame(() => {
	            session._termFlushScheduled = false;
	            flushTermWrites(session);
	          });
	        } else {
	          const delay = document.hidden ? 200 : 80;
	          session._termFlushTimer = setTimeout(() => {
	            session._termFlushScheduled = false;
	            flushTermWrites(session);
	          }, delay);
	        }
	      } catch {}
	    }

	    function flushTermWrites(session) {
	      try {
	        if (!session?.term) return;
	        if (session._termWriting) return;
	        const data = session._pendingTermWrites;
	        if (!data) return;
	        session._pendingTermWrites = '';
	        session._termWriting = true;
	        session.term.write(data, () => {
	          session._termWriting = false;
	          if (session._pendingTermWrites) scheduleTermFlush(session);
	        });
	      } catch {
	        // 如果 write 回调异常，确保不会卡死在 writing 状态
	        try { session._termWriting = false; } catch {}
	      }
	    }

		    function queueTermWrite(session, chunk) {
		      try {
		        if (!session?.term) return;
		        if (!chunk) return;
		        session._pendingTermWrites = (session._pendingTermWrites || '') + chunk;

	        // 浏览器/设备性能不足时，优先加快刷新，避免待写入队列无界增长导致更卡
	        if (!session._termWriting && session._pendingTermWrites.length > 256 * 1024) {
	          flushTermWrites(session);
	          return;
	        }
	        scheduleTermFlush(session);
		      } catch {}
		    }

		    // 手机输入法（IME）兼容：
		    // 某些输入法在输入智能引号等字符时，会在 composing 阶段反复“整段重发”，
		    // 造成每输入一个字符就把之前的内容再次发送到后端（看起来像重复粘贴）。
		    function installImeWorkaround(session) {
		      try {
		        if (!session?.pane || session._imeInstalled) return;
		        const ta = session.pane.querySelector('.xterm-helper-textarea');
		        if (!ta) return;

		        session._imeInstalled = true;
		        session._xtermTextarea = ta;
		        session._imeComposing = false;
		        session._imeLastData = '';
		        session._imeDedupeUntil = 0;
		        session._imeProblemModeUntil = 0;

		        function clearTextareaSoon() {
		          try {
		            if (!session._xtermTextarea) return;
		            // 不要在 composing 中强行清空，否则会打断输入法候选/联想。
		            if (session._imeComposing) return;
		            // 用 0ms 延迟，避免与 xterm 内部事件顺序冲突
		            setTimeout(() => {
		              try {
		                if (session._imeComposing) return;
		                session._xtermTextarea.value = '';
		                // 某些浏览器需要显式重置 selection，避免输入法继续基于旧文本做“整段重发”
		                if (typeof session._xtermTextarea.setSelectionRange === 'function') {
		                  session._xtermTextarea.setSelectionRange(0, 0);
		                }
		              } catch {}
		            }, 0);
		          } catch {}
		        }

		        ta.addEventListener(
		          'compositionstart',
		          () => {
		            session._imeComposing = true;
		            session._imeLastData = '';
		            session._imeDedupeUntil = Date.now() + 20000;
		          },
		          { passive: true }
		        );

		        ta.addEventListener(
		          'compositionupdate',
		          () => {
		            session._imeComposing = true;
		            session._imeDedupeUntil = Date.now() + 20000;
		          },
		          { passive: true }
		        );

		        ta.addEventListener(
		          'compositionend',
		          () => {
		            session._imeComposing = false;
		            session._imeLastData = '';
		            // 有些输入法在 compositionend 后还会持续几秒“整段重发”
		            session._imeDedupeUntil = Date.now() + 8000;
		            // compositionend 后强制清空一次 textarea，避免后续按键基于旧值重发整段
		            clearTextareaSoon();
		          },
		          { passive: true }
		        );

		        // 兜底：在“问题窗口”内，每次 input 都清空 textarea，避免输入法持续携带历史文本
		        ta.addEventListener(
		          'input',
		          () => {
		            try {
		              if (session._imeComposing) return;
		              if (session._imeProblemModeUntil && Date.now() < session._imeProblemModeUntil) {
		                clearTextareaSoon();
		              }
		            } catch {}
		          },
		          { passive: true }
		        );
		      } catch {}
		    }

			    function createTerminal(cwd, autorunCmd=null, sessionId=null) {
	      const id = `term-${counter++}`;
      const tabs = document.getElementById('tabs');
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = sessionId ? `终端 ${sessions.length + 1} (恢复)` : `终端 ${sessions.length + 1}`;
	      const close = document.createElement('span');
	      close.className = 'close';
	      close.textContent = '×';
	      close.onclick = (e) => { e.stopPropagation(); closeTerminal(id); };
	      tab.appendChild(close);
      tab.onclick = () => setActive(id);
      tabs.appendChild(tab);

	      const pane = document.createElement('div');
	      pane.className = 'term-pane';
	      document.getElementById('term-area').appendChild(pane);

	      // 默认单元格尺寸（会在 term.open 后尽量用 xterm 实测值替换，避免不同浏览器下 rows 计算偏差导致“字铺不满”）
	      let cellWidth = 7.6;
	      let cellHeight = 18;

	      function updateCellMetrics(term) {
	        try {
	          const d = term?._core?._renderService?.dimensions;
	          const w = d?.actualCellWidth ?? d?.css?.cell?.width;
	          const h = d?.actualCellHeight ?? d?.css?.cell?.height;
	          if (Number.isFinite(w) && w > 0) cellWidth = w;
	          if (Number.isFinite(h) && h > 0) cellHeight = h;
	        } catch {}
	      }

		      // 计算初始终端尺寸
		      function calculateTermSize() {
		        const termArea = document.getElementById('term-area');
		        // 注意：移动端会在底部渲染一个“空白触控板”(#cursor-pad) 作为单指移动光标区域，
		        // 终端实际可用区域以 pane 的尺寸为准，避免行数计算偏大导致内容被遮挡。
		        const container = pane || termArea;
		        // pane 已按 CSS inset 扣掉边距，这里直接用 clientWidth/clientHeight，避免误差导致底部出现“空隙感”。
		        const availableWidth = container.clientWidth;
		        const availableHeight = container.clientHeight;
		        
		        const cols = Math.floor(availableWidth / (cellWidth || 1));
		        const rows = Math.floor(availableHeight / (cellHeight || 1));
	        
	        return {
	          cols: Math.max(Math.min(cols, 150), 20),
	          rows: Math.max(Math.min(rows, 50), 10)
        };
      }

      const initialSize = calculateTermSize();
	      const term = new Terminal({ 
	        convertEol: true, 
	        theme: { background: '#0f1115' },
	        cols: initialSize.cols,
	        rows: initialSize.rows,
	        scrollback: 5000,
	        cursorBlink: true,
	        fontSize: 13,
	        fontFamily: 'Consolas, "Courier New", monospace',
	        allowTransparency: false,
	        cursorStyle: 'block',
	        // 明确使用 canvas 渲染（不支持则自动忽略），避免 DOM 渲染在长输出下更易卡顿
	        rendererType: 'canvas'
	      });
	      
	      term.open(pane);

	      // 尝试启用 WebGL 渲染加速（失败则自动降级为 canvas）
	      try {
	        if (typeof term.loadAddon === 'function' && window.WebglAddon?.WebglAddon) {
	          const webgl = new window.WebglAddon.WebglAddon();
	          term.loadAddon(webgl);
	        }
	      } catch (e) {
	        console.warn('WebGL 渲染加速不可用，已降级:', e);
	      }

	      // 创建一个专门的resize函数
	      function resizeTerminal() {
	        updateCellMetrics(term);
	        const newSize = calculateTermSize();
	        if (term.cols !== newSize.cols || term.rows !== newSize.rows) {
	          term.resize(newSize.cols, newSize.rows);
	        }
	      }

      // 监听容器尺寸变化
      let resizeTimeout;
	      const resizeObserver = new ResizeObserver(() => {
	        clearTimeout(resizeTimeout);
	        resizeTimeout = setTimeout(resizeTerminal, 50);
	      });
	      // 观察 pane 尺寸变化更精确（绝对定位 + inset 变化也能触发），避免出现“底部有空白但 rows 没跟上”的情况
	      try { resizeObserver.observe(pane); } catch { resizeObserver.observe(document.getElementById('term-area')); }

	      // term.open 后的前几帧，xterm 的实际 cell 尺寸可能才稳定：补几次测量与 resize，尽量让字铺满高度（Android Edge 常见）
	      try {
	        requestAnimationFrame(() => {
	          try { updateCellMetrics(term); resizeTerminal(); } catch {}
	          setTimeout(() => { try { updateCellMetrics(term); resizeTerminal(); } catch {} }, 60);
	          setTimeout(() => { try { updateCellMetrics(term); resizeTerminal(); } catch {} }, 220);
	        });
	      } catch {}

			      const session = { 
			        type: 'term',
			        id, cwd, term, pane, tab, ws: null, inputDisposable: null, 
			        autorun: autorunCmd,
			        resizeObserver,
			        resizeTerminal,
			        sessionId,
			        lastReplyText: '',
			        lastReplyLine: '',
			        _replyTextBytes: 0,
			        _capturingReply: false,
			        _replyCarry: '',
			        _pendingTermWrites: '',
			        _termFlushScheduled: false,
			        _termFlushTimer: null,
			        _termWriting: false,
			        _imeInstalled: false,
			        _xtermTextarea: null,
			        _imeComposing: false,
			        _imeLastData: '',
			        _imeDedupeUntil: 0,
			        _imeProblemModeUntil: 0
			      };
		      sessions.push(session);
		      // xterm 的隐藏 textarea 可能在 open 后异步出现，延迟安装 IME 监听。
		      requestAnimationFrame(() => { try { installImeWorkaround(session); } catch {} });
	      // Ensure the terminal has the correct size before establishing WS, otherwise xterm may wrap/reflow
	      // the first line when a later resize happens (common on mobile/PWA during layout settle).
	      try { resizeTerminal(); } catch {}
	      requestAnimationFrame(() => {
	        setTimeout(() => {
	          try { resizeTerminal(); } catch {}
	          connectSession(session);
	        }, 0);
	      });
	      setActive(id);
	      
	      return session;
	    }

	    function connectSession(session) {
      // teardown old; suppress close message when reconnecting
      if (session.ws) {
        session.suppressClose = true;
        session.ws.close();
      }
      session.inputDisposable?.dispose();
      
      // 在URL中包含终端尺寸、token和会话ID
	      const params = new URLSearchParams({
	        cwd: session.cwd,
	        cols: session.term.cols,
	        rows: session.term.rows,
	        clientId,
	        token: authToken
	      });
      
      if (session.sessionId) {
        params.set('sessionId', session.sessionId);
        params.set('reconnect', 'true');
      }
      
      const url = `${location.origin.replace('http','ws')}/ws/pty?${params}`;
      const ws = new WebSocket(url);
      session.ws = ws;
      
				      ws.onmessage = ev => {
				        const data = ev.data;

	        // Backend may refuse reconnects to missing sessions (e.g. after server restart/cleanup).
	        if (data.startsWith('SESSION_NOT_FOUND:')) {
	          const missingId = data.split(':')[1];
	          console.warn('会话不存在:', missingId);

		          // Session is gone on the server; remove UI without deleting.
		          try { removeTerminal(session.id); } catch {}
		          if (!sessions.length) createTerminal('.');
		          return;
		        }

	        if (data.startsWith('SESSION_FORBIDDEN:')) {
	          const forbiddenId = data.split(':')[1];
	          console.warn('会话无权限:', forbiddenId);
		          try { removeTerminal(session.id); } catch {}
		          if (!sessions.length) createTerminal('.');
		          return;
		        }
        
		        // 检查是否是会话ID消息
		        if (data.startsWith('SESSION_ID:')) {
		          session.sessionId = data.split(':')[1];
		          console.log('会话ID:', session.sessionId);
		          return;
		        }
		        
				        // Normal pty output (what we consider "reply")
				        updateLastReplyLine(session, data);
				        appendReplyText(session, data);
				        queueTermWrite(session, data);
				      };
      
	      ws.onclose = () => {
	        if (session.suppressClose) {
	          session.suppressClose = false;
	          return;
	        }
	        queueTermWrite(session, '\\r\\n[连接已断开 - 会话已保存，尝试自动重连中...]\\r\\n');
	        // 自动重连（带指数退避上限）
	        const base = 800;
	        const max = 8000;
	        const attempts = session._retries || 0;
	        const delay = Math.min(max, base * Math.pow(1.6, attempts));
	        session._retries = attempts + 1;
	        setTimeout(() => {
	          try {
	            connectSession(session);
	          } catch (e) {
	            queueTermWrite(session, `\\r\\n[重连失败：${e?.message || e}]\\r\\n`);
	          }
	        }, delay);
	      };
      
	      ws.onopen = () => {
	        session._capturingReply = true;
	        // 请求会话ID（如果是新会话）
	        if (!session.sessionId) {
	          ws.send('GET_SESSION_ID');
	        }

	        // Re-assert current size right after connect (mobile layout can change after initial params).
	        try { ws.send(`RESIZE:${session.term.cols}:${session.term.rows}`); } catch {}
	        
	        if (session.autorun) {
	          setTimeout(() => {
	            ws.send(session.autorun);
	            ws.send('\n');
            session.autorun = null;
          }, 200);
        }
	      };
	      
	      session.inputDisposable = session.term.onData((d) => {
	        if (ws?.readyState !== 1) return;
	        try {
	          let payload = d;

	          // 兼容：把智能引号统一为 ASCII，避免某些 shell/程序解析异常
	          if (typeof payload === 'string' && payload) {
	            const raw = payload;
	            payload = payload.replace(/[“”]/g, '"').replace(/[‘’]/g, "'");
	            // 禁用“成对引号自动补全”（常见于部分安卓输入法，如小米输入法）。
	            // 这类输入法会一次性插入两个引号并试图把光标放到中间，但 xterm 的输入模型不支持该行为，
	            // 容易触发后续按键的“整段重发/重复粘贴”。这里直接降级为只发送一个引号。
	            if (payload === '""') payload = '"';
	            else if (payload === "''") payload = "'";

	            // 如果检测到来自输入法的“引号相关触发”（智能引号/成对补全），开启一个短暂的“问题窗口”，
	            // 在窗口内更积极地清空 xterm textarea，防止输入法持续携带历史文本重发整段。
	            try {
	              const looksLikeImeQuote =
	                (typeof raw === 'string' && /[“”‘’]/.test(raw)) || raw === '""' || raw === "''";
	              if (looksLikeImeQuote) {
	                session._imeProblemModeUntil = Date.now() + 15000;
	                session._imeDedupeUntil = Math.max(session._imeDedupeUntil || 0, Date.now() + 15000);
	              }
	            } catch {}
	          }

	          // IME 去重（更激进的兜底）：
	          // 一些手机输入法在输入智能引号等字符后，会在后续按键里持续发送“整段文本”，
	          // 导致终端看起来像“每输入一个字符就把之前全部再粘贴一遍”。
	          // 这里在 composing 期间/刚结束后一段时间内，做“最长公共前缀”增量发送。
	          if (typeof payload === 'string' && payload.length > 1) {
	            const now = Date.now();
	            const inImeDedupe = !!session._imeComposing || (session._imeDedupeUntil && now < session._imeDedupeUntil);
	            if (inImeDedupe) {
	              const last = session._imeLastData || '';
	              let delta = payload;
	              if (last) {
	                let i = 0;
	                const max = Math.min(last.length, payload.length);
	                while (i < max && last.charCodeAt(i) === payload.charCodeAt(i)) i++;
	                delta = payload.slice(i);
	              }
	              session._imeLastData = payload;
	              if (!delta) return;
	              payload = delta;
	            } else if (session._imeLastData) {
	              session._imeLastData = '';
	            }
	          } else if (!session._imeComposing && session._imeLastData) {
	            session._imeLastData = '';
	          }

	          ws.send(payload);

	          // 在问题窗口内（且非 composing），每次发送后都清空 textarea，尽量阻断“整段重发”链路
	          try {
	            if (!session._imeComposing && session._imeProblemModeUntil && Date.now() < session._imeProblemModeUntil) {
	              const ta = session._xtermTextarea;
	              if (ta) {
	                setTimeout(() => {
	                  try {
	                    if (session._imeComposing) return;
	                    ta.value = '';
	                    if (typeof ta.setSelectionRange === 'function') ta.setSelectionRange(0, 0);
	                  } catch {}
	                }, 0);
	              }
	            }
	          } catch {}
	        } catch {
	          try { ws.send(d); } catch {}
	        }

	        // When user submits a command (Enter), reset reply accumulator so "copy reply"
	        // grabs the full output from this command.
	        if (d.includes('\r') || d.includes('\n')) {
	          session.lastReplyText = '';
	          session._replyTextBytes = 0;
	          session._replyCarry = '';
	          session.lastReplyLine = '';
	          session._capturingReply = true;
	        }
	      });
      
      // 监听终端尺寸变化，通知后端
      if (session.resizeListener) {
        session.resizeListener.dispose();
      }
      session.resizeListener = session.term.onResize(({ cols, rows }) => {
        if (ws?.readyState === 1) {
          ws.send(`RESIZE:${cols}:${rows}`);
        }
      });
    }

	    function setActive(id) {
	      activeId = id;
	      const activeSession = sessions.find(s => s.id === id) || null;
	      try { document.body.classList.toggle('editor-active', activeSession?.type === 'editor'); } catch {}

	      sessions.forEach(s => {
	        const active = s.id === id;
	        s.tab.classList.toggle('active', active);
	        // 不同面板类型的 display 不能一刀切：
	        // - editor-pane 依赖 flex 布局（否则 editor-body 的高度计算会失效，表现为“看不到编辑器”）
	        // - term-pane 用 block/flex 都能工作，这里保持 block
	        if (active) s.pane.style.display = (s.type === 'editor') ? 'flex' : 'block';
	        else s.pane.style.display = 'none';
	      });

	      // 切换到活动终端后，优先把积压输出快速刷新（避免切换后看到“卡住”）
	      try {
	        const s = activeSession;
	        if (s?.type === 'term') {
	          if (s?._pendingTermWrites) flushTermWrites(s);
	          if (s?._pendingTermWrites) scheduleTermFlush(s);
	          try { s.term?.focus?.(); } catch {}
	        } else if (s?.type === 'editor') {
	          refreshEditorSession(s);
	          try { s.cm?.focus?.(); } catch {}
	        }
	      } catch {}

	    }

	    function getActive() {
	      return sessions.find(s => s.id === activeId);
	    }

	    function refreshEditorSession(s) {
	      try {
	        if (!s || s.type !== 'editor' || !s.cm) return;
	        // setSize 能显式解决某些浏览器下 CodeMirror 高度计算偏差（导致顶部/底部被裁切）
	        try { s.cm.setSize('100%', '100%'); } catch {}
	        try { s.cm.refresh(); } catch {}
	      } catch {}
	    }

	    function refreshAllEditors() {
	      try { sessions.forEach(refreshEditorSession); } catch {}
	    }

	    // 编辑器在容器尺寸变化时需要 refresh，否则可能出现空白/高度不正确（尤其是移动端旋转/软键盘弹出）
	    window.addEventListener('resize', () => {
	      try {
	        const s = getActive();
	        if (s?.type === 'editor') refreshEditorSession(s);
	      } catch {}
	    });

		    function getLatestNonEmptyLine(term) {
		      try {
		        const buf = term?.buffer?.active;
		        if (!buf) return '';
		        const start = (buf.baseY || 0) + (buf.cursorY || 0);
		        for (let y = start; y >= 0; y--) {
		          const line = buf.getLine(y);
		          if (!line) continue;
		          const text = (line.translateToString(true) || '').replace(/\s+$/g, '');
		          if (text.trim().length) return text;
		        }
		      } catch {}
		      return '';
		    }

			    // Track "terminal reply": latest non-empty line received from backend output.
			    function updateLastReplyLine(session, chunk) {
		      try {
		        if (!session) return;
		        const carry = session._replyCarry || '';
		        const text = (carry + (chunk || '')).replace(/\r/g, '');
		        const parts = text.split('\n');
		        session._replyCarry = parts.pop() || '';
		        for (const line of parts) {
		          const cleaned = (line || '').replace(/\s+$/g, '');
		          if (cleaned.trim()) session.lastReplyLine = cleaned;
		        }
			      } catch {}
			    }

			    // Track "terminal reply": full output text for the most recent command.
			    function appendReplyText(session, chunk) {
			      try {
			        if (!session?._capturingReply) return;
			        if (!chunk) return;
			        const text = String(chunk).replace(/\r/g, '');

			        // Avoid unbounded growth (keep last ~200KB per session).
			        const maxBytes = 200000;
			        const newBytes = session._replyTextBytes + text.length;
			        if (newBytes > maxBytes) {
			          const overflow = newBytes - maxBytes;
			          session.lastReplyText = (session.lastReplyText || '').slice(overflow);
			          session._replyTextBytes = Math.max(0, session._replyTextBytes - overflow);
			        }

			        session.lastReplyText = (session.lastReplyText || '') + text;
			        session._replyTextBytes += text.length;
			      } catch {}
			    }

	    async function writeClipboard(text) {
	      if (!text) return false;
	      try {
	        await navigator.clipboard.writeText(text);
	        return true;
	      } catch {
	        try {
	          const ta = document.createElement('textarea');
	          ta.value = text;
	          ta.style.position = 'fixed';
	          ta.style.left = '-9999px';
	          document.body.appendChild(ta);
	          ta.focus();
	          ta.select();
	          const ok = document.execCommand('copy');
	          ta.remove();
	          return ok;
	        } catch {
	          return false;
	        }
	      }
	    }

		    async function readClipboard() {
		      try {
		        return await navigator.clipboard.readText();
		      } catch {
		        return '';
		      }
		    }

		    // 统一的“粘贴到活动终端”（不自动回车），供工具栏/指令集共用
			    function pasteTextToActiveTerminal(text, { toastOk = '✅ 已粘贴', toastEmpty = '⚠️ 内容为空' } = {}) {
			      const s = getActive();
			      if (!s?.ws || s.ws.readyState !== 1) {
			        showToast('❌ 终端未连接');
			        return false;
		      }
		      const normalized = String(text ?? '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
		      if (!normalized.trim()) {
		        showToast(toastEmpty);
		        return false;
		      }
		      // bracketed paste：避免多行被逐行执行
		      try {
		        s.ws.send(`\x1b[200~${normalized}\x1b[201~`);
		      } catch {
		        showToast('❌ 粘贴失败');
		        return false;
		      }
			      showToast(toastOk);
			      return true;
			    }

			    // ========= 指令集（预设命令） =========
			    function initCommandSets() {
			      const page = document.getElementById('cmdset-page');
			      const backBtn = document.getElementById('cmdsetBackBtn');
			      const breadcrumbEl = document.getElementById('cmdsetBreadcrumb');
			      const listEl = document.getElementById('cmdsetList');
			      const emptyEl = document.getElementById('cmdsetEmpty');
			      const newCmdBtn = document.getElementById('cmdsetNewCommandBtn');
			      const newFolderBtn = document.getElementById('cmdsetNewFolderBtn');
			      const floatingBtn = document.getElementById('cmdsetFloatingBtn');

			      const modalBackdrop = document.getElementById('cmdset-modal-backdrop');
			      const modal = document.getElementById('cmdset-modal');
			      const modalTitle = document.getElementById('cmdsetModalTitle');
			      const nameInput = document.getElementById('cmdsetNameInput');
			      const contentField = document.getElementById('cmdsetContentField');
			      const contentInput = document.getElementById('cmdsetContentInput');
			      const autoSendField = document.getElementById('cmdsetAutoSendField');
			      const autoSendInput = document.getElementById('cmdsetAutoSendInput');
			      const modalCancelBtn = document.getElementById('cmdsetModalCancelBtn');
			      const modalOkBtn = document.getElementById('cmdsetModalOkBtn');
			      const modalCloseBtn = document.getElementById('cmdsetModalCloseBtn');

			      const confirmBackdrop = document.getElementById('cmdset-confirm-backdrop');
			      const confirmModal = document.getElementById('cmdset-confirm-modal');
			      const confirmText = document.getElementById('cmdsetConfirmText');
			      const confirmCancelBtn = document.getElementById('cmdsetConfirmCancelBtn');
			      const confirmOkBtn = document.getElementById('cmdsetConfirmOkBtn');
			      const confirmCloseBtn = document.getElementById('cmdsetConfirmCloseBtn');

			      if (!page || !backBtn || !breadcrumbEl || !listEl || !emptyEl || !newCmdBtn || !newFolderBtn || !floatingBtn) return;
				      const modalDeleteBtn = document.getElementById('cmdsetModalDeleteBtn');
				      if (!modalBackdrop || !modal || !modalTitle || !nameInput || !contentField || !contentInput || !autoSendField || !autoSendInput || !modalCancelBtn || !modalOkBtn || !modalCloseBtn || !modalDeleteBtn) return;
			      if (!confirmBackdrop || !confirmModal || !confirmText || !confirmCancelBtn || !confirmOkBtn || !confirmCloseBtn) return;

			      const state = {
			        root: null,
			        path: ['root'], // id 栈
			        modalMode: 'command', // 'command' | 'folder'
			        pendingDelete: null, // node id
			        loading: false,
			      };

			      const genId = () => `c_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;

			      function findNodeById(id, node) {
			        if (!node) return null;
			        if (node.id === id) return node;
			        if (node.type === 'folder' && Array.isArray(node.children)) {
			          for (const ch of node.children) {
			            const r = findNodeById(id, ch);
			            if (r) return r;
			          }
			        }
			        return null;
			      }

			      function getCurrentFolder() {
			        let node = state.root;
			        for (let i = 1; i < state.path.length; i++) {
			          const id = state.path[i];
			          node = node?.children?.find((c) => c.id === id);
			        }
			        if (!node || node.type !== 'folder') return state.root;
			        return node;
			      }

			      function updateBreadcrumb() {
			        const names = [];
			        let node = state.root;
			        names.push('根目录');
			        for (let i = 1; i < state.path.length; i++) {
			          const id = state.path[i];
			          node = node?.children?.find((c) => c.id === id);
			          if (node) names.push(node.name);
			        }
			        breadcrumbEl.textContent = names.join(' / ');
			      }

			      function renderList() {
			        const folder = getCurrentFolder();
			        if (!folder) return;
			        const items = (folder.children || []).slice().sort((a, b) => a.name.localeCompare(b.name, 'zh-Hans-CN'));
			        listEl.innerHTML = '';
			        if (!items.length) {
			          emptyEl.style.display = 'block';
			          return;
			        }
			        emptyEl.style.display = 'none';
			        for (const item of items) {
			          const row = document.createElement('div');
			          row.className = 'cmdset-item';
			          const ico = document.createElement('div');
			          ico.className = 'ico';
			          ico.textContent = item.type === 'folder' ? '📂' : '▶️';
			          const name = document.createElement('div');
			          name.className = 'name';
		          name.textContent = item.name;
			          const meta = document.createElement('div');
			          meta.className = 'meta';
			          if (item.type === 'folder') {
			            meta.textContent = '文件夹';
			          } else {
			            const preview = (item.content || '').slice(0, 60);
			            meta.textContent = (item.autoSend ? '自动发送 · ' : '') + preview;
			          }
			        const del = document.createElement('button');
			        del.className = 'cmdset-edit';
			        del.textContent = '编辑';

			          row.appendChild(ico);
			          row.appendChild(name);
			          row.appendChild(meta);
			          row.appendChild(del);

			          row.onclick = (e) => {
			            e.preventDefault();
			            e.stopPropagation();
			            if (item.type === 'folder') {
			              state.path.push(item.id);
			              updateBreadcrumb();
			              renderList();
			              return;
			            }
			            const ok = pasteTextToActiveTerminal(item.content, { toastOk: item.autoSend ? '✅ 已发送指令' : '✅ 已粘贴指令', toastEmpty: '⚠️ 指令为空' });
			            if (ok && item.autoSend) {
			              try {
			                const s = getActive();
			                setTimeout(() => { try { s?.ws?.send('\r'); } catch {} }, 20);
			              } catch {}
			            }
			            if (ok) closeCommandSetsPage();
			          };

			          del.onclick = (e) => {
			            e.preventDefault();
			            e.stopPropagation();
			            openEditModal(item);
			          };

			          listEl.appendChild(row);
			        }
			      }

			      function openPage() {
			        page.classList.add('open');
			        page.setAttribute('aria-hidden', 'false');
			        try { listEl.scrollTop = 0; } catch {}
			      }
			      function closeCommandSetsPage() {
			        page.classList.remove('open');
			        page.setAttribute('aria-hidden', 'true');
			      }

			      async function loadCommandSets() {
			        state.loading = true;
			        try {
			          const res = await fetch('/api/command-sets');
			          const data = await res.json();
			          if (data && data.root) state.root = data.root;
			        } catch (e) {
			          console.error('加载指令集失败', e);
			          state.root = { id: 'root', type: 'folder', name: 'root', children: [] };
			        } finally {
			          state.loading = false;
			          if (!state.root) state.root = { id: 'root', type: 'folder', name: 'root', children: [] };
			          state.path = [state.root.id || 'root'];
			        }
			      }

			      async function saveCommandSets() {
			        if (!state.root) return;
			        try {
			          await fetch('/api/command-sets', {
			            method: 'PUT',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ root: state.root }),
			          });
			        } catch (e) {
			          console.error('保存指令集失败', e);
			          showToast('⚠️ 保存失败');
			        }
			      }

				      function openCreateModal(mode, editingItem = null) {
				        state.modalMode = mode;
				        state.editingNode = editingItem || null;
				        modalTitle.textContent = editingItem
				          ? (mode === 'folder' ? '编辑文件夹' : '编辑指令')
				          : (mode === 'folder' ? '新建文件夹' : '新建指令');
				        const isFolder = mode === 'folder';
				        contentField.style.display = isFolder ? 'none' : 'block';
				        autoSendField.style.display = isFolder ? 'none' : 'block';

				        if (editingItem) {
				          nameInput.value = editingItem.name || '';
				          if (!isFolder) {
				            contentInput.value = editingItem.content || '';
				            autoSendInput.checked = Boolean(editingItem.autoSend);
				          } else {
				            contentInput.value = '';
				            autoSendInput.checked = false;
				          }
				          modalDeleteBtn.style.display = 'inline-flex';
				        } else {
				          nameInput.value = '';
				          contentInput.value = '';
				          autoSendInput.checked = false;
				          modalDeleteBtn.style.display = 'none';
				        }

				        modalBackdrop.classList.add('open');
				        modal.classList.add('open');
				        modal.setAttribute('aria-hidden', 'false');
				        setTimeout(() => { try { nameInput.focus(); } catch {} }, 0);
				      }

				      function closeCreateModal() {
				        modalBackdrop.classList.remove('open');
				        modal.classList.remove('open');
				        modal.setAttribute('aria-hidden', 'true');
				        state.editingNode = null;
				        modalDeleteBtn.onclick = null;
				      }

			      function openDeleteConfirm(item) {
			        state.pendingDelete = item;
			        confirmText.textContent = item.type === 'folder'
			          ? `确认删除文件夹“${item.name}”及其中所有指令？`
			          : `确认删除指令“${item.name}”？`;
			        confirmBackdrop.classList.add('open');
			        confirmModal.classList.add('open');
			        confirmModal.setAttribute('aria-hidden', 'false');
			      }

			      function closeDeleteConfirm() {
			        state.pendingDelete = null;
			        confirmBackdrop.classList.remove('open');
			        confirmModal.classList.remove('open');
			        confirmModal.setAttribute('aria-hidden', 'true');
			      }

			      function removeNodeById(targetId, node) {
			        if (!node || node.type !== 'folder' || !Array.isArray(node.children)) return false;
			        const idx = node.children.findIndex((c) => c.id === targetId);
			        if (idx !== -1) {
			          node.children.splice(idx, 1);
			          return true;
			        }
			        for (const ch of node.children) {
			          if (ch.type === 'folder' && removeNodeById(targetId, ch)) return true;
			        }
			        return false;
			      }

			      async function ensureLoadedThen(fn) {
			        if (!state.root) await loadCommandSets();
			        fn();
			      }

				      async function handleCreateOk() {
				        const name = nameInput.value.trim();
				        const content = contentInput.value;
				        if (!name) {
				          showToast('⚠️ 名称不能为空');
				          return;
				        }
				        const folder = getCurrentFolder();
				        if (!folder || folder.type !== 'folder') return;
				        if (state.editingNode) {
				          state.editingNode.name = name;
				          if (state.editingNode.type === 'command') {
				            state.editingNode.content = content || '';
				            state.editingNode.autoSend = Boolean(autoSendInput.checked);
				          }
				        } else {
				          const node = state.modalMode === 'folder'
				            ? { id: genId(), type: 'folder', name, children: [] }
				            : { id: genId(), type: 'command', name, content: content || '', autoSend: Boolean(autoSendInput.checked) };
				          folder.children = folder.children || [];
				          folder.children.push(node);
				        }
				        await saveCommandSets();
				        closeCreateModal();
				        renderList();
				      }

			      async function handleDeleteOk() {
			        if (!state.pendingDelete) return;
			        removeNodeById(state.pendingDelete.id, state.root);
			        // 删除时如果当前路径已被删掉，退回上一级
			        const existsPath = (ids) => {
			          let n = state.root;
			          for (let i = 1; i < ids.length; i++) {
			            const id = ids[i];
			            n = n?.children?.find((c) => c.id === id);
			            if (!n) return false;
			          }
			          return true;
			        };
			        if (!existsPath(state.path)) {
			          state.path = [state.root?.id || 'root'];
			        }
			        await saveCommandSets();
			        closeDeleteConfirm();
			        updateBreadcrumb();
			        renderList();
			      }

				      function openCommandSetsPage() {
				        ensureLoadedThen(() => {
				          updateBreadcrumb();
				          renderList();
				          openPage();
				        });
				      }

				      function handleBack() {
				        if (state.path.length > 1) {
				          state.path.pop();
				          updateBreadcrumb();
				          renderList();
				        } else {
				          closeCommandSetsPage();
				        }
				      }

				      function openEditModal(item) {
				        openCreateModal(item.type, item);
				        modalDeleteBtn.onclick = (e) => {
				          e.preventDefault(); e.stopPropagation();
				          state.pendingDelete = item;
				          closeCreateModal();
				          openDeleteConfirm(item);
				        };
				      }

				      // 事件绑定
				      floatingBtn.onclick = () => openCommandSetsPage();
				      newCmdBtn.onclick = () => openCreateModal('command', null);
				      newFolderBtn.onclick = () => openCreateModal('folder', null);
			      modalCancelBtn.onclick = closeCreateModal;
			      modalCloseBtn.onclick = closeCreateModal;
			      modalOkBtn.onclick = handleCreateOk;
			      backBtn.onclick = handleBack;

			      confirmCancelBtn.onclick = closeDeleteConfirm;
			      confirmCloseBtn.onclick = closeDeleteConfirm;
			      confirmOkBtn.onclick = handleDeleteOk;

			      // 暴露到全局
			      window.openCommandSetsPage = openCommandSetsPage;
			    }

			    function stripTerminalControl(text) {
			      try {
			        let s = String(text ?? '');
			        if (!s) return '';

			        // Some environments/loggers render ESC as the visible two-character sequence "^["
			        // (caret notation). If copied, it shows up as "^[[...". Strip those too.
			        // CSI: ^[[ ... command
			        s = s.replace(/\^\[\[[0-?]*[ -/]*[@-~]/g, '');
			        // OSC: ^[] ... ^[\
			        s = s.replace(/\^\[\][\s\S]*?\^\[\\/g, '');
			        // DCS/PM/APC: ^[P / ^[^ / ^[_ ... ^[\
			        s = s.replace(/\^\[[P^_][\s\S]*?\^\[\\/g, '');
			        // Single-character caret-notation ESC sequences
			        s = s.replace(/\^\[[@-Z\\-_]/g, '');

			        // OSC: ESC ] ... BEL or ESC \
			        s = s.replace(/\x1b\][^\x07\x1b]*(?:\x07|\x1b\\)/g, '');
			        // DCS/PM/APC: ESC P / ESC ^ / ESC _ ... ESC \
			        s = s.replace(/\x1b[P^_][\s\S]*?\x1b\\/g, '');
			        // CSI: ESC [ ... command
		        s = s.replace(/\x1b\[[0-?]*[ -/]*[@-~]/g, '');
		        // Single-character ESC sequences
		        s = s.replace(/\x1b[@-Z\\-_]/g, '');

		        // Control chars (keep \n and \t)
		        s = s.replace(/[\x00-\x08\x0B-\x1A\x1C-\x1F\x7F]/g, '');
		        // C1 controls
		        s = s.replace(/[\x80-\x9F]/g, '');

		        return s;
		      } catch {
		        return '';
		      }
		    }

			    // ========= Git 历史页（长按“指令集”按钮进入） =========
			    function initGitPage() {
			      const page = document.getElementById('git-page');
			      const backBtn = document.getElementById('gitBackBtn');
			      const refreshBtn = document.getElementById('gitRefreshBtn');
			      const cwdText = document.getElementById('gitCwdText');
			      const infoBox = document.getElementById('gitInfoBox');
			      const listEl = document.getElementById('gitList');
			      const resetBackdrop = document.getElementById('git-reset-backdrop');
			      const resetModal = document.getElementById('git-reset-modal');
			      const resetCloseBtn = document.getElementById('gitResetCloseBtn');
			      const revertBtn = document.getElementById('gitRevertBtn');
			      const resetSoftBtn = document.getElementById('gitResetSoftBtn');
			      const resetHardBtn = document.getElementById('gitResetHardBtn');
			      const resetDesc = document.getElementById('gitResetDesc');
			      if (!page || !backBtn || !refreshBtn || !cwdText || !infoBox || !listEl) return;
			      if (!resetBackdrop || !resetModal || !resetCloseBtn || !revertBtn || !resetSoftBtn || !resetHardBtn || !resetDesc) return;

			      const state = {
			        loading: false,
			        cwd: '.',
			        resetCommit: null,
			        resetSubject: '',
			        resetPushed: null,
			        resetIsUpstreamHead: false,
			      };

			      function getTargetCwd() {
			        try {
			          const s = getActive?.();
			          if (s?.cwd) return s.cwd;
			        } catch {}
			        try {
			          const v = document.getElementById('path')?.value;
			          if (v) return v;
			        } catch {}
			        return '.';
			      }

			      function openPage() {
			        page.classList.add('open');
			        page.setAttribute('aria-hidden', 'false');
			      }

			      function closePage() {
			        page.classList.remove('open');
			        page.setAttribute('aria-hidden', 'true');
			      }

			      function escapeHtml(s) {
			        return String(s ?? '')
			          .replace(/&/g, '&amp;')
			          .replace(/</g, '&lt;')
			          .replace(/>/g, '&gt;')
			          .replace(/\"/g, '&quot;')
			          .replace(/'/g, '&#39;');
			      }

			      function setInfo(text) {
			        infoBox.style.display = 'block';
			        infoBox.textContent = String(text ?? '');
			      }

			      function clearList() {
			        listEl.innerHTML = '';
			      }

			      function renderCommits(commits) {
			        clearList();
			        if (!Array.isArray(commits) || !commits.length) return;
			        infoBox.style.display = 'none';
			        const fmtTime = (iso) => {
			          try {
			            const d = new Date(iso);
			            if (!Number.isFinite(d.getTime())) return '';
			            const pad = (n) => String(n).padStart(2, '0');
			            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
			          } catch {
			            return '';
			          }
			        };
			        for (let idx = 0; idx < commits.length; idx += 1) {
			          const c = commits[idx];
			          const item = document.createElement('div');
			          let stClass = 'git-unknown';
			          if (c.pushed === true) stClass = 'git-pushed';
			          else if (c.pushed === false) stClass = 'git-unpushed';
			          item.className = `cmdset-item ${stClass}`;
			          const author = String(c.author || '').trim();
			          const time = fmtTime(c.date);
			          const meta = [time, author].filter(Boolean).join(' · ');
			          item.innerHTML = `
			            <span class="ico">⎇</span>
			            <span class="name">${escapeHtml(c.subject || '(no subject)')}</span>
			            <span class="meta">${escapeHtml(meta || '')}</span>
			          `;
			          item.onclick = async (e) => {
			            e.preventDefault();
			            e.stopPropagation();
			            const hash = String(c.hash || '').trim();
			            if (!hash) return;
			            const ok = await writeClipboard(hash);
			            showToast(ok ? '✅ 已复制提交哈希' : '❌ 复制失败');
			          };
			          // 长按：打开操作弹窗（reset 仅未推送可用；revert 对任意提交可用）
			          {
			            let timer = null;
			            const longPressMs = 520;
			            const start = () => {
			              try {
			                if (timer) clearTimeout(timer);
			                timer = setTimeout(() => {
			                  state.resetCommit = String(c.hash || '').trim();
			                  state.resetSubject = String(c.subject || '').trim();
			                  state.resetPushed = c.pushed;
			                  state.resetIsUpstreamHead = Boolean(c.isUpstreamHead);
			                  openResetModal();
			                }, longPressMs);
			              } catch {}
			            };
			            const cancel = () => {
			              if (timer) clearTimeout(timer);
			              timer = null;
			            };
			            item.addEventListener('pointerdown', start);
			            item.addEventListener('pointerup', cancel);
			            item.addEventListener('pointercancel', cancel);
			            item.addEventListener('pointerleave', cancel);
			          }
			          listEl.appendChild(item);
			        }
			      }

			      async function createBranchFromCommit(hash) {
			        const name = prompt('输入新分支名称');
			        if (!name || !name.trim()) return;
			        const cwd = getTargetCwd();
			        try {
			          const res = await fetch('/api/git/checkout-new', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd, branch: name.trim(), from: hash }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            if (res.status === 409) throw new Error('工作区脏，请先提交/暂存或清理');
			            throw new Error(data?.error || `HTTP ${res.status}`);
			          }
			          showToast(`✅ 已基于 ${hash.slice(0,7)} 创建并切换到 ${data?.current || name.trim()}`);
			          closeResetModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`❌ 新建分支失败：${e?.message || e}`);
			        }
			      }

			      async function fetchJson(url, options) {
			        const res = await fetch(url, options);
			        const data = await res.json().catch(() => ({}));
			        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
			        return data;
			      }

			      async function fetchBranches(cwd) {
			        return fetchJson(`/api/git/branches?cwd=${encodeURIComponent(cwd)}`);
			      }

			      const branchModal = {
			        backdrop: null,
			        modal: null,
			        filter: null,
			        localList: null,
			        remoteList: null,
			        forceChk: null,
			        status: null,
			        okBtn: null,
			        cancelBtn: null,
			        closeBtn: null,
			        data: { locals: [], remotes: [], current: '' },
			        selected: '',
			      };

			      function renderBranchList(listEl, branches, current) {
			        listEl.innerHTML = '';
			        branches.forEach((name) => {
			          const div = document.createElement('div');
			          div.className = 'branch-item';
			          if (name === current) div.classList.add('active');
			          div.innerHTML = `<span>${name === current ? '⭐' : '🔀'}</span><span style="flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${name}</span>`;
			          div.onclick = () => {
			            branchModal.selected = name;
			            // 高亮
			            try {
			              branchModal.localList.querySelectorAll('.branch-item').forEach(el => el.classList.toggle('active', false));
			              branchModal.remoteList.querySelectorAll('.branch-item').forEach(el => el.classList.toggle('active', false));
			            } catch {}
			            div.classList.add('active');
			          };
			          listEl.appendChild(div);
			        });
			      }

      function openBranchModal(data) {
        branchModal.data = data || { locals: [], remotes: [], current: '' };
        branchModal.selected = data?.current || '';
        branchModal.filter.value = '';
        renderBranchList(branchModal.localList, data.locals || [], data.current);
        renderBranchList(branchModal.remoteList, data.remotes || [], data.current);
        branchModal.forceChk.checked = false;
        branchModal.status.textContent = `当前分支：${data.current || '-'}`;
        branchModal.backdrop.style.display = 'block';
        branchModal.modal.style.display = 'block';
        branchModal.backdrop.classList.add('open');
        branchModal.modal.classList.add('open');
      }

      function closeBranchModal() {
        branchModal.backdrop.classList.remove('open');
        branchModal.modal.classList.remove('open');
        branchModal.backdrop.style.display = 'none';
        branchModal.modal.style.display = 'none';
      }

			      function filterBranches(keyword) {
			        const kw = keyword.trim().toLowerCase();
			        const locals = (branchModal.data.locals || []).filter(n => !kw || n.toLowerCase().includes(kw));
			        const remotes = (branchModal.data.remotes || []).filter(n => !kw || n.toLowerCase().includes(kw));
			        renderBranchList(branchModal.localList, locals, branchModal.data.current);
			        renderBranchList(branchModal.remoteList, remotes, branchModal.data.current);
			      }

			      async function submitBranchSwitch() {
			        const cwd = getTargetCwd();
			        const target = branchModal.selected || branchModal.data.current;
			        if (!target) { showToast('⚠️ 请选择要切换的分支'); return; }
			        branchModal.okBtn.disabled = true;
			        branchModal.cancelBtn.disabled = true;
			        try {
			          const res = await fetch('/api/git/checkout', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd, branch: target, force: branchModal.forceChk.checked }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            if (res.status === 409) {
			              branchModal.status.textContent = '工作区有未提交修改：请提交/暂存，或勾选“强制切换”后重试（会丢弃修改）';
			              branchModal.forceChk.focus();
			              return;
			            }
			            throw new Error(data?.error || `HTTP ${res.status}`);
			          }
			          showToast(`✅ 已切换到 ${data?.current || target}`);
			          closeBranchModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          branchModal.status.textContent = `❌ 切换失败：${e?.message || e}`;
			        } finally {
			          branchModal.okBtn.disabled = false;
			          branchModal.cancelBtn.disabled = false;
			        }
			      }

			      // 新建分支弹窗逻辑
			      const newBranchModal = {
			        backdrop: null,
			        modal: null,
			        closeBtn: null,
			        cancelBtn: null,
			        okBtn: null,
			        fromSelect: null,
			        nameInput: null,
			      };

			      function openNewBranchModal(commits, currentBranch) {
			        const opts = [];
			        opts.push({ value: 'HEAD', label: `HEAD（当前：${currentBranch || '-' }）` });
			        (commits || []).slice(0, 50).forEach((c) => {
			          const label = `${c.shortHash || c.hash?.slice(0,7) || ''} · ${c.subject || ''}`.trim();
			          opts.push({ value: c.hash, label });
			        });
			        newBranchModal.fromSelect.innerHTML = '';
			        opts.forEach((o) => {
			          const opt = document.createElement('option');
			          opt.value = o.value;
			          opt.textContent = o.label;
			          newBranchModal.fromSelect.appendChild(opt);
			        });
			        newBranchModal.nameInput.value = '';
			        newBranchModal.backdrop.style.display = 'block';
			        newBranchModal.modal.style.display = 'block';
			        newBranchModal.backdrop.classList.add('open');
			        newBranchModal.modal.classList.add('open');
			        setTimeout(() => { try { newBranchModal.nameInput.focus(); } catch {} }, 0);
			      }

			      function closeNewBranchModal() {
			        newBranchModal.backdrop.classList.remove('open');
			        newBranchModal.modal.classList.remove('open');
			        newBranchModal.backdrop.style.display = 'none';
			        newBranchModal.modal.style.display = 'none';
			      }

			      async function submitNewBranch() {
			        const name = (newBranchModal.nameInput.value || '').trim();
			        if (!name) { showToast('⚠️ 请输入分支名称'); return; }
			        const from = (newBranchModal.fromSelect.value || 'HEAD').trim() || 'HEAD';
			        const cwd = getTargetCwd();
			        newBranchModal.okBtn.disabled = true;
			        newBranchModal.cancelBtn.disabled = true;
			        try {
			          const res = await fetch('/api/git/checkout-new', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd, branch: name, from }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            if (res.status === 409) throw new Error('工作区脏，请先提交/暂存或清理');
			            throw new Error(data?.error || `HTTP ${res.status}`);
			          }
			          showToast(`✅ 已创建并切换到 ${data?.current || name}`);
			          closeNewBranchModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`❌ 新建分支失败：${e?.message || e}`);
			        } finally {
			          newBranchModal.okBtn.disabled = false;
			          newBranchModal.cancelBtn.disabled = false;
			        }
			      }

			      async function refresh({ allowInitPrompt = false } = {}) {
			        if (state.loading) return;
			        state.loading = true;
			        const cwd = getTargetCwd();
			        state.cwd = cwd;
			        cwdText.textContent = cwd;
			        {
			          const raw = String(cwd || '').trim();
			          const parts = raw.split(/[\\/]+/).filter(Boolean);
			          const hasHidden = parts.some((p) => p.startsWith('.') && p !== '.' && p !== '..');
			          if (raw === '.') {
			            setInfo('⚠️ 为安全起见，禁止在根目录（.）打开 Git 管理页。请先进入具体项目目录。');
			            clearList();
			            state.loading = false;
			            return;
			          }
			          if (hasHidden) {
			            setInfo('⚠️ 为安全起见，隐藏目录内禁止打开 Git 管理页。请切换到非隐藏项目目录。');
			            clearList();
			            state.loading = false;
			            return;
			          }
			        }
			        setInfo('加载中…');
			        clearList();
			        try {
			          const info = await fetchJson(`/api/git/info?cwd=${encodeURIComponent(cwd)}`);
			          if (!info?.gitAvailable) {
			            setInfo('⚠️ 当前环境未安装 Git 或不可用。');
			            return;
			          }
			          if (!info?.isRepo) {
			            if (allowInitPrompt) {
			              const ok = confirm(`当前文件夹（${cwd}）未初始化 Git，是否执行 git init？`);
			              if (!ok) return;
			              await fetchJson('/api/git/init', {
			                method: 'POST',
			                headers: { 'Content-Type': 'application/json' },
			                body: JSON.stringify({ cwd }),
			              });
			              showToast('✅ 已执行 git init');
			            } else {
			              setInfo('当前文件夹未初始化 Git。');
			              return;
			            }
			          }

			          const commitsResp = await fetchJson(`/api/git/commits?cwd=${encodeURIComponent(cwd)}&limit=80`);
			          const branch = commitsResp?.branch ? `分支：${commitsResp.branch}` : '';
			          const root = commitsResp?.repoRoot ? `仓库：${commitsResp.repoRoot}` : '';
			          const upstream = commitsResp?.upstream ? `上游：${commitsResp.upstream}` : '上游：未配置';
			          const header = `${branch}${branch && root ? ' · ' : ''}${root}`.trim();
			          if (!commitsResp?.commits?.length) {
			            setInfo(header ? `${header}（暂无提交）\n${upstream}` : `暂无提交记录。\n${upstream}`);
			          } else {
			            setInfo(`${header || '提交历史'}\n${upstream}\n提示：绿色=已推送，橙色=未推送，灰色=未知；长按条目可 Reset/Revert`);
			          }
			          renderCommits(commitsResp?.commits || []);
			        } catch (e) {
			          setInfo(`❌ 加载失败：${escapeHtml(e?.message || 'unknown')}`);
			        } finally {
			          state.loading = false;
			        }
			      }

			      function openGitPage({ promptInit = false } = {}) {
			        openPage();
			        refresh({ allowInitPrompt: promptInit }).catch(() => {});
			      }

			      function openResetModal() {
			        const subj = state.resetSubject ? `“${state.resetSubject}”` : '(无标题)';
			        const canReset = state.resetPushed === false || (state.resetPushed === true && state.resetIsUpstreamHead === true);
			        try { resetSoftBtn.disabled = !canReset; } catch {}
			        try { resetHardBtn.disabled = !canReset; } catch {}
			        try {
			          resetSoftBtn.title = canReset ? '软回退：reset 到该提交' : '仅未推送提交或云端最新提交可用';
			          resetHardBtn.title = canReset ? '硬回退：reset 到该提交' : '仅未推送提交或云端最新提交可用';
			        } catch {}
			        resetDesc.textContent =
			          `将回退到该提交：${subj}\n\n` +
			          `软回退：仅移动指针到该提交，不改动工作区文件（差异会保留为暂存区/待提交状态）。\n` +
			          `硬回退：指针与工作区文件一起回到该提交（会丢弃未提交的工作区改动）。\n` +
			          `Revert：生成一个新的提交来反做该提交的改动（可用于已推送提交，但可能产生冲突）。\n\n` +
			          `提示：Reset 对“未推送”提交开放；对“已推送”提交仅允许回退到云端最新（用于与云端同步）；Revert 对历史提交更安全。`;
			        resetBackdrop.classList.add('open');
			        resetModal.classList.add('open');
			        resetBackdrop.setAttribute('aria-hidden', 'false');
			        resetModal.setAttribute('aria-hidden', 'false');
			      }

			      function closeResetModal() {
			        resetBackdrop.classList.remove('open');
			        resetModal.classList.remove('open');
			        resetBackdrop.setAttribute('aria-hidden', 'true');
			        resetModal.setAttribute('aria-hidden', 'true');
			        state.resetCommit = null;
			        state.resetSubject = '';
			        state.resetPushed = null;
			        state.resetIsUpstreamHead = false;
			      }

			      async function doReset(mode) {
			        const commit = String(state.resetCommit || '').trim();
			        if (!commit) return;
			        try {
			          const body = { cwd: getTargetCwd(), mode, commit };
			          if (mode === 'hard') body.confirmHard = true;
			          const res = await fetch('/api/git/reset', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify(body),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
			          showToast(mode === 'soft' ? '✅ 软回退完成' : '✅ 硬回退完成');
			          closeResetModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`❌ 回退失败：${e?.message || 'unknown'}`);
			        }
			      }

			      async function doRevert() {
			        const commit = String(state.resetCommit || '').trim();
			        if (!commit) return;
			        try {
			          const res = await fetch('/api/git/revert', {
			            method: 'POST',
			            headers: { 'Content-Type': 'application/json' },
			            body: JSON.stringify({ cwd: getTargetCwd(), commit }),
			          });
			          const data = await res.json().catch(() => ({}));
			          if (!res.ok) {
			            const msg = data?.hint ? `${data?.error || `HTTP ${res.status}`}（${data.hint}）` : (data?.error || `HTTP ${res.status}`);
			            if (res.status === 409) throw new Error(`${msg}：${data?.hint || ''}`.trim());
			            throw new Error(msg);
			          }
			          showToast('✅ Revert 完成（已生成新提交）');
			          closeResetModal();
			          refresh({ allowInitPrompt: false }).catch(() => {});
			        } catch (e) {
			          showToast(`❌ Revert 失败：${e?.message || 'unknown'}`);
			        }
			      }

      backBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        closePage();
      };
      refreshBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        refresh({ allowInitPrompt: false }).catch(() => {});
      };
      // 分支选择弹窗绑定
      branchModal.backdrop = document.getElementById('git-branch-backdrop');
      branchModal.modal = document.getElementById('git-branch-modal');
      branchModal.filter = document.getElementById('gitBranchFilter');
      branchModal.localList = document.getElementById('gitBranchLocalList');
      branchModal.remoteList = document.getElementById('gitBranchRemoteList');
      branchModal.forceChk = document.getElementById('gitBranchForce');
      branchModal.status = document.getElementById('branch-status');
      branchModal.okBtn = document.getElementById('gitBranchOkBtn');
      branchModal.cancelBtn = document.getElementById('gitBranchCancelBtn');
      branchModal.closeBtn = document.getElementById('gitBranchCloseBtn');

      // 绑定新建分支弹窗元素
      newBranchModal.backdrop = document.getElementById('git-new-branch-backdrop');
      newBranchModal.modal = document.getElementById('git-new-branch-modal');
      newBranchModal.closeBtn = document.getElementById('gitNewBranchCloseBtn');
      newBranchModal.cancelBtn = document.getElementById('gitNewBranchCancelBtn');
      newBranchModal.okBtn = document.getElementById('gitNewBranchOkBtn');
      newBranchModal.fromSelect = document.getElementById('gitNewBranchFrom');
      newBranchModal.nameInput = document.getElementById('gitNewBranchName');

      const branchSwitchBtn = document.getElementById('gitBranchSwitchBtn');
      const branchNewBtn = null; // 已移除顶部新建按钮，改为在 commit 长按弹窗操作

      if (branchSwitchBtn) branchSwitchBtn.onclick = async (e) => {
        e.preventDefault(); e.stopPropagation();
        try {
          // 确保懒加载样式启用
          try { document.getElementById('git-branch-style')?.removeAttribute('disabled'); } catch {}
          // 若 Git 页面未打开，先打开再拉取分支，确保弹窗叠在 Git 管理视图上
          const gitPage = document.getElementById('git-page');
          if (gitPage && gitPage.getAttribute('aria-hidden') !== 'false') {
            openGitPage({ promptInit: false });
          }
          const cwd = getTargetCwd();
          const data = await fetchBranches(cwd);
          if (!data?.isRepo) { showToast('⚠️ 不是 Git 仓库'); return; }
          openBranchModal(data);
        } catch (err) {
          showToast(`❌ 获取分支失败：${err?.message || err}`);
        }
      };
      if (branchNewBtn) branchNewBtn.onclick = async (e) => {
        e.preventDefault(); e.stopPropagation();
        try {
          try { document.getElementById('git-branch-style')?.removeAttribute('disabled'); } catch {}
          const cwd = getTargetCwd();
          const data = await fetchBranches(cwd);
          if (!data?.isRepo) { showToast('⚠️ 不是 Git 仓库'); return; }
          const commitsResp = await fetchJson(`/api/git/commits?cwd=${encodeURIComponent(cwd)}&limit=100`);
          state.commits = commitsResp?.commits || [];
          openNewBranchModal(state.commits, data.current);
        } catch (err) {
          showToast(`❌ 无法加载分支/提交列表：${err?.message || err}`);
        }
      };

      if (branchModal.cancelBtn) branchModal.cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeBranchModal(); };
      if (branchModal.closeBtn) branchModal.closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeBranchModal(); };
      if (branchModal.backdrop) branchModal.backdrop.onclick = () => closeBranchModal();
      if (branchModal.okBtn) branchModal.okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); submitBranchSwitch(); };
      if (branchModal.filter) branchModal.filter.oninput = (e) => filterBranches(e.target.value || '');

      // 新建分支弹窗关闭/提交
      if (newBranchModal.cancelBtn) newBranchModal.cancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeNewBranchModal(); };
      if (newBranchModal.closeBtn) newBranchModal.closeBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeNewBranchModal(); };
      if (newBranchModal.backdrop) newBranchModal.backdrop.onclick = () => closeNewBranchModal();
      if (newBranchModal.okBtn) newBranchModal.okBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); submitNewBranch(); };

			      resetBackdrop.onclick = closeResetModal;
			      resetCloseBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeResetModal(); };
			      revertBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const ok = confirm('Revert 会生成一个新的提交来反做改动，确认执行？');
			        if (!ok) return;
			        doRevert();
			      };
			      resetSoftBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        doReset('soft');
			      };
			      resetHardBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const ok = confirm('硬回退会丢弃未提交的工作区改动，确认继续？');
			        if (!ok) return;
			        doReset('hard');
			      };
			      const branchFromCommitBtn = document.getElementById('gitBranchFromCommitBtn');
			      if (branchFromCommitBtn) branchFromCommitBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        if (!state.resetCommit) return;
			        createBranchFromCommit(state.resetCommit);
			      };

			      window.openGitPage = openGitPage;
			    }

				    function initSideActions() {
				      const toggleBtn = document.getElementById('drawerToggleBtn');
				      const floatingCmdBtn = document.getElementById('cmdsetFloatingBtn');
				      const drawer = document.getElementById('right-drawer');
				      const backdrop = document.getElementById('drawer-backdrop');
				      const closeBtn = document.getElementById('drawerCloseBtn');

				      const orientationBtn = document.getElementById('orientationLockBtn');
				      const ctrlToggleBtn = document.getElementById('ctrlToggleBtn');
				      const altToggleBtn = document.getElementById('altToggleBtn');
				      const comboBtn = document.getElementById('comboFloatingBtn');
				      const undoBtn = document.getElementById('undoBtn');
				      const tabBtn = document.getElementById('tabBtn');
				      const enterBtn = document.getElementById('enterBtn');
				      const continueBtn = document.getElementById('continueBtn');
				      const escBtn = document.getElementById('escBtn');
				      const ctrlCBtn = document.getElementById('ctrlCBtn');

			      const pasteModalBackdrop = document.getElementById('paste-modal-backdrop');
			      const pasteModal = document.getElementById('paste-modal');
			      const pasteModalCloseBtn = document.getElementById('pasteModalCloseBtn');
			      const pasteModalCancelBtn = document.getElementById('pasteModalCancelBtn');
				      const pasteModalOkBtn = document.getElementById('pasteModalOkBtn');
				      const pasteInput = document.getElementById('paste-input');

				      if (!toggleBtn || !floatingCmdBtn || !drawer || !backdrop || !closeBtn) return;
					      if (!orientationBtn || !undoBtn || !comboBtn || !tabBtn || !enterBtn || !continueBtn || !escBtn || !ctrlCBtn) return;
					      if (!pasteModalBackdrop || !pasteModal || !pasteModalCloseBtn || !pasteModalCancelBtn || !pasteModalOkBtn || !pasteInput) return;

				      // 旋转锁：无法读取“系统旋转锁”状态，只提供 App 内开关（PWA 默认启用竖屏锁）
				      {
				        const ORIENT_KEY = 'lan_shell_orient_lock'; // 'portrait' | 'off'
				        let isActuallyLocked = false;
				        const getPref = () => {
				          try { return localStorage.getItem(ORIENT_KEY); } catch { return null; }
				        };
				        const setPref = (v) => {
				          try { localStorage.setItem(ORIENT_KEY, v); } catch {}
				        };

				        // PWA/独立模式下默认锁定竖屏，避免误横屏（可手动关闭）
				        try {
				          if (!getPref() && isPWA()) setPref('portrait');
				        } catch {}

				        const syncBtn = () => {
				          const v = getPref();
				          const wants = v === 'portrait';
				          const on = wants && isActuallyLocked;
				          try { orientationBtn.classList.toggle('active', on); } catch {}
				          try {
				            if (on) orientationBtn.title = '旋转：已锁定竖屏（点击允许旋转）';
				            else if (wants) orientationBtn.title = '旋转：将尝试锁定竖屏（需浏览器支持/可能需PWA或HTTPS）';
				            else orientationBtn.title = '旋转：允许旋转（点击锁定竖屏）';
				          } catch {}
				        };

				        const unlock = () => {
				          try { screen?.orientation?.unlock?.(); } catch {}
				          isActuallyLocked = false;
				        };

				        const lockPortrait = async ({ silent = false } = {}) => {
				          try {
				            if (!window.isSecureContext) {
				              if (!silent) showToast('⚠️ 锁定旋转需要HTTPS安全上下文（或localhost）');
				              return false;
				            }
				            if (!screen?.orientation?.lock) {
				              if (!silent) showToast('⚠️ 当前浏览器不支持锁定旋转');
				              return false;
				            }
				            await screen.orientation.lock('portrait-primary');
				            isActuallyLocked = true;
				            return true;
				          } catch (e) {
				            // 常见：需要一次用户手势 / 仅 PWA 或全屏可用
				            if (!silent) showToast('⚠️ 锁定旋转失败：可能需要在PWA/全屏或点击后生效');
				            isActuallyLocked = false;
				            return false;
				          }
				        };

				        const applyPref = async ({ silent = false } = {}) => {
				          const v = getPref();
				          if (v === 'portrait') {
				            // 先清空实际锁定状态，避免“徒有其表”
				            isActuallyLocked = false;
				            syncBtn();
				            const ok = await lockPortrait({ silent: true });
				            if (ok) {
				              syncBtn();
				              if (!silent) showToast('✅ 已锁定竖屏');
				              return;
				            }

				            // 兜底：等下一次用户交互再试一次，提升成功率（只有在安全上下文且支持 API 时才值得重试）
				            if (window.isSecureContext && screen?.orientation?.lock) {
				              const retry = async () => {
				                document.removeEventListener('touchstart', retry, true);
				                document.removeEventListener('click', retry, true);
				                const ok2 = await lockPortrait({ silent });
				                syncBtn();
				                if (ok2 && !silent) showToast('✅ 已锁定竖屏');
				                if (!ok2 && !silent) {
				                  setPref('off');
				                  unlock();
				                  syncBtn();
				                }
				              };
				              document.addEventListener('touchstart', retry, { capture: true, once: true, passive: true });
				              document.addEventListener('click', retry, { capture: true, once: true });
				              syncBtn();
				            } else {
				              // 无法锁定：回退为 off，避免按钮表现与实际不一致
				              if (!silent) showToast('⚠️ 当前环境无法锁定旋转（建议使用HTTPS或安装PWA）');
				              setPref('off');
				              unlock();
				              syncBtn();
				            }
				          } else {
				            unlock();
				            syncBtn();
				            if (!silent) showToast('✅ 已允许旋转');
				          }
				        };

				        orientationBtn.onclick = async (e) => {
				          e.preventDefault();
				          e.stopPropagation();
				          const v = getPref();
				          const next = v === 'portrait' ? 'off' : 'portrait';
				          setPref(next);
				          await applyPref();
				        };

				        // 初始化：按偏好应用一次（尽量静默，避免首次弹 toast）
				        applyPref({ silent: true }).catch(() => {});
				      }

				      // 将“复制/粘贴”能力保留为逻辑函数（从工具栏移除按钮，但手势/快捷键仍可触发）
				      async function copyLastOutput() {
				        const s = getActive();
				        if (!s?.term) {
				          showToast('❌ 没有活动的终端会话');
				          return;
				        }
				        const latest =
				          (s.lastReplyText && s.lastReplyText.trim())
				            ? s.lastReplyText.trimEnd()
				            : ((s.lastReplyLine && s.lastReplyLine.trim()) ? s.lastReplyLine : getLatestNonEmptyLine(s.term));
				        const cleaned = stripTerminalControl(latest).trimEnd();
				        if (!cleaned) {
				          showToast('⚠️ 没有可复制的内容');
				          return;
				        }
				        const ok = await writeClipboard(cleaned);
				        showToast(ok ? '✅ 已复制最后一次输出' : '❌ 复制失败（请允许剪贴板权限）');
				      }

				      async function pasteClipboard() {
				        try {
				          const text = await readClipboard();
				          if (!text) {
				            // 无权限/为空：改为弹出输入框，保证“二指长按粘贴”总有可用回退
				            openPasteModal();
				            showToast('⚠️ 无法读取剪贴板，已打开粘贴输入框');
				            return;
				          }
				          pasteTextToActiveTerminal(text);
				        } catch {
				          openPasteModal();
				          showToast('⚠️ 无法读取剪贴板，已打开粘贴输入框');
				        }
				      }

					      // 在终端区域启用手势：终端区域滚动；底部空白区域单指滑动发送方向键；二指点按复制；二指长按粘贴
					      try {
					        initTerminalGestures({
					          termArea: document.getElementById('term-area'),
					          cursorPad: document.getElementById('cursor-pad'),
					          onCopy: copyLastOutput,
					          onPaste: pasteClipboard,
					        });
					      } catch {}

				      // 让键盘快捷键（移动端 Ctrl+Shift+C / Ctrl+Shift+V）可以复用
				      try {
				        window.__lanShellQuickActions = { copyLastOutput, pasteClipboard };
				      } catch {}

				      // 撤回：终端没有通用“撤销”，这里提供最常用的 Ctrl+U（清空当前输入行）
				      undoBtn.onclick = (e) => {
				        e.preventDefault();
				        e.stopPropagation();
				        sendToTerminal('\x15', '✅ 已发送撤回（Ctrl+U）');
				      };

			      function openDrawer() {
			        try {
			          const w = drawer.getBoundingClientRect().width || drawer.offsetWidth || 0;
			          document.documentElement.style.setProperty('--drawer-w', `${w}px`);
			        } catch {}
			        drawer.classList.add('open');
			        backdrop.classList.add('open');
			        drawer.setAttribute('aria-hidden', 'false');
			        toggleBtn.parentElement?.classList?.add('open');
			      }
		      function closeDrawer() {
		        drawer.classList.remove('open');
		        backdrop.classList.remove('open');
		        drawer.setAttribute('aria-hidden', 'true');
		        toggleBtn.parentElement?.classList?.remove('open');
		      }
		      function toggleDrawer() {
		        if (drawer.classList.contains('open')) closeDrawer();
		        else openDrawer();
		      }

			      toggleBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        toggleDrawer();
			      };
			      floatingCmdBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        if (floatingCmdBtn.__suppressClickOnce) {
			          floatingCmdBtn.__suppressClickOnce = false;
			          return;
			        }
			        try { openCommandSetsPage(); } catch {}
			      };

			      // 长按“指令集”按钮：进入 Git 页面（若未初始化 Git，则提示是否 git init）
			      {
			        let timer = null;
			        const longPressMs = 520;
			        const start = () => {
			          try {
			            if (timer) clearTimeout(timer);
			            timer = setTimeout(() => {
			              // 禁止在根目录（.）/隐藏目录打开 Git 管理页
			              try {
			                const s = getActive?.();
			                const cwd = s?.cwd || document.getElementById('path')?.value || '.';
			                const raw = String(cwd || '').trim();
			                const parts = raw.split(/[\\/]+/).filter(Boolean);
			                const hasHidden = parts.some((p) => p.startsWith('.') && p !== '.' && p !== '..');
			                if (raw === '.') {
			                  showToast('⚠️ 根目录（.）禁止打开 Git 管理页');
			                  return;
			                }
			                if (hasHidden) {
			                  showToast('⚠️ 隐藏目录禁止打开 Git 管理页');
			                  return;
			                }
			              } catch {}
			              try { floatingCmdBtn.__suppressClickOnce = true; } catch {}
			              try { window.openGitPage?.({ promptInit: true }); } catch {}
			            }, longPressMs);
			          } catch {}
			        };
			        const cancel = () => {
			          if (timer) clearTimeout(timer);
			          timer = null;
			        };
			        floatingCmdBtn.addEventListener('pointerdown', start);
			        floatingCmdBtn.addEventListener('pointerup', cancel);
			        floatingCmdBtn.addEventListener('pointercancel', cancel);
			        floatingCmdBtn.addEventListener('pointerleave', cancel);
			      }
		      closeBtn.onclick = (e) => {
		        e.preventDefault();
		        e.stopPropagation();
		        closeDrawer();
		      };
		      backdrop.onclick = closeDrawer;

		      // Keep the toggle button aligned with drawer width
		      window.addEventListener('resize', () => {
		        if (!drawer.classList.contains('open')) return;
		        try {
		          const w = drawer.getBoundingClientRect().width || drawer.offsetWidth || 0;
		          document.documentElement.style.setProperty('--drawer-w', `${w}px`);
		        } catch {}
		      });

		      // copyLastOutput / pasteClipboard 已上移：工具栏移除按钮后仍供手势/快捷键调用

			      function openPasteModal() {
			        try {
			          pasteInput.value = '';
			          pasteModalBackdrop.classList.add('open');
			          pasteModal.classList.add('open');
			          pasteModalBackdrop.setAttribute('aria-hidden', 'false');
			          pasteModal.setAttribute('aria-hidden', 'false');
			          setTimeout(() => { try { pasteInput.focus(); } catch {} }, 0);
			        } catch {}
			      }

			      function closePasteModal() {
			        try {
			          pasteModalBackdrop.classList.remove('open');
			          pasteModal.classList.remove('open');
			          pasteModalBackdrop.setAttribute('aria-hidden', 'true');
			          pasteModal.setAttribute('aria-hidden', 'true');
			        } catch {}
			      }

				      function sendPasteText(text) {
				        return pasteTextToActiveTerminal(text);
				      }

			      function sendToTerminal(data, okMsg) {
			        const s = getActive();
			        if (s?.type === 'editor') {
			          showToast('⚠️ 当前是编辑器窗口，请切换到终端窗口再发送按键');
			          return;
			        }
			        if (!s?.ws || s.ws.readyState !== 1) {
			          showToast('❌ 终端未连接');
			          return;
			        }
			        s.ws.send(data);
			        if (okMsg) showToast(okMsg);
			      }

			      // 触控手势：通过手势触发右侧工具栏的既有能力（不改原快捷键/按钮逻辑）
			      function initTerminalGestures({ termArea, cursorPad, onCopy, onPaste } = {}) {
			        if (!termArea || termArea.__lanShellGesturesInstalled) return;
			        termArea.__lanShellGesturesInstalled = true;

			        const TAP_MAX_MS = 260;
			        const LONG_PRESS_MS = 520;
			        const TAP_MAX_MOVE = 12; // px
			        const AXIS_LOCK_THRESHOLD = 10; // px
			        const STEP_PX = 18; // px：每移动多少像素发送一次方向键

			        const state = {
			          one: null,
			          multi: null,
			        };

			        function followEditorCursorSmoothly(cm, { marginLines = 1 } = {}) {
			          try {
			            if (!cm) return;
			            const info = cm.getScrollInfo?.();
			            if (!info) return;
			            const lineH = (typeof cm.defaultTextHeight === 'function' ? cm.defaultTextHeight() : 18) || 18;
			            const marginPx = Math.max(0, Number.parseInt(String(marginLines), 10) || 0) * lineH;
			            const coords = cm.cursorCoords?.(null, 'local') || cm.charCoords?.(cm.getCursor?.(), 'local');
			            if (!coords) return;

			            const topEdge = marginPx;
			            const bottomEdge = info.clientHeight - marginPx;

			            // 只在光标触碰到可视区域边缘后“跟随滚动”，且每次最多滚动 1 行高度，避免跳行眩晕
			            if (coords.top < topEdge) {
			              const delta = Math.min(lineH, topEdge - coords.top);
			              cm.scrollTo(null, Math.max(0, info.top - delta));
			            } else if (coords.bottom > bottomEdge) {
			              const delta = Math.min(lineH, coords.bottom - bottomEdge);
			              cm.scrollTo(null, info.top + delta);
			            }
			          } catch {}
			        }

			        // 编辑器方向移动“节流/分帧”：
			        // 触控板一次滑动可能产生大量 steps，如果同步循环执行，会出现“光标跑出屏幕后才突然跳回”的观感。
			        // 这里把编辑器的方向移动拆到多帧里执行，让滚动能持续跟上光标。
			        const editorArrowQueue = {
			          esc: null,
			          remaining: 0,
			          raf: 0,
			        };

			        function pumpEditorArrowQueue() {
			          try {
			            editorArrowQueue.raf = 0;
			            const s = getActive();
			            if (!s || s.type !== 'editor' || !s.cm) {
			              editorArrowQueue.remaining = 0;
			              return;
			            }
			            const cm = s.cm;
			            const map = {
			              '\x1b[A': 'goLineUp',
			              '\x1b[B': 'goLineDown',
			              '\x1b[C': 'goCharRight',
			              '\x1b[D': 'goCharLeft',
			            };
			            const cmd = map[editorArrowQueue.esc];
			            if (!cmd) {
			              editorArrowQueue.remaining = 0;
			              return;
			            }

			            // 每帧最多移动 N 次，兼顾“跟手”与“平滑”
			            const PER_FRAME = 3;
			            const n = Math.min(PER_FRAME, editorArrowQueue.remaining);
			            for (let i = 0; i < n; i += 1) {
			              try { cm.execCommand(cmd); } catch {}
			            }
			            editorArrowQueue.remaining -= n;
			            followEditorCursorSmoothly(cm, { marginLines: 1 });
			            try { cm.focus(); } catch {}

			            if (editorArrowQueue.remaining > 0) {
			              editorArrowQueue.raf = requestAnimationFrame(pumpEditorArrowQueue);
			            }
			          } catch {}
			        }

			        function enqueueEditorArrow(esc, steps) {
			          try {
			            if (!steps) return;
			            // 如果方向变了，重置队列（避免“先上后下”累计后延迟执行）
			            if (editorArrowQueue.esc && editorArrowQueue.esc !== esc) editorArrowQueue.remaining = 0;
			            editorArrowQueue.esc = esc;
			            editorArrowQueue.remaining = Math.min(120, editorArrowQueue.remaining + Math.abs(steps));
			            if (!editorArrowQueue.raf) editorArrowQueue.raf = requestAnimationFrame(pumpEditorArrowQueue);
			          } catch {}
			        }

			        function sendArrowSilent(esc) {
			          const s = getActive();
			          if (!s) return false;

			          // 编辑器：把方向键映射为 CodeMirror 光标移动，并自动滚动到光标
			          if (s.type === 'editor') {
			            const cm = s.cm;
			            if (!cm) return false;
			            const map = {
			              '\x1b[A': 'goLineUp',
			              '\x1b[B': 'goLineDown',
			              '\x1b[C': 'goCharRight',
			              '\x1b[D': 'goCharLeft',
			            };
			            const cmd = map[esc];
			            if (!cmd) return false;
			            try {
			              cm.execCommand(cmd);
			              followEditorCursorSmoothly(cm, { marginLines: 1 });
			              cm.focus();
			            } catch {}
			            return true;
			          }

			          // 终端：发送真实方向键序列
			          if (s.type === 'term') {
			            if (!s.ws || s.ws.readyState !== 1) {
			              showToast('❌ 终端未连接');
			              return false;
			            }
			            try { s.ws.send(esc); } catch { return false; }
			            return true;
			          }

			          return false;
			        }

			        function fireCopyIfTerminal() {
			          const s = getActive();
			          if (s?.type !== 'term') return;
			          try { onCopy?.(); } catch {}
			        }

			        function firePasteIfTerminal() {
			          const s = getActive();
			          if (s?.type !== 'term') return;
			          try { onPaste?.(); } catch {}
			        }

			        function dist(x1, y1, x2, y2) {
			          const dx = x2 - x1;
			          const dy = y2 - y1;
			          return Math.hypot(dx, dy);
			        }

			        function startOneFinger(t) {
			          state.one = {
			            active: true,
			            startX: t.clientX,
			            startY: t.clientY,
			            lastX: t.clientX,
			            lastY: t.clientY,
			            totalX: 0,
			            totalY: 0,
			            axis: null, // 'x' | 'y'
			            accum: 0,
			          };
			          state.multi = null;
			        }

			        function startMultiFinger(e) {
			          const touches = Array.from(e.touches || []);
			          const count = touches.length;
			          const startMap = new Map();
			          for (const t of touches) startMap.set(t.identifier, { x: t.clientX, y: t.clientY });
			          state.multi = {
			            active: true,
			            count,
			            startTs: Date.now(),
			            startMap,
			            maxMove: 0,
			            endedCount: 0,
			            longPressTimer: null,
			            longPressFired: false,
			            cancelled: false,
			          };
			          state.one = null;

			          // 二指长按：粘贴（等价点击右侧 PASTE）
			          if (count === 2) {
			            try {
			              state.multi.longPressTimer = setTimeout(() => {
			                const m = state.multi;
			                if (!m?.active || m.longPressFired) return;
			                if (m.cancelled) return;
			                if (m.maxMove > TAP_MAX_MOVE) return;
			                m.longPressFired = true;
			                // 长按已触发：不再将其判定为“二指点按复制”
			                m.cancelled = true;
			                firePasteIfTerminal();
			              }, LONG_PRESS_MS);
			            } catch {}
			          }
			        }

			        function cancelMultiLongPressTimer() {
			          const m = state.multi;
			          if (!m) return;
			          if (m.longPressTimer) {
			            try { clearTimeout(m.longPressTimer); } catch {}
			            m.longPressTimer = null;
			          }
			        }

			        function updateMultiFingerByTouches(m, touches) {
			          for (const t of Array.from(touches || [])) {
			            const s = m.startMap.get(t.identifier);
			            if (!s) continue;
			            m.maxMove = Math.max(m.maxMove, dist(s.x, s.y, t.clientX, t.clientY));
			          }
			          if (m.maxMove > TAP_MAX_MOVE) m.cancelled = true;
			        }

			        function updateMultiFinger(e) {
			          const m = state.multi;
			          if (!m?.active) return;
			          if ((e.touches?.length || 0) !== m.count) {
			            m.cancelled = true;
			            cancelMultiLongPressTimer();
			            return;
			          }
			          updateMultiFingerByTouches(m, e.touches);
			          if (m.maxMove > TAP_MAX_MOVE) cancelMultiLongPressTimer();
			        }

			        function tryFireMultiTapIfDone({ force = false } = {}) {
			          const m = state.multi;
			          if (!m?.active) return;
			          cancelMultiLongPressTimer();
			          if (!force && m.endedCount < m.count) return;
			          const elapsed = Date.now() - m.startTs;
			          const ok = !m.cancelled && elapsed <= TAP_MAX_MS && m.maxMove <= TAP_MAX_MOVE;
			          const count = m.count;
			          state.multi = null;
			          if (!ok) return;
			          if (count === 2) {
			            fireCopyIfTerminal();
			          }
			        }

			        function handleOneFingerMove(e) {
			          const o = state.one;
			          if (!o?.active) return;
			          if ((e.touches?.length || 0) !== 1) return;

			          // 单指移动：仅在底部“空白触控板”区域启用，阻止滚动，把触控当作“触控板/方向键”
			          try { e.preventDefault(); } catch {}

			          const t = e.touches[0];
			          const dx = t.clientX - o.lastX;
			          const dy = t.clientY - o.lastY;
			          o.lastX = t.clientX;
			          o.lastY = t.clientY;

			          o.totalX = t.clientX - o.startX;
			          o.totalY = t.clientY - o.startY;

			          if (!o.axis) {
			            const ax = Math.abs(o.totalX);
			            const ay = Math.abs(o.totalY);
			            if (ax >= AXIS_LOCK_THRESHOLD || ay >= AXIS_LOCK_THRESHOLD) {
			              o.axis = ax >= ay ? 'x' : 'y';
			            }
			          }

			          if (!o.axis) return;

			          if (o.axis === 'x') {
			            o.accum += dx;
			            const steps = Math.trunc(o.accum / STEP_PX);
			            if (!steps) return;
			            o.accum -= steps * STEP_PX;
			            const key = steps > 0 ? '\x1b[C' : '\x1b[D';
			            const s = getActive();
			            if (s?.type === 'editor') enqueueEditorArrow(key, steps);
			            else for (let i = 0; i < Math.abs(steps); i += 1) sendArrowSilent(key);
			          } else {
			            o.accum += dy;
			            const steps = Math.trunc(o.accum / STEP_PX);
			            if (!steps) return;
			            o.accum -= steps * STEP_PX;
			            const key = steps > 0 ? '\x1b[B' : '\x1b[A';
			            const s = getActive();
			            if (s?.type === 'editor') enqueueEditorArrow(key, steps);
			            else for (let i = 0; i < Math.abs(steps); i += 1) sendArrowSilent(key);
			          }
			        }

			        // 多指手势依然在终端区域触发（不干预滚动）
			        termArea.addEventListener(
			          'touchstart',
			          (e) => {
			            const n = e.touches?.length || 0;
			            if (n === 2 || n === 3) startMultiFinger(e);
			            else {
			              state.multi = null;
			            }
			          },
			          { passive: true, capture: true }
			        );

			        termArea.addEventListener(
			          'touchmove',
			          (e) => {
			            if (state.multi?.active) {
			              updateMultiFinger(e);
			              return; // 双指滚动/三指滑动：不干预
			            }
			          },
			          { passive: false, capture: true }
			        );

			        termArea.addEventListener(
			          'touchend',
			          (e) => {
			            if (state.multi?.active) {
			              // 注意：多指点按会分多次触发 touchend（先抬起一根，再抬起另一根），不能在中途直接取消。
			              state.multi.endedCount += (e.changedTouches?.length || 0);
			              // 记录松开瞬间的位置（部分浏览器 touchmove 不一定覆盖到）
			              updateMultiFingerByTouches(state.multi, e.changedTouches);
			              // 二指长按已经触发时，不再尝试点按判定
			              if (state.multi.longPressFired) {
			                cancelMultiLongPressTimer();
			                if ((e.touches?.length || 0) === 0) state.multi = null;
			              } else {
			              tryFireMultiTapIfDone({ force: (e.touches?.length || 0) === 0 });
			              }
			            }
			          },
			          { passive: true, capture: true }
			        );

			        termArea.addEventListener(
			          'touchcancel',
			          () => {
			            cancelMultiLongPressTimer();
			            state.multi = null;
			          },
			          { passive: true, capture: true }
			        );

			        // 单指移动光标：只在底部空白区域启用；若没有 cursorPad，则回退到 termArea（兼容旧布局）
			        const pad = cursorPad || termArea;
			        pad.addEventListener(
			          'touchstart',
			          (e) => {
			            const n = e.touches?.length || 0;
			            if (n === 1) startOneFinger(e.touches[0]);
			            else state.one = null;
			          },
			          { passive: true, capture: true }
			        );
			        pad.addEventListener(
			          'touchmove',
			          (e) => {
			            if (state.one?.active) handleOneFingerMove(e);
			          },
			          { passive: false, capture: true }
			        );
			        pad.addEventListener(
			          'touchend',
			          (e) => {
			            if ((e.touches?.length || 0) === 0) state.one = null;
			          },
			          { passive: true, capture: true }
			        );
			        pad.addEventListener(
			          'touchcancel',
			          () => {
			            state.one = null;
			          },
			          { passive: true, capture: true }
			        );
			      }

			      // Ctrl / Alt 组合键一次性开关
			      let pendingCtrl = false;
			      let pendingAlt = false;
			      let pendingShift = false;

			      function resetModifiers() {
			        pendingCtrl = false;
			        pendingAlt = false;
			        pendingShift = false;
			        // 移除旧的工具栏状态（已删除）
			        try { document.getElementById('comboCtrlBtn')?.classList?.remove('active'); } catch {}
			        try { document.getElementById('comboAltBtn')?.classList?.remove('active'); } catch {}
			        try { document.getElementById('comboShiftBtn')?.classList?.remove('active'); } catch {}
			      }

			      function sendCtrlCombo(ch) {
			        const key = String(ch || '').toUpperCase();
			        if (!key || key.length !== 1) return false;
			        const code = key.charCodeAt(0);
			        // A-Z -> ctrl: code & 0x1f
			        if (code < 64 || code > 90) return false;
			        const ctrlChar = String.fromCharCode(code & 0x1f);
			        const s = getActive();
			        if (!s?.ws || s.ws.readyState !== 1) {
			          showToast('❌ 终端未连接');
			          return false;
			        }
			        // Alt 同时按下：ESC 前缀
			        const payload = pendingAlt ? `\x1b${ctrlChar}` : ctrlChar;
			        s.ws.send(payload);
			        showToast(pendingAlt ? `✅ 发送 Alt+Ctrl+${key}` : `✅ 发送 Ctrl+${key}`);
			        resetModifiers();
			        return true;
			      }

			      function sendAltCombo(ch) {
			        const key = String(ch || '');
			        if (!key || key.length !== 1) return false;
			        const s = getActive();
			        if (!s?.ws || s.ws.readyState !== 1) {
			          showToast('❌ 终端未连接');
			          return false;
			        }
			        s.ws.send(`\x1b${key}`);
			        showToast(`✅ 发送 Alt+${key}`);
			        resetModifiers();
			        return true;
			      }

			      function handleModifierKeydown(e) {
			        // 弹出式组合键模式下不拦截输入框的按键
			        if (comboModal?.classList?.contains('open')) return;
			        if (!pendingCtrl && !pendingAlt) return;
			        // 忽略功能键
			        if (e.key && e.key.length === 1) {
			          e.preventDefault();
			          e.stopPropagation();
			          const k = e.key;
			          if (pendingCtrl) {
			            const ok = sendCtrlCombo(k);
			            if (!ok && pendingAlt) sendAltCombo(k); // 回退为 alt+key
			            else if (!ok) resetModifiers();
			          } else if (pendingAlt) {
			            sendAltCombo(k);
			          }
			        }
			        // 任何按键都清理状态，避免卡住
			        resetModifiers();
			      }

			      // 组合键弹窗逻辑
			      const comboBackdrop = document.getElementById('combo-modal-backdrop');
			      const comboModal = document.getElementById('combo-modal');
			      const comboCtrlBtn = document.getElementById('comboCtrlBtn');
			      const comboAltBtn = document.getElementById('comboAltBtn');
			      const comboShiftBtn = document.getElementById('comboShiftBtn');
			      const comboInput = document.getElementById('combo-input');
			      const comboCloseBtn = document.getElementById('comboModalCloseBtn');
			      const comboCancelBtn = document.getElementById('comboModalCancelBtn');
			      const comboOkBtn = document.getElementById('comboModalOkBtn');

			      function toggleCombo(btn, flagKey) {
			        btn.classList.toggle('active');
			        if (flagKey === 'ctrl') pendingCtrl = btn.classList.contains('active');
			        if (flagKey === 'alt') pendingAlt = btn.classList.contains('active');
			        if (flagKey === 'shift') pendingShift = btn.classList.contains('active');
			      }

			      function openComboModal() {
			        comboBackdrop.classList.add('open');
			        comboModal.classList.add('open');
			        comboBackdrop.setAttribute('aria-hidden', 'false');
			        comboModal.setAttribute('aria-hidden', 'false');
			        setTimeout(() => { try { comboInput.focus(); } catch {} }, 0);
			      }
			      function closeComboModal() {
			        comboBackdrop.classList.remove('open');
			        comboModal.classList.remove('open');
			        comboBackdrop.setAttribute('aria-hidden', 'true');
			        comboModal.setAttribute('aria-hidden', 'true');
			        resetModifiers();
			        comboInput.value = '';
			      }

			      function buildComboPayload(text) {
			        const chars = String(text || '').split('');
			        if (!chars.length) {
			          showToast('⚠️ 请输入要发送的字符');
			          return null;
			        }
			        let payload = '';
			        for (const ch of chars) {
			          let c = ch;
			          const upper = c.toUpperCase();
			          if (pendingCtrl) {
			            const code = upper.charCodeAt(0);
			            if (code >= 64 && code <= 95) {
			              c = String.fromCharCode(code & 0x1f);
			            }
			          } else if (pendingShift) {
			            c = upper;
			          }
			          if (pendingAlt) {
			            payload += `\x1b${c}`;
			          } else {
			            payload += c;
			          }
			        }
			        return payload;
			      }

			      function sendComboFromModal() {
			        const payload = buildComboPayload(comboInput.value);
			        if (!payload) return;
			        try {
			          const s = getActive();
			          s.ws.send(payload);
			          const mods = [
			            pendingCtrl ? 'Ctrl' : null,
			            pendingAlt ? 'Alt' : null,
			            pendingShift ? 'Shift' : null,
			          ].filter(Boolean).join('+');
			          showToast(`✅ 已发送 ${mods ? mods + '+' : ''}${comboInput.value}`);
			        } catch {
			          showToast('❌ 发送失败');
			        }
			        closeComboModal();
			      }

			      comboBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); openComboModal(); };
			      comboCloseBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeComboModal(); };
			      comboCancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closeComboModal(); };
			      comboOkBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); sendComboFromModal(); };
			      comboCtrlBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); toggleCombo(comboCtrlBtn, 'ctrl'); };
			      comboAltBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); toggleCombo(comboAltBtn, 'alt'); };
			      comboShiftBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); toggleCombo(comboShiftBtn, 'shift'); };

			      comboInput.addEventListener('keydown', (e) => {
			        if (e.key === 'Escape') {
			          e.preventDefault(); closeComboModal(); return;
			        }
			        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
			          e.preventDefault();
			          sendComboFromModal();
			        }
			      });
			      // removed: COPY/PASTE/UP/DOWN buttons in toolbar
				      tabBtn.onclick = (e) => {
				        e.preventDefault();
				        e.stopPropagation();
				        sendToTerminal('\t', '✅ TAB');
				      };
				      enterBtn.onclick = (e) => {
				        e.preventDefault();
				        e.stopPropagation();
				        sendToTerminal('\r', '✅ ENTER');
				      };
			      escBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        sendToTerminal('\x1b', '✅ 已发送 ESC');
			      };
			      ctrlCBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        sendToTerminal('\x03', '✅ 已发送 Ctrl+C');
			      };

			      continueBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const s = getActive();
			        if (!s?.ws || s.ws.readyState !== 1) {
		          showToast('❌ 终端未连接');
		          return;
		        }
		        // Macro: ESC -> "continue" -> Enter
		        // IMPORTANT: avoid sending ESC immediately followed by "c" (ESC c == RIS reset in many terminals),
		        // which can swallow the "c" and make it look like "ontinue".
		        s.ws.send('\x1b');
		        setTimeout(() => {
		          try { s.ws.send('continue'); } catch {}
		          setTimeout(() => {
		            try { s.ws.send('\r'); } catch {}
		          }, 30);
		        }, 80);
			        showToast('✅ CONT');
			      };

			      // 捕获阶段优先截获，防止按键先被 xterm 吃掉（尤其移动端）
			      document.addEventListener('keydown', (e) => {
			        if (e.key === 'Escape' && drawer.classList.contains('open')) {
			          closeDrawer();
			          return;
			        }
			        handleModifierKeydown(e);
			      }, true);

			      // removed: PASTE button long-press (use two-finger long-press or fallback modal)

			      pasteModalBackdrop.onclick = closePasteModal;
			      pasteModalCloseBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closePasteModal(); };
			      pasteModalCancelBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); closePasteModal(); };
			      pasteModalOkBtn.onclick = (e) => {
			        e.preventDefault();
			        e.stopPropagation();
			        const ok = sendPasteText(pasteInput.value);
			        if (ok) closePasteModal();
			      };
			      pasteInput.addEventListener('keydown', (e) => {
			        if (e.key === 'Escape') {
			          e.preventDefault();
			          closePasteModal();
			          return;
			        }
			        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
			          e.preventDefault();
			          const ok = sendPasteText(pasteInput.value);
			          if (ok) closePasteModal();
			        }
			      });
			    }

	    function removeTerminal(id) {
	      const idx = sessions.findIndex(s => s.id === id);
	      if (idx === -1) return;
	      const s = sessions[idx];
	      // 先标记，避免 ws 关闭时触发自动重连逻辑
	      try {
	        if (s.ws) {
	          s.suppressClose = true;
	          s.ws.close();
	        }
	      } catch (e) {
	        console.warn('关闭终端 WS 失败', e);
	      }

	      try { s.inputDisposable?.dispose(); } catch (e) { console.warn('inputDisposable dispose 失败', e); }
	      try { s.resizeListener?.dispose(); } catch (e) { console.warn('resizeListener dispose 失败', e); }
	      try { s.resizeObserver?.disconnect(); } catch (e) { console.warn('resizeObserver disconnect 失败', e); }
	      try { if (s._termFlushTimer) clearTimeout(s._termFlushTimer); } catch {}

	      // 防御性释放：即便某一步抛错也要继续移除标签与面板，避免出现“点一次空白、点两次才关闭”
	      try { s.term?.dispose?.(); } catch (e) { console.warn('xterm dispose 失败', e); }
	      try { s.pane?.remove?.(); } catch (e) { console.warn('pane remove 失败', e); }
	      try { s.tab?.remove?.(); } catch (e) { console.warn('tab remove 失败', e); }

	      sessions.splice(idx, 1);
	      if (activeId === id) {
	        if (sessions.length) setActive(sessions[0].id);
	        else activeId = null;
	      }
	    }

	    // Close terminal: delete the unique session id so it won't be restored.
		    function closeTerminal(id) {
		      const s = sessions.find(s => s.id === id);
		      if (!s) return;

		      if (s.sessionId) {
		        fetch(
		          `/api/sessions/${encodeURIComponent(s.sessionId)}?clientId=${encodeURIComponent(clientId)}&token=${encodeURIComponent(authToken)}`,
		          { method: 'DELETE' }
		        ).catch(() => {});
		      }

		      removeTerminal(id);
		    }

    document.getElementById('load').onclick = () => {
      const p = document.getElementById('path').value;
      loadDir(p);
    };
    document.getElementById('newTerm').onclick = () => {
      const p = document.getElementById('path').value;
      createTerminal(p);
    };

    // 初始化：尝试恢复现有会话或创建新会话
	    async function initializeTerminals() {
	      const existingSessions = await loadExistingSessions();

	      if (existingSessions.length > 0) {
	        // Restore ALL sessions that still exist on the server for this clientId.
	        const sorted = existingSessions
	          .slice()
	          .sort((a, b) => new Date(a.created || 0) - new Date(b.created || 0))
	          .slice(-50); // safety cap

	        console.log('恢复现有会话数量:', sorted.length);
	        const restored = sorted.map(s => createTerminal(s?.cwd || '.', null, s.id));

	        // Focus the most recently active session (fallback: first).
	        const focusId =
	          sorted
	            .slice()
	            .sort((a, b) => new Date(b.lastActivity || 0) - new Date(a.lastActivity || 0))[0]?.id || restored[0]?.id;
	        if (focusId) setActive(focusId);
	        return;
	      }

	      // No existing sessions: create a new one.
	      console.log('创建新终端会话');
	      const created = createTerminal('.');
	      setActive(created.id);
	    }

	    let hasInitialized = false;
	    function initializeOnce() {
      if (hasInitialized) return;
      hasInitialized = true;

      console.log('开始初始化...');

      // 检测Edge并应用专用样式
      if (/Edg/i.test(navigator.userAgent)) {
        console.log('检测到Edge浏览器');
        applyEdgePWAStyles();
      }

      // 应用PWA样式
      applyPWAStyles();

      // 强制移动端全屏
      forceMobileFullscreen();

      // 如果是PWA模式，隐藏地址栏
      if (isPWA()) {
        console.log('PWA模式已激活');
        hideAddressBar();
      }

	      // 启动单设备token管理
	      if (authToken) {
	        startSingleDeviceTokenManagement();
	        console.log('✅ 单设备Token管理已启动');
	      }

      // 初始化指令集页面
      initCommandSets();

      // 初始化 Git 页面
      initGitPage();

      // 初始化文件新建/上传
      installFileModal();
      // 初始化解压弹窗
      installExtractModal();
      // 初始化“显示隐藏文件”开关
      installHiddenToggle();

      initSideActions();
      loadDir('.');
      initializeTerminals();
    }

    // 页面初始化（确保只执行一次，避免重复创建终端会话）
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded');
      initializeOnce();
    });

    if (document.readyState !== 'loading') {
      console.log('DOM已就绪（readyState）');
      initializeOnce();
    }

    // 单设备Token管理功能 - 严格模式
    let activityRefreshInterval;
    let sseConnection = null;
    
    // Token持久化管理
    const TOKEN_STORAGE_KEY = 'lanshell_auth_token';
    const TOKEN_EXPIRY_KEY = 'lanshell_token_expiry';
    
    // 清除保存的token
    function clearSavedToken() {
      try {
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        localStorage.removeItem(TOKEN_EXPIRY_KEY);
        console.log('🗑️ 已清除保存的token');
      } catch (error) {
        console.error('清除token失败:', error);
      }
    }
    
    // 强制登出处理
    function handleForceLogout(reason, message) {
      console.log(`🚨 收到强制登出通知: ${reason}`);
      
      // 清除本地token
      clearSavedToken();
      
      // 停止所有活动
      stopTokenManagement();
      
      // 关闭SSE连接
      if (sseConnection) {
        sseConnection.close();
        sseConnection = null;
      }
      
      // 显示通知
      showToast(`🚨 ${message || '您已被强制登出'}`);
      
      // 延迟跳转到登录页面
      setTimeout(() => {
        window.location.href = '/';
      }, 3000);
    }
    
    // 建立SSE连接监听强制登出
    function establishSSEConnection() {
      if (!authToken) return;
      
      try {
        console.log('📡 建立SSE连接监听强制登出...');
        sseConnection = new EventSource(`/api/events?token=${encodeURIComponent(authToken)}`);
        
        sseConnection.onopen = function(event) {
          console.log('✅ SSE连接已建立');
        };
        
        sseConnection.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            console.log('📡 收到SSE消息:', data);
            
            switch (data.type) {
              case 'connected':
                console.log(`📡 SSE连接确认: ${data.connectionId}`);
                break;
                
              case 'heartbeat':
                // 心跳消息，保持连接活跃
                break;
                
              case 'force_logout':
                console.log('🚨 收到强制登出指令');
                handleForceLogout(data.reason, data.message);
                break;
                
              default:
                console.log('📡 未知SSE消息类型:', data.type);
            }
          } catch (error) {
            console.error('解析SSE消息失败:', error);
          }
        };
        
        sseConnection.onerror = function(event) {
          console.error('❌ SSE连接错误:', event);
          
          // 重连逻辑
          setTimeout(() => {
            if (authToken && !sseConnection) {
              console.log('🔄 尝试重新建立SSE连接...');
              establishSSEConnection();
            }
          }, 5000);
        };
        
        sseConnection.onclose = function(event) {
          console.log('📡 SSE连接已关闭');
          sseConnection = null;
        };
        
      } catch (error) {
        console.error('建立SSE连接失败:', error);
      }
    }
    
    // 安全登出功能
    function secureLogout() {
      if (confirm('确定要退出登录吗？这将结束所有设备上的会话。')) {
        // 清除本地保存的token
        clearSavedToken();
        
        // 关闭SSE连接
        if (sseConnection) {
          sseConnection.close();
          sseConnection = null;
        }
        
        // 通知服务器登出
        fetch(`/api/logout?token=${encodeURIComponent(authToken)}`, {
          method: 'POST'
        }).then(() => {
          console.log('✅ 已安全登出');
        }).catch(error => {
          console.error('登出请求失败:', error);
        }).finally(() => {
          // 跳转到登录页面
          window.location.href = '/';
        });
      }
    }
    
    function startSingleDeviceTokenManagement() {
      // 建立SSE连接监听强制登出
      establishSSEConnection();
      
      // 每10分钟刷新一次活跃状态（更宽松）
      activityRefreshInterval = setInterval(async () => {
        try {
          const response = await fetch(`/api/refresh-activity?token=${encodeURIComponent(authToken)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (!response.ok) {
            console.log('⚠️ 定时Token刷新失败，但不强制退出');
            // 不强制退出，让用户继续使用
            // 只有在真正需要认证的操作时才会提示重新登录
          } else {
            console.log('✅ 定时活跃状态已刷新');
          }
        } catch (error) {
          console.error('⚠️ 定时活跃状态刷新失败（可能是网络问题）:', error);
          // 网络错误不应该导致强制退出
        }
      }, 10 * 60 * 1000); // 10分钟刷新一次
    }
    
    function stopTokenManagement() {
      if (activityRefreshInterval) {
        clearInterval(activityRefreshInterval);
        activityRefreshInterval = null;
      }
      
      if (sseConnection) {
        sseConnection.close();
        sseConnection = null;
      }
    }

    // 页面可见性变化时的处理 - 单设备简化版
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // 页面变为可见时
        console.log('📱 页面变为可见，开始验证token');
        if (isPWA()) {
          setTimeout(hideAddressBar, 100);
        }
        
        // 刷新活跃状态（静默处理，不强制跳转）
        if (authToken) {
          console.log(`🔍 发送活跃状态刷新请求，token: ${authToken ? authToken.substring(0, 8) + '...' : 'null'}`);
          fetch(`/api/refresh-activity?token=${encodeURIComponent(authToken)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
          .then(response => {
            console.log(`📡 活跃状态刷新响应: ${response.status}`);
            if (!response.ok) {
              console.log('⚠️ Token验证失败，但不强制退出（可能是短暂的网络问题）');
              // 不立即跳转，给用户继续使用的机会
              // 只在真正需要认证的操作时才会失败
            } else {
              console.log('✅ 切屏回来，活跃状态已刷新');
              return response.json();
            }
          })
          .then(data => {
            if (data) {
              console.log('📊 活跃状态刷新结果:', data);
            }
          })
          .catch(error => {
            console.error('⚠️ 活跃状态刷新失败（网络问题），继续使用:', error);
            // 网络错误不应该导致退出登录
          });
        }
      } else {
        console.log('📱 页面变为隐藏');
      }
    });
				  </script>
</body>
</html>
